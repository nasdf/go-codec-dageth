package dageth

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n _AccessElement) FieldAddress() Address {
	return &n.Address
}
func (n _AccessElement) FieldStorageKeys() StorageKeys {
	return &n.StorageKeys
}

type _AccessElement__Maybe struct {
	m schema.Maybe
	v AccessElement
}
type MaybeAccessElement = *_AccessElement__Maybe

func (m MaybeAccessElement) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAccessElement) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAccessElement) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAccessElement) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAccessElement) Must() AccessElement {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__AccessElement_Address     = _String{"Address"}
	fieldName__AccessElement_StorageKeys = _String{"StorageKeys"}
)
var _ ipld.Node = (AccessElement)(&_AccessElement{})
var _ schema.TypedNode = (AccessElement)(&_AccessElement{})

func (AccessElement) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n AccessElement) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "StorageKeys":
		return &n.StorageKeys, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n AccessElement) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (AccessElement) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.AccessElement"}.LookupByIndex(0)
}
func (n AccessElement) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n AccessElement) MapIterator() ipld.MapIterator {
	return &_AccessElement__MapItr{n, 0}
}

type _AccessElement__MapItr struct {
	n   AccessElement
	idx int
}

func (itr *_AccessElement__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AccessElement_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__AccessElement_StorageKeys
		v = &itr.n.StorageKeys
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AccessElement__MapItr) Done() bool {
	return itr.idx >= 2
}

func (AccessElement) ListIterator() ipld.ListIterator {
	return nil
}
func (AccessElement) Length() int64 {
	return 2
}
func (AccessElement) IsAbsent() bool {
	return false
}
func (AccessElement) IsNull() bool {
	return false
}
func (AccessElement) AsBool() (bool, error) {
	return mixins.Map{"dageth.AccessElement"}.AsBool()
}
func (AccessElement) AsInt() (int64, error) {
	return mixins.Map{"dageth.AccessElement"}.AsInt()
}
func (AccessElement) AsFloat() (float64, error) {
	return mixins.Map{"dageth.AccessElement"}.AsFloat()
}
func (AccessElement) AsString() (string, error) {
	return mixins.Map{"dageth.AccessElement"}.AsString()
}
func (AccessElement) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.AccessElement"}.AsBytes()
}
func (AccessElement) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.AccessElement"}.AsLink()
}
func (AccessElement) Prototype() ipld.NodePrototype {
	return _AccessElement__Prototype{}
}

type _AccessElement__Prototype struct{}

func (_AccessElement__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessElement__Builder
	nb.Reset()
	return &nb
}

type _AccessElement__Builder struct {
	_AccessElement__Assembler
}

func (nb *_AccessElement__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessElement__Builder) Reset() {
	var w _AccessElement
	var m schema.Maybe
	*nb = _AccessElement__Builder{_AccessElement__Assembler{w: &w, m: &m}}
}

type _AccessElement__Assembler struct {
	w     *_AccessElement
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Address     _Address__Assembler
	ca_StorageKeys _StorageKeys__Assembler
}

func (na *_AccessElement__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_StorageKeys.reset()
}

var (
	fieldBit__AccessElement_Address     = 1 << 0
	fieldBit__AccessElement_StorageKeys = 1 << 1
	fieldBits__AccessElement_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_AccessElement__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AccessElement{}
	}
	return na, nil
}
func (_AccessElement__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.AccessElement"}.BeginList(0)
}
func (na *_AccessElement__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.AccessElement"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessElement__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignBool(false)
}
func (_AccessElement__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignInt(0)
}
func (_AccessElement__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignFloat(0)
}
func (_AccessElement__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignString("")
}
func (_AccessElement__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignBytes(nil)
}
func (_AccessElement__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.AccessElement"}.AssignLink(nil)
}
func (na *_AccessElement__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessElement); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessElement", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessElement__Assembler) Prototype() ipld.NodePrototype {
	return _AccessElement__Prototype{}
}
func (ma *_AccessElement__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StorageKeys.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__AccessElement_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address}
		}
		ma.s += fieldBit__AccessElement_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "StorageKeys":
		if ma.s&fieldBit__AccessElement_StorageKeys != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys}
		}
		ma.s += fieldBit__AccessElement_StorageKeys
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.AccessElement", Key: &_String{k}}
}
func (ma *_AccessElement__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AccessElement__KeyAssembler)(ma)
}
func (ma *_AccessElement__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__AccessElement_sufficient != fieldBits__AccessElement_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__AccessElement_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__AccessElement_StorageKeys == 0 {
			err.Missing = append(err.Missing, "StorageKeys")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AccessElement__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AccessElement__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _AccessElement__KeyAssembler _AccessElement__Assembler

func (_AccessElement__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.BeginMap(0)
}
func (_AccessElement__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.BeginList(0)
}
func (na *_AccessElement__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignNull()
}
func (_AccessElement__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignBool(false)
}
func (_AccessElement__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignInt(0)
}
func (_AccessElement__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AccessElement__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__AccessElement_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address}
		}
		ka.s += fieldBit__AccessElement_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "StorageKeys":
		if ka.s&fieldBit__AccessElement_StorageKeys != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys}
		}
		ka.s += fieldBit__AccessElement_StorageKeys
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.AccessElement", Key: &_String{k}}
	}
	return nil
}
func (_AccessElement__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignBytes(nil)
}
func (_AccessElement__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.AccessElement.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AccessElement__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AccessElement__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (AccessElement) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AccessElement) Representation() ipld.Node {
	return (*_AccessElement__Repr)(n)
}

type _AccessElement__Repr _AccessElement

var (
	fieldName__AccessElement_Address_serial     = _String{"Address"}
	fieldName__AccessElement_StorageKeys_serial = _String{"StorageKeys"}
)
var _ ipld.Node = &_AccessElement__Repr{}

func (_AccessElement__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_AccessElement__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "StorageKeys":
		return n.StorageKeys.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_AccessElement__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_AccessElement__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.LookupByIndex(0)
}
func (n _AccessElement__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_AccessElement__Repr) MapIterator() ipld.MapIterator {
	return &_AccessElement__ReprMapItr{n, 0}
}

type _AccessElement__ReprMapItr struct {
	n   *_AccessElement__Repr
	idx int
}

func (itr *_AccessElement__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AccessElement_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__AccessElement_StorageKeys_serial
		v = itr.n.StorageKeys.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AccessElement__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_AccessElement__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_AccessElement__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_AccessElement__Repr) IsAbsent() bool {
	return false
}
func (_AccessElement__Repr) IsNull() bool {
	return false
}
func (_AccessElement__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsBool()
}
func (_AccessElement__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsInt()
}
func (_AccessElement__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsFloat()
}
func (_AccessElement__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsString()
}
func (_AccessElement__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsBytes()
}
func (_AccessElement__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.AccessElement.Repr"}.AsLink()
}
func (_AccessElement__Repr) Prototype() ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}

type _AccessElement__ReprPrototype struct{}

func (_AccessElement__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessElement__ReprBuilder
	nb.Reset()
	return &nb
}

type _AccessElement__ReprBuilder struct {
	_AccessElement__ReprAssembler
}

func (nb *_AccessElement__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessElement__ReprBuilder) Reset() {
	var w _AccessElement
	var m schema.Maybe
	*nb = _AccessElement__ReprBuilder{_AccessElement__ReprAssembler{w: &w, m: &m}}
}

type _AccessElement__ReprAssembler struct {
	w     *_AccessElement
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Address     _Address__ReprAssembler
	ca_StorageKeys _StorageKeys__ReprAssembler
}

func (na *_AccessElement__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_StorageKeys.reset()
}
func (na *_AccessElement__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AccessElement{}
	}
	return na, nil
}
func (_AccessElement__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.BeginList(0)
}
func (na *_AccessElement__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.AccessElement.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessElement__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignBool(false)
}
func (_AccessElement__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignInt(0)
}
func (_AccessElement__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignFloat(0)
}
func (_AccessElement__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignString("")
}
func (_AccessElement__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignBytes(nil)
}
func (_AccessElement__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.AccessElement.Repr"}.AssignLink(nil)
}
func (na *_AccessElement__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessElement); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessElement.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessElement__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}
func (ma *_AccessElement__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__AccessElement_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address_serial}
		}
		ma.s += fieldBit__AccessElement_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "StorageKeys":
		if ma.s&fieldBit__AccessElement_StorageKeys != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys_serial}
		}
		ma.s += fieldBit__AccessElement_StorageKeys
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.AccessElement.Repr", Key: &_String{k}}
}
func (ma *_AccessElement__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AccessElement__ReprKeyAssembler)(ma)
}
func (ma *_AccessElement__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__AccessElement_sufficient != fieldBits__AccessElement_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__AccessElement_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__AccessElement_StorageKeys == 0 {
			err.Missing = append(err.Missing, "StorageKeys")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AccessElement__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AccessElement__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _AccessElement__ReprKeyAssembler _AccessElement__ReprAssembler

func (_AccessElement__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.BeginMap(0)
}
func (_AccessElement__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_AccessElement__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignNull()
}
func (_AccessElement__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignBool(false)
}
func (_AccessElement__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignInt(0)
}
func (_AccessElement__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AccessElement__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__AccessElement_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address_serial}
		}
		ka.s += fieldBit__AccessElement_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "StorageKeys":
		if ka.s&fieldBit__AccessElement_StorageKeys != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys_serial}
		}
		ka.s += fieldBit__AccessElement_StorageKeys
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.AccessElement.Repr", Key: &_String{k}}
}
func (_AccessElement__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_AccessElement__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.AccessElement.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AccessElement__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AccessElement__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_AccessList) Lookup(idx int64) AccessElement {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_AccessList) LookupMaybe(idx int64) MaybeAccessElement {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_AccessElement__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _AccessList__valueAbsent = _AccessElement__Maybe{m: schema.Maybe_Absent}

func (n AccessList) Iterator() *AccessList__Itr {
	return &AccessList__Itr{n, 0}
}

type AccessList__Itr struct {
	n   AccessList
	idx int
}

func (itr *AccessList__Itr) Next() (idx int64, v AccessElement) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *AccessList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _AccessList__Maybe struct {
	m schema.Maybe
	v AccessList
}
type MaybeAccessList = *_AccessList__Maybe

func (m MaybeAccessList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAccessList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAccessList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAccessList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAccessList) Must() AccessList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (AccessList)(&_AccessList{})
var _ schema.TypedNode = (AccessList)(&_AccessList{})

func (AccessList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (AccessList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.AccessList"}.LookupByString("")
}
func (n AccessList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n AccessList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n AccessList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.AccessList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (AccessList) MapIterator() ipld.MapIterator {
	return nil
}
func (n AccessList) ListIterator() ipld.ListIterator {
	return &_AccessList__ListItr{n, 0}
}

type _AccessList__ListItr struct {
	n   AccessList
	idx int
}

func (itr *_AccessList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_AccessList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n AccessList) Length() int64 {
	return int64(len(n.x))
}
func (AccessList) IsAbsent() bool {
	return false
}
func (AccessList) IsNull() bool {
	return false
}
func (AccessList) AsBool() (bool, error) {
	return mixins.List{"dageth.AccessList"}.AsBool()
}
func (AccessList) AsInt() (int64, error) {
	return mixins.List{"dageth.AccessList"}.AsInt()
}
func (AccessList) AsFloat() (float64, error) {
	return mixins.List{"dageth.AccessList"}.AsFloat()
}
func (AccessList) AsString() (string, error) {
	return mixins.List{"dageth.AccessList"}.AsString()
}
func (AccessList) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.AccessList"}.AsBytes()
}
func (AccessList) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.AccessList"}.AsLink()
}
func (AccessList) Prototype() ipld.NodePrototype {
	return _AccessList__Prototype{}
}

type _AccessList__Prototype struct{}

func (_AccessList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessList__Builder
	nb.Reset()
	return &nb
}

type _AccessList__Builder struct {
	_AccessList__Assembler
}

func (nb *_AccessList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessList__Builder) Reset() {
	var w _AccessList
	var m schema.Maybe
	*nb = _AccessList__Builder{_AccessList__Assembler{w: &w, m: &m}}
}

type _AccessList__Assembler struct {
	w     *_AccessList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _AccessElement__Assembler
}

func (na *_AccessList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_AccessList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.AccessList"}.BeginMap(0)
}
func (na *_AccessList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_AccessList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_AccessElement, 0, sizeHint)
	}
	return na, nil
}
func (na *_AccessList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.AccessList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignBool(false)
}
func (_AccessList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignInt(0)
}
func (_AccessList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignFloat(0)
}
func (_AccessList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignString("")
}
func (_AccessList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignBytes(nil)
}
func (_AccessList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.AccessList"}.AssignLink(nil)
}
func (na *_AccessList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessList__Assembler) Prototype() ipld.NodePrototype {
	return _AccessList__Prototype{}
}
func (la *_AccessList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_AccessList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AccessElement{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_AccessList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_AccessList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AccessElement__Prototype{}
}
func (AccessList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AccessList) Representation() ipld.Node {
	return (*_AccessList__Repr)(n)
}

type _AccessList__Repr _AccessList

var _ ipld.Node = &_AccessList__Repr{}

func (_AccessList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_AccessList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.AccessList.Repr"}.LookupByString("")
}
func (nr *_AccessList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (AccessList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AccessElement).Representation(), nil
}
func (nr *_AccessList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (AccessList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AccessElement).Representation(), nil
}
func (n _AccessList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.AccessList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_AccessList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_AccessList__Repr) ListIterator() ipld.ListIterator {
	return &_AccessList__ReprListItr{(AccessList)(nr), 0}
}

type _AccessList__ReprListItr _AccessList__ListItr

func (itr *_AccessList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_AccessList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(AccessElement).Representation(), nil
}
func (itr *_AccessList__ReprListItr) Done() bool {
	return (*_AccessList__ListItr)(itr).Done()
}

func (rn *_AccessList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_AccessList__Repr) IsAbsent() bool {
	return false
}
func (_AccessList__Repr) IsNull() bool {
	return false
}
func (_AccessList__Repr) AsBool() (bool, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsBool()
}
func (_AccessList__Repr) AsInt() (int64, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsInt()
}
func (_AccessList__Repr) AsFloat() (float64, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsFloat()
}
func (_AccessList__Repr) AsString() (string, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsString()
}
func (_AccessList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsBytes()
}
func (_AccessList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.AccessList.Repr"}.AsLink()
}
func (_AccessList__Repr) Prototype() ipld.NodePrototype {
	return _AccessList__ReprPrototype{}
}

type _AccessList__ReprPrototype struct{}

func (_AccessList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessList__ReprBuilder
	nb.Reset()
	return &nb
}

type _AccessList__ReprBuilder struct {
	_AccessList__ReprAssembler
}

func (nb *_AccessList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessList__ReprBuilder) Reset() {
	var w _AccessList
	var m schema.Maybe
	*nb = _AccessList__ReprBuilder{_AccessList__ReprAssembler{w: &w, m: &m}}
}

type _AccessList__ReprAssembler struct {
	w     *_AccessList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _AccessElement__ReprAssembler
}

func (na *_AccessList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_AccessList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.BeginMap(0)
}
func (na *_AccessList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_AccessList{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_AccessElement, 0, sizeHint)
	}
	return na, nil
}
func (na *_AccessList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.AccessList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignBool(false)
}
func (_AccessList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignInt(0)
}
func (_AccessList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignFloat(0)
}
func (_AccessList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignString("")
}
func (_AccessList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignBytes(nil)
}
func (_AccessList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.AccessList.Repr"}.AssignLink(nil)
}
func (na *_AccessList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AccessList__ReprPrototype{}
}
func (la *_AccessList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_AccessList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AccessElement{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_AccessList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_AccessList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}

func (n Address) Bytes() []byte {
	return n.x
}
func (_Address__Prototype) FromBytes(v []byte) (Address, error) {
	n := _Address{v}
	return &n, nil
}

type _Address__Maybe struct {
	m schema.Maybe
	v Address
}
type MaybeAddress = *_Address__Maybe

func (m MaybeAddress) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAddress) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAddress) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAddress) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAddress) Must() Address {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Address)(&_Address{})
var _ schema.TypedNode = (Address)(&_Address{})

func (Address) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Address) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Address"}.LookupByString("")
}
func (Address) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Address"}.LookupByNode(nil)
}
func (Address) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Address"}.LookupByIndex(0)
}
func (Address) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Address"}.LookupBySegment(seg)
}
func (Address) MapIterator() ipld.MapIterator {
	return nil
}
func (Address) ListIterator() ipld.ListIterator {
	return nil
}
func (Address) Length() int64 {
	return -1
}
func (Address) IsAbsent() bool {
	return false
}
func (Address) IsNull() bool {
	return false
}
func (Address) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Address"}.AsBool()
}
func (Address) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Address"}.AsInt()
}
func (Address) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Address"}.AsFloat()
}
func (Address) AsString() (string, error) {
	return mixins.Bytes{"dageth.Address"}.AsString()
}
func (n Address) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Address) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Address"}.AsLink()
}
func (Address) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}

type _Address__Prototype struct{}

func (_Address__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Address__Builder
	nb.Reset()
	return &nb
}

type _Address__Builder struct {
	_Address__Assembler
}

func (nb *_Address__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Address__Builder) Reset() {
	var w _Address
	var m schema.Maybe
	*nb = _Address__Builder{_Address__Assembler{w: &w, m: &m}}
}

type _Address__Assembler struct {
	w *_Address
	m *schema.Maybe
}

func (na *_Address__Assembler) reset() {}
func (_Address__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Address"}.BeginMap(0)
}
func (_Address__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Address"}.BeginList(0)
}
func (na *_Address__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Address"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Address__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Address"}.AssignBool(false)
}
func (_Address__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Address"}.AssignInt(0)
}
func (_Address__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Address"}.AssignFloat(0)
}
func (_Address__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Address"}.AssignString("")
}
func (na *_Address__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Address{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Address__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Address"}.AssignLink(nil)
}
func (na *_Address__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Address); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Address__Assembler) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}
func (Address) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Address) Representation() ipld.Node {
	return (*_Address__Repr)(n)
}

type _Address__Repr = _Address

var _ ipld.Node = &_Address__Repr{}

type _Address__ReprPrototype = _Address__Prototype
type _Address__ReprAssembler = _Address__Assembler

func (n Balance) Bytes() []byte {
	return n.x
}
func (_Balance__Prototype) FromBytes(v []byte) (Balance, error) {
	n := _Balance{v}
	return &n, nil
}

type _Balance__Maybe struct {
	m schema.Maybe
	v Balance
}
type MaybeBalance = *_Balance__Maybe

func (m MaybeBalance) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBalance) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBalance) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBalance) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBalance) Must() Balance {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Balance)(&_Balance{})
var _ schema.TypedNode = (Balance)(&_Balance{})

func (Balance) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Balance) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Balance"}.LookupByString("")
}
func (Balance) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Balance"}.LookupByNode(nil)
}
func (Balance) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Balance"}.LookupByIndex(0)
}
func (Balance) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Balance"}.LookupBySegment(seg)
}
func (Balance) MapIterator() ipld.MapIterator {
	return nil
}
func (Balance) ListIterator() ipld.ListIterator {
	return nil
}
func (Balance) Length() int64 {
	return -1
}
func (Balance) IsAbsent() bool {
	return false
}
func (Balance) IsNull() bool {
	return false
}
func (Balance) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Balance"}.AsBool()
}
func (Balance) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Balance"}.AsInt()
}
func (Balance) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Balance"}.AsFloat()
}
func (Balance) AsString() (string, error) {
	return mixins.Bytes{"dageth.Balance"}.AsString()
}
func (n Balance) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Balance) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Balance"}.AsLink()
}
func (Balance) Prototype() ipld.NodePrototype {
	return _Balance__Prototype{}
}

type _Balance__Prototype struct{}

func (_Balance__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Balance__Builder
	nb.Reset()
	return &nb
}

type _Balance__Builder struct {
	_Balance__Assembler
}

func (nb *_Balance__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Balance__Builder) Reset() {
	var w _Balance
	var m schema.Maybe
	*nb = _Balance__Builder{_Balance__Assembler{w: &w, m: &m}}
}

type _Balance__Assembler struct {
	w *_Balance
	m *schema.Maybe
}

func (na *_Balance__Assembler) reset() {}
func (_Balance__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Balance"}.BeginMap(0)
}
func (_Balance__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Balance"}.BeginList(0)
}
func (na *_Balance__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Balance"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Balance__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Balance"}.AssignBool(false)
}
func (_Balance__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Balance"}.AssignInt(0)
}
func (_Balance__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Balance"}.AssignFloat(0)
}
func (_Balance__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Balance"}.AssignString("")
}
func (na *_Balance__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Balance{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Balance__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Balance"}.AssignLink(nil)
}
func (na *_Balance__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Balance); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Balance__Assembler) Prototype() ipld.NodePrototype {
	return _Balance__Prototype{}
}
func (Balance) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Balance) Representation() ipld.Node {
	return (*_Balance__Repr)(n)
}

type _Balance__Repr = _Balance

var _ ipld.Node = &_Balance__Repr{}

type _Balance__ReprPrototype = _Balance__Prototype
type _Balance__ReprAssembler = _Balance__Assembler

func (n BigInt) Bytes() []byte {
	return n.x
}
func (_BigInt__Prototype) FromBytes(v []byte) (BigInt, error) {
	n := _BigInt{v}
	return &n, nil
}

type _BigInt__Maybe struct {
	m schema.Maybe
	v BigInt
}
type MaybeBigInt = *_BigInt__Maybe

func (m MaybeBigInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBigInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBigInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBigInt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBigInt) Must() BigInt {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (BigInt)(&_BigInt{})
var _ schema.TypedNode = (BigInt)(&_BigInt{})

func (BigInt) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (BigInt) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BigInt"}.LookupByString("")
}
func (BigInt) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BigInt"}.LookupByNode(nil)
}
func (BigInt) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BigInt"}.LookupByIndex(0)
}
func (BigInt) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BigInt"}.LookupBySegment(seg)
}
func (BigInt) MapIterator() ipld.MapIterator {
	return nil
}
func (BigInt) ListIterator() ipld.ListIterator {
	return nil
}
func (BigInt) Length() int64 {
	return -1
}
func (BigInt) IsAbsent() bool {
	return false
}
func (BigInt) IsNull() bool {
	return false
}
func (BigInt) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.BigInt"}.AsBool()
}
func (BigInt) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.BigInt"}.AsInt()
}
func (BigInt) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.BigInt"}.AsFloat()
}
func (BigInt) AsString() (string, error) {
	return mixins.Bytes{"dageth.BigInt"}.AsString()
}
func (n BigInt) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (BigInt) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.BigInt"}.AsLink()
}
func (BigInt) Prototype() ipld.NodePrototype {
	return _BigInt__Prototype{}
}

type _BigInt__Prototype struct{}

func (_BigInt__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BigInt__Builder
	nb.Reset()
	return &nb
}

type _BigInt__Builder struct {
	_BigInt__Assembler
}

func (nb *_BigInt__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BigInt__Builder) Reset() {
	var w _BigInt
	var m schema.Maybe
	*nb = _BigInt__Builder{_BigInt__Assembler{w: &w, m: &m}}
}

type _BigInt__Assembler struct {
	w *_BigInt
	m *schema.Maybe
}

func (na *_BigInt__Assembler) reset() {}
func (_BigInt__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.BigInt"}.BeginMap(0)
}
func (_BigInt__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.BigInt"}.BeginList(0)
}
func (na *_BigInt__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.BigInt"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_BigInt__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.BigInt"}.AssignBool(false)
}
func (_BigInt__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.BigInt"}.AssignInt(0)
}
func (_BigInt__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.BigInt"}.AssignFloat(0)
}
func (_BigInt__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.BigInt"}.AssignString("")
}
func (na *_BigInt__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_BigInt{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_BigInt__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.BigInt"}.AssignLink(nil)
}
func (na *_BigInt__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BigInt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_BigInt__Assembler) Prototype() ipld.NodePrototype {
	return _BigInt__Prototype{}
}
func (BigInt) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BigInt) Representation() ipld.Node {
	return (*_BigInt__Repr)(n)
}

type _BigInt__Repr = _BigInt

var _ ipld.Node = &_BigInt__Repr{}

type _BigInt__ReprPrototype = _BigInt__Prototype
type _BigInt__ReprAssembler = _BigInt__Assembler

func (n BlockNonce) Bytes() []byte {
	return n.x
}
func (_BlockNonce__Prototype) FromBytes(v []byte) (BlockNonce, error) {
	n := _BlockNonce{v}
	return &n, nil
}

type _BlockNonce__Maybe struct {
	m schema.Maybe
	v BlockNonce
}
type MaybeBlockNonce = *_BlockNonce__Maybe

func (m MaybeBlockNonce) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlockNonce) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlockNonce) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlockNonce) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlockNonce) Must() BlockNonce {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (BlockNonce)(&_BlockNonce{})
var _ schema.TypedNode = (BlockNonce)(&_BlockNonce{})

func (BlockNonce) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (BlockNonce) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.LookupByString("")
}
func (BlockNonce) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.LookupByNode(nil)
}
func (BlockNonce) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.LookupByIndex(0)
}
func (BlockNonce) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.LookupBySegment(seg)
}
func (BlockNonce) MapIterator() ipld.MapIterator {
	return nil
}
func (BlockNonce) ListIterator() ipld.ListIterator {
	return nil
}
func (BlockNonce) Length() int64 {
	return -1
}
func (BlockNonce) IsAbsent() bool {
	return false
}
func (BlockNonce) IsNull() bool {
	return false
}
func (BlockNonce) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.AsBool()
}
func (BlockNonce) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.AsInt()
}
func (BlockNonce) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.AsFloat()
}
func (BlockNonce) AsString() (string, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.AsString()
}
func (n BlockNonce) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (BlockNonce) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.BlockNonce"}.AsLink()
}
func (BlockNonce) Prototype() ipld.NodePrototype {
	return _BlockNonce__Prototype{}
}

type _BlockNonce__Prototype struct{}

func (_BlockNonce__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BlockNonce__Builder
	nb.Reset()
	return &nb
}

type _BlockNonce__Builder struct {
	_BlockNonce__Assembler
}

func (nb *_BlockNonce__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BlockNonce__Builder) Reset() {
	var w _BlockNonce
	var m schema.Maybe
	*nb = _BlockNonce__Builder{_BlockNonce__Assembler{w: &w, m: &m}}
}

type _BlockNonce__Assembler struct {
	w *_BlockNonce
	m *schema.Maybe
}

func (na *_BlockNonce__Assembler) reset() {}
func (_BlockNonce__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.BeginMap(0)
}
func (_BlockNonce__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.BeginList(0)
}
func (na *_BlockNonce__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_BlockNonce__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignBool(false)
}
func (_BlockNonce__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignInt(0)
}
func (_BlockNonce__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignFloat(0)
}
func (_BlockNonce__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignString("")
}
func (na *_BlockNonce__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_BlockNonce{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_BlockNonce__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.BlockNonce"}.AssignLink(nil)
}
func (na *_BlockNonce__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BlockNonce); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_BlockNonce__Assembler) Prototype() ipld.NodePrototype {
	return _BlockNonce__Prototype{}
}
func (BlockNonce) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BlockNonce) Representation() ipld.Node {
	return (*_BlockNonce__Repr)(n)
}

type _BlockNonce__Repr = _BlockNonce

var _ ipld.Node = &_BlockNonce__Repr{}

type _BlockNonce__ReprPrototype = _BlockNonce__Prototype
type _BlockNonce__ReprAssembler = _BlockNonce__Assembler

func (n Bloom) Bytes() []byte {
	return n.x
}
func (_Bloom__Prototype) FromBytes(v []byte) (Bloom, error) {
	n := _Bloom{v}
	return &n, nil
}

type _Bloom__Maybe struct {
	m schema.Maybe
	v Bloom
}
type MaybeBloom = *_Bloom__Maybe

func (m MaybeBloom) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBloom) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBloom) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBloom) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBloom) Must() Bloom {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Bloom)(&_Bloom{})
var _ schema.TypedNode = (Bloom)(&_Bloom{})

func (Bloom) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bloom) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bloom"}.LookupByString("")
}
func (Bloom) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bloom"}.LookupByNode(nil)
}
func (Bloom) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bloom"}.LookupByIndex(0)
}
func (Bloom) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bloom"}.LookupBySegment(seg)
}
func (Bloom) MapIterator() ipld.MapIterator {
	return nil
}
func (Bloom) ListIterator() ipld.ListIterator {
	return nil
}
func (Bloom) Length() int64 {
	return -1
}
func (Bloom) IsAbsent() bool {
	return false
}
func (Bloom) IsNull() bool {
	return false
}
func (Bloom) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Bloom"}.AsBool()
}
func (Bloom) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Bloom"}.AsInt()
}
func (Bloom) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Bloom"}.AsFloat()
}
func (Bloom) AsString() (string, error) {
	return mixins.Bytes{"dageth.Bloom"}.AsString()
}
func (n Bloom) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bloom) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Bloom"}.AsLink()
}
func (Bloom) Prototype() ipld.NodePrototype {
	return _Bloom__Prototype{}
}

type _Bloom__Prototype struct{}

func (_Bloom__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bloom__Builder
	nb.Reset()
	return &nb
}

type _Bloom__Builder struct {
	_Bloom__Assembler
}

func (nb *_Bloom__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bloom__Builder) Reset() {
	var w _Bloom
	var m schema.Maybe
	*nb = _Bloom__Builder{_Bloom__Assembler{w: &w, m: &m}}
}

type _Bloom__Assembler struct {
	w *_Bloom
	m *schema.Maybe
}

func (na *_Bloom__Assembler) reset() {}
func (_Bloom__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Bloom"}.BeginMap(0)
}
func (_Bloom__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Bloom"}.BeginList(0)
}
func (na *_Bloom__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Bloom"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bloom__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Bloom"}.AssignBool(false)
}
func (_Bloom__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Bloom"}.AssignInt(0)
}
func (_Bloom__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Bloom"}.AssignFloat(0)
}
func (_Bloom__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Bloom"}.AssignString("")
}
func (na *_Bloom__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bloom{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bloom__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Bloom"}.AssignLink(nil)
}
func (na *_Bloom__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bloom); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bloom__Assembler) Prototype() ipld.NodePrototype {
	return _Bloom__Prototype{}
}
func (Bloom) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bloom) Representation() ipld.Node {
	return (*_Bloom__Repr)(n)
}

type _Bloom__Repr = _Bloom

var _ ipld.Node = &_Bloom__Repr{}

type _Bloom__ReprPrototype = _Bloom__Prototype
type _Bloom__ReprAssembler = _Bloom__Assembler

func (n ByteCode) Bytes() []byte {
	return n.x
}
func (_ByteCode__Prototype) FromBytes(v []byte) (ByteCode, error) {
	n := _ByteCode{v}
	return &n, nil
}

type _ByteCode__Maybe struct {
	m schema.Maybe
	v ByteCode
}
type MaybeByteCode = *_ByteCode__Maybe

func (m MaybeByteCode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeByteCode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeByteCode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeByteCode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeByteCode) Must() ByteCode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (ByteCode)(&_ByteCode{})
var _ schema.TypedNode = (ByteCode)(&_ByteCode{})

func (ByteCode) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (ByteCode) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.ByteCode"}.LookupByString("")
}
func (ByteCode) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.ByteCode"}.LookupByNode(nil)
}
func (ByteCode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.ByteCode"}.LookupByIndex(0)
}
func (ByteCode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.ByteCode"}.LookupBySegment(seg)
}
func (ByteCode) MapIterator() ipld.MapIterator {
	return nil
}
func (ByteCode) ListIterator() ipld.ListIterator {
	return nil
}
func (ByteCode) Length() int64 {
	return -1
}
func (ByteCode) IsAbsent() bool {
	return false
}
func (ByteCode) IsNull() bool {
	return false
}
func (ByteCode) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.ByteCode"}.AsBool()
}
func (ByteCode) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.ByteCode"}.AsInt()
}
func (ByteCode) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.ByteCode"}.AsFloat()
}
func (ByteCode) AsString() (string, error) {
	return mixins.Bytes{"dageth.ByteCode"}.AsString()
}
func (n ByteCode) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (ByteCode) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.ByteCode"}.AsLink()
}
func (ByteCode) Prototype() ipld.NodePrototype {
	return _ByteCode__Prototype{}
}

type _ByteCode__Prototype struct{}

func (_ByteCode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ByteCode__Builder
	nb.Reset()
	return &nb
}

type _ByteCode__Builder struct {
	_ByteCode__Assembler
}

func (nb *_ByteCode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ByteCode__Builder) Reset() {
	var w _ByteCode
	var m schema.Maybe
	*nb = _ByteCode__Builder{_ByteCode__Assembler{w: &w, m: &m}}
}

type _ByteCode__Assembler struct {
	w *_ByteCode
	m *schema.Maybe
}

func (na *_ByteCode__Assembler) reset() {}
func (_ByteCode__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.ByteCode"}.BeginMap(0)
}
func (_ByteCode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.ByteCode"}.BeginList(0)
}
func (na *_ByteCode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.ByteCode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_ByteCode__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.ByteCode"}.AssignBool(false)
}
func (_ByteCode__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.ByteCode"}.AssignInt(0)
}
func (_ByteCode__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.ByteCode"}.AssignFloat(0)
}
func (_ByteCode__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.ByteCode"}.AssignString("")
}
func (na *_ByteCode__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_ByteCode{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_ByteCode__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.ByteCode"}.AssignLink(nil)
}
func (na *_ByteCode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ByteCode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_ByteCode__Assembler) Prototype() ipld.NodePrototype {
	return _ByteCode__Prototype{}
}
func (ByteCode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ByteCode) Representation() ipld.Node {
	return (*_ByteCode__Repr)(n)
}

type _ByteCode__Repr = _ByteCode

var _ ipld.Node = &_ByteCode__Repr{}

type _ByteCode__ReprPrototype = _ByteCode__Prototype
type _ByteCode__ReprAssembler = _ByteCode__Assembler

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}

type _Bytes__Maybe struct {
	m schema.Maybe
	v Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})

func (Bytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int64 {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{"dageth.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}

type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}

type _Bytes__Builder struct {
	_Bytes__Assembler
}

func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}

type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}

type _Bytes__Repr = _Bytes

var _ ipld.Node = &_Bytes__Repr{}

type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler

func (n Hash) Bytes() []byte {
	return n.x
}
func (_Hash__Prototype) FromBytes(v []byte) (Hash, error) {
	n := _Hash{v}
	return &n, nil
}

type _Hash__Maybe struct {
	m schema.Maybe
	v Hash
}
type MaybeHash = *_Hash__Maybe

func (m MaybeHash) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHash) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHash) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHash) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHash) Must() Hash {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Hash)(&_Hash{})
var _ schema.TypedNode = (Hash)(&_Hash{})

func (Hash) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Hash) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Hash"}.LookupByString("")
}
func (Hash) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Hash"}.LookupByNode(nil)
}
func (Hash) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Hash"}.LookupByIndex(0)
}
func (Hash) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Hash"}.LookupBySegment(seg)
}
func (Hash) MapIterator() ipld.MapIterator {
	return nil
}
func (Hash) ListIterator() ipld.ListIterator {
	return nil
}
func (Hash) Length() int64 {
	return -1
}
func (Hash) IsAbsent() bool {
	return false
}
func (Hash) IsNull() bool {
	return false
}
func (Hash) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Hash"}.AsBool()
}
func (Hash) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Hash"}.AsInt()
}
func (Hash) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Hash"}.AsFloat()
}
func (Hash) AsString() (string, error) {
	return mixins.Bytes{"dageth.Hash"}.AsString()
}
func (n Hash) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Hash) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Hash"}.AsLink()
}
func (Hash) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}

type _Hash__Prototype struct{}

func (_Hash__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Hash__Builder
	nb.Reset()
	return &nb
}

type _Hash__Builder struct {
	_Hash__Assembler
}

func (nb *_Hash__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Hash__Builder) Reset() {
	var w _Hash
	var m schema.Maybe
	*nb = _Hash__Builder{_Hash__Assembler{w: &w, m: &m}}
}

type _Hash__Assembler struct {
	w *_Hash
	m *schema.Maybe
}

func (na *_Hash__Assembler) reset() {}
func (_Hash__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Hash"}.BeginMap(0)
}
func (_Hash__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Hash"}.BeginList(0)
}
func (na *_Hash__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Hash"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Hash__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Hash"}.AssignBool(false)
}
func (_Hash__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Hash"}.AssignInt(0)
}
func (_Hash__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Hash"}.AssignFloat(0)
}
func (_Hash__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Hash"}.AssignString("")
}
func (na *_Hash__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Hash{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Hash__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Hash"}.AssignLink(nil)
}
func (na *_Hash__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Hash); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Hash__Assembler) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Hash) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Hash) Representation() ipld.Node {
	return (*_Hash__Repr)(n)
}

type _Hash__Repr = _Hash

var _ ipld.Node = &_Hash__Repr{}

type _Hash__ReprPrototype = _Hash__Prototype
type _Hash__ReprAssembler = _Hash__Assembler

func (n _Header) FieldParentCID() Link {
	return &n.ParentCID
}
func (n _Header) FieldUnclesCID() Link {
	return &n.UnclesCID
}
func (n _Header) FieldCoinbase() Address {
	return &n.Coinbase
}
func (n _Header) FieldStateRootCID() Link {
	return &n.StateRootCID
}
func (n _Header) FieldTxRootCID() Link {
	return &n.TxRootCID
}
func (n _Header) FieldRctRootCID() Link {
	return &n.RctRootCID
}
func (n _Header) FieldBloom() Bloom {
	return &n.Bloom
}
func (n _Header) FieldDifficulty() BigInt {
	return &n.Difficulty
}
func (n _Header) FieldNumber() BigInt {
	return &n.Number
}
func (n _Header) FieldGasLimit() Uint {
	return &n.GasLimit
}
func (n _Header) FieldGasUsed() Uint {
	return &n.GasUsed
}
func (n _Header) FieldTime() Time {
	return &n.Time
}
func (n _Header) FieldExtra() Bytes {
	return &n.Extra
}
func (n _Header) FieldMixDigest() Hash {
	return &n.MixDigest
}
func (n _Header) FieldNonce() BlockNonce {
	return &n.Nonce
}

type _Header__Maybe struct {
	m schema.Maybe
	v Header
}
type MaybeHeader = *_Header__Maybe

func (m MaybeHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHeader) Must() Header {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Header_ParentCID    = _String{"ParentCID"}
	fieldName__Header_UnclesCID    = _String{"UnclesCID"}
	fieldName__Header_Coinbase     = _String{"Coinbase"}
	fieldName__Header_StateRootCID = _String{"StateRootCID"}
	fieldName__Header_TxRootCID    = _String{"TxRootCID"}
	fieldName__Header_RctRootCID   = _String{"RctRootCID"}
	fieldName__Header_Bloom        = _String{"Bloom"}
	fieldName__Header_Difficulty   = _String{"Difficulty"}
	fieldName__Header_Number       = _String{"Number"}
	fieldName__Header_GasLimit     = _String{"GasLimit"}
	fieldName__Header_GasUsed      = _String{"GasUsed"}
	fieldName__Header_Time         = _String{"Time"}
	fieldName__Header_Extra        = _String{"Extra"}
	fieldName__Header_MixDigest    = _String{"MixDigest"}
	fieldName__Header_Nonce        = _String{"Nonce"}
)
var _ ipld.Node = (Header)(&_Header{})
var _ schema.TypedNode = (Header)(&_Header{})

func (Header) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Header) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ParentCID":
		return &n.ParentCID, nil
	case "UnclesCID":
		return &n.UnclesCID, nil
	case "Coinbase":
		return &n.Coinbase, nil
	case "StateRootCID":
		return &n.StateRootCID, nil
	case "TxRootCID":
		return &n.TxRootCID, nil
	case "RctRootCID":
		return &n.RctRootCID, nil
	case "Bloom":
		return &n.Bloom, nil
	case "Difficulty":
		return &n.Difficulty, nil
	case "Number":
		return &n.Number, nil
	case "GasLimit":
		return &n.GasLimit, nil
	case "GasUsed":
		return &n.GasUsed, nil
	case "Time":
		return &n.Time, nil
	case "Extra":
		return &n.Extra, nil
	case "MixDigest":
		return &n.MixDigest, nil
	case "Nonce":
		return &n.Nonce, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Header) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Header) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Header"}.LookupByIndex(0)
}
func (n Header) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Header) MapIterator() ipld.MapIterator {
	return &_Header__MapItr{n, 0}
}

type _Header__MapItr struct {
	n   Header
	idx int
}

func (itr *_Header__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 15 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_ParentCID
		v = &itr.n.ParentCID
	case 1:
		k = &fieldName__Header_UnclesCID
		v = &itr.n.UnclesCID
	case 2:
		k = &fieldName__Header_Coinbase
		v = &itr.n.Coinbase
	case 3:
		k = &fieldName__Header_StateRootCID
		v = &itr.n.StateRootCID
	case 4:
		k = &fieldName__Header_TxRootCID
		v = &itr.n.TxRootCID
	case 5:
		k = &fieldName__Header_RctRootCID
		v = &itr.n.RctRootCID
	case 6:
		k = &fieldName__Header_Bloom
		v = &itr.n.Bloom
	case 7:
		k = &fieldName__Header_Difficulty
		v = &itr.n.Difficulty
	case 8:
		k = &fieldName__Header_Number
		v = &itr.n.Number
	case 9:
		k = &fieldName__Header_GasLimit
		v = &itr.n.GasLimit
	case 10:
		k = &fieldName__Header_GasUsed
		v = &itr.n.GasUsed
	case 11:
		k = &fieldName__Header_Time
		v = &itr.n.Time
	case 12:
		k = &fieldName__Header_Extra
		v = &itr.n.Extra
	case 13:
		k = &fieldName__Header_MixDigest
		v = &itr.n.MixDigest
	case 14:
		k = &fieldName__Header_Nonce
		v = &itr.n.Nonce
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__MapItr) Done() bool {
	return itr.idx >= 15
}

func (Header) ListIterator() ipld.ListIterator {
	return nil
}
func (Header) Length() int64 {
	return 15
}
func (Header) IsAbsent() bool {
	return false
}
func (Header) IsNull() bool {
	return false
}
func (Header) AsBool() (bool, error) {
	return mixins.Map{"dageth.Header"}.AsBool()
}
func (Header) AsInt() (int64, error) {
	return mixins.Map{"dageth.Header"}.AsInt()
}
func (Header) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Header"}.AsFloat()
}
func (Header) AsString() (string, error) {
	return mixins.Map{"dageth.Header"}.AsString()
}
func (Header) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Header"}.AsBytes()
}
func (Header) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Header"}.AsLink()
}
func (Header) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}

type _Header__Prototype struct{}

func (_Header__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__Builder
	nb.Reset()
	return &nb
}

type _Header__Builder struct {
	_Header__Assembler
}

func (nb *_Header__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__Builder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__Builder{_Header__Assembler{w: &w, m: &m}}
}

type _Header__Assembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ParentCID    _Link__Assembler
	ca_UnclesCID    _Link__Assembler
	ca_Coinbase     _Address__Assembler
	ca_StateRootCID _Link__Assembler
	ca_TxRootCID    _Link__Assembler
	ca_RctRootCID   _Link__Assembler
	ca_Bloom        _Bloom__Assembler
	ca_Difficulty   _BigInt__Assembler
	ca_Number       _BigInt__Assembler
	ca_GasLimit     _Uint__Assembler
	ca_GasUsed      _Uint__Assembler
	ca_Time         _Time__Assembler
	ca_Extra        _Bytes__Assembler
	ca_MixDigest    _Hash__Assembler
	ca_Nonce        _BlockNonce__Assembler
}

func (na *_Header__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ParentCID.reset()
	na.ca_UnclesCID.reset()
	na.ca_Coinbase.reset()
	na.ca_StateRootCID.reset()
	na.ca_TxRootCID.reset()
	na.ca_RctRootCID.reset()
	na.ca_Bloom.reset()
	na.ca_Difficulty.reset()
	na.ca_Number.reset()
	na.ca_GasLimit.reset()
	na.ca_GasUsed.reset()
	na.ca_Time.reset()
	na.ca_Extra.reset()
	na.ca_MixDigest.reset()
	na.ca_Nonce.reset()
}

var (
	fieldBit__Header_ParentCID    = 1 << 0
	fieldBit__Header_UnclesCID    = 1 << 1
	fieldBit__Header_Coinbase     = 1 << 2
	fieldBit__Header_StateRootCID = 1 << 3
	fieldBit__Header_TxRootCID    = 1 << 4
	fieldBit__Header_RctRootCID   = 1 << 5
	fieldBit__Header_Bloom        = 1 << 6
	fieldBit__Header_Difficulty   = 1 << 7
	fieldBit__Header_Number       = 1 << 8
	fieldBit__Header_GasLimit     = 1 << 9
	fieldBit__Header_GasUsed      = 1 << 10
	fieldBit__Header_Time         = 1 << 11
	fieldBit__Header_Extra        = 1 << 12
	fieldBit__Header_MixDigest    = 1 << 13
	fieldBit__Header_Nonce        = 1 << 14
	fieldBits__Header_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13 + 1<<14
)

func (na *_Header__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Header"}.BeginList(0)
}
func (na *_Header__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Header"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignBool(false)
}
func (_Header__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignInt(0)
}
func (_Header__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignFloat(0)
}
func (_Header__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignString("")
}
func (_Header__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignBytes(nil)
}
func (_Header__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Header"}.AssignLink(nil)
}
func (na *_Header__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Header", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__Assembler) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}
func (ma *_Header__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ParentCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_UnclesCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Coinbase.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StateRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TxRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_RctRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bloom.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Difficulty.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Number.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasLimit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasUsed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Time.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Extra.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MixDigest.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ParentCID":
		if ma.s&fieldBit__Header_ParentCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID}
		}
		ma.s += fieldBit__Header_ParentCID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID, nil
	case "UnclesCID":
		if ma.s&fieldBit__Header_UnclesCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID}
		}
		ma.s += fieldBit__Header_UnclesCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID, nil
	case "Coinbase":
		if ma.s&fieldBit__Header_Coinbase != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase}
		}
		ma.s += fieldBit__Header_Coinbase
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase, nil
	case "StateRootCID":
		if ma.s&fieldBit__Header_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID}
		}
		ma.s += fieldBit__Header_StateRootCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "TxRootCID":
		if ma.s&fieldBit__Header_TxRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID}
		}
		ma.s += fieldBit__Header_TxRootCID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID, nil
	case "RctRootCID":
		if ma.s&fieldBit__Header_RctRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID}
		}
		ma.s += fieldBit__Header_RctRootCID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID, nil
	case "Bloom":
		if ma.s&fieldBit__Header_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom}
		}
		ma.s += fieldBit__Header_Bloom
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Difficulty":
		if ma.s&fieldBit__Header_Difficulty != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty}
		}
		ma.s += fieldBit__Header_Difficulty
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty, nil
	case "Number":
		if ma.s&fieldBit__Header_Number != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number}
		}
		ma.s += fieldBit__Header_Number
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number, nil
	case "GasLimit":
		if ma.s&fieldBit__Header_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit}
		}
		ma.s += fieldBit__Header_GasLimit
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "GasUsed":
		if ma.s&fieldBit__Header_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed}
		}
		ma.s += fieldBit__Header_GasUsed
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "Extra":
		if ma.s&fieldBit__Header_Extra != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra}
		}
		ma.s += fieldBit__Header_Extra
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra, nil
	case "MixDigest":
		if ma.s&fieldBit__Header_MixDigest != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest}
		}
		ma.s += fieldBit__Header_MixDigest
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest, nil
	case "Nonce":
		if ma.s&fieldBit__Header_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce}
		}
		ma.s += fieldBit__Header_Nonce
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Header", Key: &_String{k}}
}
func (ma *_Header__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__KeyAssembler)(ma)
}
func (ma *_Header__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID
	case 1:
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID
	case 2:
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase
	case 3:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 4:
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID
	case 5:
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID
	case 6:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 7:
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty
	case 8:
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number
	case 9:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 10:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	case 11:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 12:
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra
	case 13:
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest
	case 14:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_ParentCID == 0 {
			err.Missing = append(err.Missing, "ParentCID")
		}
		if ma.s&fieldBit__Header_UnclesCID == 0 {
			err.Missing = append(err.Missing, "UnclesCID")
		}
		if ma.s&fieldBit__Header_Coinbase == 0 {
			err.Missing = append(err.Missing, "Coinbase")
		}
		if ma.s&fieldBit__Header_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__Header_TxRootCID == 0 {
			err.Missing = append(err.Missing, "TxRootCID")
		}
		if ma.s&fieldBit__Header_RctRootCID == 0 {
			err.Missing = append(err.Missing, "RctRootCID")
		}
		if ma.s&fieldBit__Header_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Header_Difficulty == 0 {
			err.Missing = append(err.Missing, "Difficulty")
		}
		if ma.s&fieldBit__Header_Number == 0 {
			err.Missing = append(err.Missing, "Number")
		}
		if ma.s&fieldBit__Header_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Header_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_Extra == 0 {
			err.Missing = append(err.Missing, "Extra")
		}
		if ma.s&fieldBit__Header_MixDigest == 0 {
			err.Missing = append(err.Missing, "MixDigest")
		}
		if ma.s&fieldBit__Header_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Header__KeyAssembler _Header__Assembler

func (_Header__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.BeginMap(0)
}
func (_Header__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.BeginList(0)
}
func (na *_Header__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignNull()
}
func (_Header__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignBool(false)
}
func (_Header__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignInt(0)
}
func (_Header__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ParentCID":
		if ka.s&fieldBit__Header_ParentCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID}
		}
		ka.s += fieldBit__Header_ParentCID
		ka.state = maState_expectValue
		ka.f = 0
	case "UnclesCID":
		if ka.s&fieldBit__Header_UnclesCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID}
		}
		ka.s += fieldBit__Header_UnclesCID
		ka.state = maState_expectValue
		ka.f = 1
	case "Coinbase":
		if ka.s&fieldBit__Header_Coinbase != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase}
		}
		ka.s += fieldBit__Header_Coinbase
		ka.state = maState_expectValue
		ka.f = 2
	case "StateRootCID":
		if ka.s&fieldBit__Header_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID}
		}
		ka.s += fieldBit__Header_StateRootCID
		ka.state = maState_expectValue
		ka.f = 3
	case "TxRootCID":
		if ka.s&fieldBit__Header_TxRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID}
		}
		ka.s += fieldBit__Header_TxRootCID
		ka.state = maState_expectValue
		ka.f = 4
	case "RctRootCID":
		if ka.s&fieldBit__Header_RctRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID}
		}
		ka.s += fieldBit__Header_RctRootCID
		ka.state = maState_expectValue
		ka.f = 5
	case "Bloom":
		if ka.s&fieldBit__Header_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom}
		}
		ka.s += fieldBit__Header_Bloom
		ka.state = maState_expectValue
		ka.f = 6
	case "Difficulty":
		if ka.s&fieldBit__Header_Difficulty != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty}
		}
		ka.s += fieldBit__Header_Difficulty
		ka.state = maState_expectValue
		ka.f = 7
	case "Number":
		if ka.s&fieldBit__Header_Number != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number}
		}
		ka.s += fieldBit__Header_Number
		ka.state = maState_expectValue
		ka.f = 8
	case "GasLimit":
		if ka.s&fieldBit__Header_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit}
		}
		ka.s += fieldBit__Header_GasLimit
		ka.state = maState_expectValue
		ka.f = 9
	case "GasUsed":
		if ka.s&fieldBit__Header_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed}
		}
		ka.s += fieldBit__Header_GasUsed
		ka.state = maState_expectValue
		ka.f = 10
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 11
	case "Extra":
		if ka.s&fieldBit__Header_Extra != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra}
		}
		ka.s += fieldBit__Header_Extra
		ka.state = maState_expectValue
		ka.f = 12
	case "MixDigest":
		if ka.s&fieldBit__Header_MixDigest != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest}
		}
		ka.s += fieldBit__Header_MixDigest
		ka.state = maState_expectValue
		ka.f = 13
	case "Nonce":
		if ka.s&fieldBit__Header_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce}
		}
		ka.s += fieldBit__Header_Nonce
		ka.state = maState_expectValue
		ka.f = 14
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Header", Key: &_String{k}}
	}
	return nil
}
func (_Header__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Header.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Header) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Header) Representation() ipld.Node {
	return (*_Header__Repr)(n)
}

type _Header__Repr _Header

var (
	fieldName__Header_ParentCID_serial    = _String{"ParentCID"}
	fieldName__Header_UnclesCID_serial    = _String{"UnclesCID"}
	fieldName__Header_Coinbase_serial     = _String{"Coinbase"}
	fieldName__Header_StateRootCID_serial = _String{"StateRootCID"}
	fieldName__Header_TxRootCID_serial    = _String{"TxRootCID"}
	fieldName__Header_RctRootCID_serial   = _String{"RctRootCID"}
	fieldName__Header_Bloom_serial        = _String{"Bloom"}
	fieldName__Header_Difficulty_serial   = _String{"Difficulty"}
	fieldName__Header_Number_serial       = _String{"Number"}
	fieldName__Header_GasLimit_serial     = _String{"GasLimit"}
	fieldName__Header_GasUsed_serial      = _String{"GasUsed"}
	fieldName__Header_Time_serial         = _String{"Time"}
	fieldName__Header_Extra_serial        = _String{"Extra"}
	fieldName__Header_MixDigest_serial    = _String{"MixDigest"}
	fieldName__Header_Nonce_serial        = _String{"Nonce"}
)
var _ ipld.Node = &_Header__Repr{}

func (_Header__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Header__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ParentCID":
		return n.ParentCID.Representation(), nil
	case "UnclesCID":
		return n.UnclesCID.Representation(), nil
	case "Coinbase":
		return n.Coinbase.Representation(), nil
	case "StateRootCID":
		return n.StateRootCID.Representation(), nil
	case "TxRootCID":
		return n.TxRootCID.Representation(), nil
	case "RctRootCID":
		return n.RctRootCID.Representation(), nil
	case "Bloom":
		return n.Bloom.Representation(), nil
	case "Difficulty":
		return n.Difficulty.Representation(), nil
	case "Number":
		return n.Number.Representation(), nil
	case "GasLimit":
		return n.GasLimit.Representation(), nil
	case "GasUsed":
		return n.GasUsed.Representation(), nil
	case "Time":
		return n.Time.Representation(), nil
	case "Extra":
		return n.Extra.Representation(), nil
	case "MixDigest":
		return n.MixDigest.Representation(), nil
	case "Nonce":
		return n.Nonce.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Header__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Header__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Header.Repr"}.LookupByIndex(0)
}
func (n _Header__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Header__Repr) MapIterator() ipld.MapIterator {
	return &_Header__ReprMapItr{n, 0}
}

type _Header__ReprMapItr struct {
	n   *_Header__Repr
	idx int
}

func (itr *_Header__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 15 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_ParentCID_serial
		v = itr.n.ParentCID.Representation()
	case 1:
		k = &fieldName__Header_UnclesCID_serial
		v = itr.n.UnclesCID.Representation()
	case 2:
		k = &fieldName__Header_Coinbase_serial
		v = itr.n.Coinbase.Representation()
	case 3:
		k = &fieldName__Header_StateRootCID_serial
		v = itr.n.StateRootCID.Representation()
	case 4:
		k = &fieldName__Header_TxRootCID_serial
		v = itr.n.TxRootCID.Representation()
	case 5:
		k = &fieldName__Header_RctRootCID_serial
		v = itr.n.RctRootCID.Representation()
	case 6:
		k = &fieldName__Header_Bloom_serial
		v = itr.n.Bloom.Representation()
	case 7:
		k = &fieldName__Header_Difficulty_serial
		v = itr.n.Difficulty.Representation()
	case 8:
		k = &fieldName__Header_Number_serial
		v = itr.n.Number.Representation()
	case 9:
		k = &fieldName__Header_GasLimit_serial
		v = itr.n.GasLimit.Representation()
	case 10:
		k = &fieldName__Header_GasUsed_serial
		v = itr.n.GasUsed.Representation()
	case 11:
		k = &fieldName__Header_Time_serial
		v = itr.n.Time.Representation()
	case 12:
		k = &fieldName__Header_Extra_serial
		v = itr.n.Extra.Representation()
	case 13:
		k = &fieldName__Header_MixDigest_serial
		v = itr.n.MixDigest.Representation()
	case 14:
		k = &fieldName__Header_Nonce_serial
		v = itr.n.Nonce.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__ReprMapItr) Done() bool {
	return itr.idx >= 15
}
func (_Header__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Header__Repr) Length() int64 {
	l := 15
	return int64(l)
}
func (_Header__Repr) IsAbsent() bool {
	return false
}
func (_Header__Repr) IsNull() bool {
	return false
}
func (_Header__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsBool()
}
func (_Header__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsInt()
}
func (_Header__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsFloat()
}
func (_Header__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsString()
}
func (_Header__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsBytes()
}
func (_Header__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Header.Repr"}.AsLink()
}
func (_Header__Repr) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}

type _Header__ReprPrototype struct{}

func (_Header__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__ReprBuilder
	nb.Reset()
	return &nb
}

type _Header__ReprBuilder struct {
	_Header__ReprAssembler
}

func (nb *_Header__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__ReprBuilder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__ReprBuilder{_Header__ReprAssembler{w: &w, m: &m}}
}

type _Header__ReprAssembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ParentCID    _Link__ReprAssembler
	ca_UnclesCID    _Link__ReprAssembler
	ca_Coinbase     _Address__ReprAssembler
	ca_StateRootCID _Link__ReprAssembler
	ca_TxRootCID    _Link__ReprAssembler
	ca_RctRootCID   _Link__ReprAssembler
	ca_Bloom        _Bloom__ReprAssembler
	ca_Difficulty   _BigInt__ReprAssembler
	ca_Number       _BigInt__ReprAssembler
	ca_GasLimit     _Uint__ReprAssembler
	ca_GasUsed      _Uint__ReprAssembler
	ca_Time         _Time__ReprAssembler
	ca_Extra        _Bytes__ReprAssembler
	ca_MixDigest    _Hash__ReprAssembler
	ca_Nonce        _BlockNonce__ReprAssembler
}

func (na *_Header__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ParentCID.reset()
	na.ca_UnclesCID.reset()
	na.ca_Coinbase.reset()
	na.ca_StateRootCID.reset()
	na.ca_TxRootCID.reset()
	na.ca_RctRootCID.reset()
	na.ca_Bloom.reset()
	na.ca_Difficulty.reset()
	na.ca_Number.reset()
	na.ca_GasLimit.reset()
	na.ca_GasUsed.reset()
	na.ca_Time.reset()
	na.ca_Extra.reset()
	na.ca_MixDigest.reset()
	na.ca_Nonce.reset()
}
func (na *_Header__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Header.Repr"}.BeginList(0)
}
func (na *_Header__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Header.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignBool(false)
}
func (_Header__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignInt(0)
}
func (_Header__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignFloat(0)
}
func (_Header__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignString("")
}
func (_Header__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignBytes(nil)
}
func (_Header__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Header.Repr"}.AssignLink(nil)
}
func (na *_Header__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Header.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}
func (ma *_Header__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ParentCID":
		if ma.s&fieldBit__Header_ParentCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID_serial}
		}
		ma.s += fieldBit__Header_ParentCID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID, nil
	case "UnclesCID":
		if ma.s&fieldBit__Header_UnclesCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID_serial}
		}
		ma.s += fieldBit__Header_UnclesCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID, nil
	case "Coinbase":
		if ma.s&fieldBit__Header_Coinbase != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase_serial}
		}
		ma.s += fieldBit__Header_Coinbase
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase, nil
	case "StateRootCID":
		if ma.s&fieldBit__Header_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID_serial}
		}
		ma.s += fieldBit__Header_StateRootCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "TxRootCID":
		if ma.s&fieldBit__Header_TxRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID_serial}
		}
		ma.s += fieldBit__Header_TxRootCID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID, nil
	case "RctRootCID":
		if ma.s&fieldBit__Header_RctRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID_serial}
		}
		ma.s += fieldBit__Header_RctRootCID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID, nil
	case "Bloom":
		if ma.s&fieldBit__Header_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom_serial}
		}
		ma.s += fieldBit__Header_Bloom
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Difficulty":
		if ma.s&fieldBit__Header_Difficulty != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty_serial}
		}
		ma.s += fieldBit__Header_Difficulty
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty, nil
	case "Number":
		if ma.s&fieldBit__Header_Number != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number_serial}
		}
		ma.s += fieldBit__Header_Number
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number, nil
	case "GasLimit":
		if ma.s&fieldBit__Header_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit_serial}
		}
		ma.s += fieldBit__Header_GasLimit
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "GasUsed":
		if ma.s&fieldBit__Header_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed_serial}
		}
		ma.s += fieldBit__Header_GasUsed
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "Extra":
		if ma.s&fieldBit__Header_Extra != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra_serial}
		}
		ma.s += fieldBit__Header_Extra
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra, nil
	case "MixDigest":
		if ma.s&fieldBit__Header_MixDigest != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest_serial}
		}
		ma.s += fieldBit__Header_MixDigest
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest, nil
	case "Nonce":
		if ma.s&fieldBit__Header_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce_serial}
		}
		ma.s += fieldBit__Header_Nonce
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Header.Repr", Key: &_String{k}}
}
func (ma *_Header__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__ReprKeyAssembler)(ma)
}
func (ma *_Header__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID
	case 1:
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID
	case 2:
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase
	case 3:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 4:
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID
	case 5:
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID
	case 6:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 7:
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty
	case 8:
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number
	case 9:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 10:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	case 11:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 12:
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra
	case 13:
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest
	case 14:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_ParentCID == 0 {
			err.Missing = append(err.Missing, "ParentCID")
		}
		if ma.s&fieldBit__Header_UnclesCID == 0 {
			err.Missing = append(err.Missing, "UnclesCID")
		}
		if ma.s&fieldBit__Header_Coinbase == 0 {
			err.Missing = append(err.Missing, "Coinbase")
		}
		if ma.s&fieldBit__Header_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__Header_TxRootCID == 0 {
			err.Missing = append(err.Missing, "TxRootCID")
		}
		if ma.s&fieldBit__Header_RctRootCID == 0 {
			err.Missing = append(err.Missing, "RctRootCID")
		}
		if ma.s&fieldBit__Header_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Header_Difficulty == 0 {
			err.Missing = append(err.Missing, "Difficulty")
		}
		if ma.s&fieldBit__Header_Number == 0 {
			err.Missing = append(err.Missing, "Number")
		}
		if ma.s&fieldBit__Header_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Header_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_Extra == 0 {
			err.Missing = append(err.Missing, "Extra")
		}
		if ma.s&fieldBit__Header_MixDigest == 0 {
			err.Missing = append(err.Missing, "MixDigest")
		}
		if ma.s&fieldBit__Header_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Header__ReprKeyAssembler _Header__ReprAssembler

func (_Header__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Header__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Header__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignNull()
}
func (_Header__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Header__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Header__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ParentCID":
		if ka.s&fieldBit__Header_ParentCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID_serial}
		}
		ka.s += fieldBit__Header_ParentCID
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "UnclesCID":
		if ka.s&fieldBit__Header_UnclesCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID_serial}
		}
		ka.s += fieldBit__Header_UnclesCID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Coinbase":
		if ka.s&fieldBit__Header_Coinbase != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase_serial}
		}
		ka.s += fieldBit__Header_Coinbase
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "StateRootCID":
		if ka.s&fieldBit__Header_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID_serial}
		}
		ka.s += fieldBit__Header_StateRootCID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "TxRootCID":
		if ka.s&fieldBit__Header_TxRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID_serial}
		}
		ka.s += fieldBit__Header_TxRootCID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "RctRootCID":
		if ka.s&fieldBit__Header_RctRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID_serial}
		}
		ka.s += fieldBit__Header_RctRootCID
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Bloom":
		if ka.s&fieldBit__Header_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom_serial}
		}
		ka.s += fieldBit__Header_Bloom
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Difficulty":
		if ka.s&fieldBit__Header_Difficulty != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty_serial}
		}
		ka.s += fieldBit__Header_Difficulty
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "Number":
		if ka.s&fieldBit__Header_Number != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number_serial}
		}
		ka.s += fieldBit__Header_Number
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "GasLimit":
		if ka.s&fieldBit__Header_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit_serial}
		}
		ka.s += fieldBit__Header_GasLimit
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "GasUsed":
		if ka.s&fieldBit__Header_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed_serial}
		}
		ka.s += fieldBit__Header_GasUsed
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "Extra":
		if ka.s&fieldBit__Header_Extra != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra_serial}
		}
		ka.s += fieldBit__Header_Extra
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "MixDigest":
		if ka.s&fieldBit__Header_MixDigest != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest_serial}
		}
		ka.s += fieldBit__Header_MixDigest
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	case "Nonce":
		if ka.s&fieldBit__Header_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce_serial}
		}
		ka.s += fieldBit__Header_Nonce
		ka.state = maState_expectValue
		ka.f = 14
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Header.Repr", Key: &_String{k}}
}
func (_Header__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Header.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Int) Int() int64 {
	return n.x
}
func (_Int__Prototype) FromInt(v int64) (Int, error) {
	n := _Int{v}
	return &n, nil
}

type _Int__Maybe struct {
	m schema.Maybe
	v Int
}
type MaybeInt = *_Int__Maybe

func (m MaybeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeInt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeInt) Must() Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Int)(&_Int{})
var _ schema.TypedNode = (Int)(&_Int{})

func (Int) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Int) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"dageth.Int"}.LookupByString("")
}
func (Int) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"dageth.Int"}.LookupByNode(nil)
}
func (Int) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"dageth.Int"}.LookupByIndex(0)
}
func (Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"dageth.Int"}.LookupBySegment(seg)
}
func (Int) MapIterator() ipld.MapIterator {
	return nil
}
func (Int) ListIterator() ipld.ListIterator {
	return nil
}
func (Int) Length() int64 {
	return -1
}
func (Int) IsAbsent() bool {
	return false
}
func (Int) IsNull() bool {
	return false
}
func (Int) AsBool() (bool, error) {
	return mixins.Int{"dageth.Int"}.AsBool()
}
func (n Int) AsInt() (int64, error) {
	return n.x, nil
}
func (Int) AsFloat() (float64, error) {
	return mixins.Int{"dageth.Int"}.AsFloat()
}
func (Int) AsString() (string, error) {
	return mixins.Int{"dageth.Int"}.AsString()
}
func (Int) AsBytes() ([]byte, error) {
	return mixins.Int{"dageth.Int"}.AsBytes()
}
func (Int) AsLink() (ipld.Link, error) {
	return mixins.Int{"dageth.Int"}.AsLink()
}
func (Int) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}

type _Int__Prototype struct{}

func (_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Int__Builder
	nb.Reset()
	return &nb
}

type _Int__Builder struct {
	_Int__Assembler
}

func (nb *_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Int__Builder) Reset() {
	var w _Int
	var m schema.Maybe
	*nb = _Int__Builder{_Int__Assembler{w: &w, m: &m}}
}

type _Int__Assembler struct {
	w *_Int
	m *schema.Maybe
}

func (na *_Int__Assembler) reset() {}
func (_Int__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"dageth.Int"}.BeginMap(0)
}
func (_Int__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"dageth.Int"}.BeginList(0)
}
func (na *_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"dageth.Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Int__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"dageth.Int"}.AssignBool(false)
}
func (na *_Int__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Int{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Int__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"dageth.Int"}.AssignFloat(0)
}
func (_Int__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"dageth.Int"}.AssignString("")
}
func (_Int__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"dageth.Int"}.AssignBytes(nil)
}
func (_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"dageth.Int"}.AssignLink(nil)
}
func (na *_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Int__Assembler) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Int) Representation() ipld.Node {
	return (*_Int__Repr)(n)
}

type _Int__Repr = _Int

var _ ipld.Node = &_Int__Repr{}

type _Int__ReprPrototype = _Int__Prototype
type _Int__ReprAssembler = _Int__Assembler

func (n Link) Link() ipld.Link {
	return n.x
}
func (_Link__Prototype) FromLink(v ipld.Link) (Link, error) {
	n := _Link{v}
	return &n, nil
}

type _Link__Maybe struct {
	m schema.Maybe
	v Link
}
type MaybeLink = *_Link__Maybe

func (m MaybeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLink) Must() Link {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Link)(&_Link{})
var _ schema.TypedNode = (Link)(&_Link{})

func (Link) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"dageth.Link"}.LookupByString("")
}
func (Link) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"dageth.Link"}.LookupByNode(nil)
}
func (Link) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"dageth.Link"}.LookupByIndex(0)
}
func (Link) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"dageth.Link"}.LookupBySegment(seg)
}
func (Link) MapIterator() ipld.MapIterator {
	return nil
}
func (Link) ListIterator() ipld.ListIterator {
	return nil
}
func (Link) Length() int64 {
	return -1
}
func (Link) IsAbsent() bool {
	return false
}
func (Link) IsNull() bool {
	return false
}
func (Link) AsBool() (bool, error) {
	return mixins.Link{"dageth.Link"}.AsBool()
}
func (Link) AsInt() (int64, error) {
	return mixins.Link{"dageth.Link"}.AsInt()
}
func (Link) AsFloat() (float64, error) {
	return mixins.Link{"dageth.Link"}.AsFloat()
}
func (Link) AsString() (string, error) {
	return mixins.Link{"dageth.Link"}.AsString()
}
func (Link) AsBytes() ([]byte, error) {
	return mixins.Link{"dageth.Link"}.AsBytes()
}
func (n Link) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}

type _Link__Prototype struct{}

func (_Link__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link__Builder
	nb.Reset()
	return &nb
}

type _Link__Builder struct {
	_Link__Assembler
}

func (nb *_Link__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link__Builder) Reset() {
	var w _Link
	var m schema.Maybe
	*nb = _Link__Builder{_Link__Assembler{w: &w, m: &m}}
}

type _Link__Assembler struct {
	w *_Link
	m *schema.Maybe
}

func (na *_Link__Assembler) reset() {}
func (_Link__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"dageth.Link"}.BeginMap(0)
}
func (_Link__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"dageth.Link"}.BeginList(0)
}
func (na *_Link__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"dageth.Link"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"dageth.Link"}.AssignBool(false)
}
func (_Link__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"dageth.Link"}.AssignInt(0)
}
func (_Link__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"dageth.Link"}.AssignFloat(0)
}
func (_Link__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"dageth.Link"}.AssignString("")
}
func (_Link__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"dageth.Link"}.AssignBytes(nil)
}
func (na *_Link__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link__Assembler) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
func (Link) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Link) Representation() ipld.Node {
	return (*_Link__Repr)(n)
}

type _Link__Repr = _Link

var _ ipld.Node = &_Link__Repr{}

type _Link__ReprPrototype = _Link__Prototype
type _Link__ReprAssembler = _Link__Assembler

func (n _Log) FieldAddress() Address {
	return &n.Address
}
func (n _Log) FieldTopics() Topics {
	return &n.Topics
}
func (n _Log) FieldData() Bytes {
	return &n.Data
}

type _Log__Maybe struct {
	m schema.Maybe
	v Log
}
type MaybeLog = *_Log__Maybe

func (m MaybeLog) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLog) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLog) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLog) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLog) Must() Log {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Log_Address = _String{"Address"}
	fieldName__Log_Topics  = _String{"Topics"}
	fieldName__Log_Data    = _String{"Data"}
)
var _ ipld.Node = (Log)(&_Log{})
var _ schema.TypedNode = (Log)(&_Log{})

func (Log) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Log) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "Topics":
		return &n.Topics, nil
	case "Data":
		return &n.Data, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Log) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Log) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Log"}.LookupByIndex(0)
}
func (n Log) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Log) MapIterator() ipld.MapIterator {
	return &_Log__MapItr{n, 0}
}

type _Log__MapItr struct {
	n   Log
	idx int
}

func (itr *_Log__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Log_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__Log_Topics
		v = &itr.n.Topics
	case 2:
		k = &fieldName__Log_Data
		v = &itr.n.Data
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Log__MapItr) Done() bool {
	return itr.idx >= 3
}

func (Log) ListIterator() ipld.ListIterator {
	return nil
}
func (Log) Length() int64 {
	return 3
}
func (Log) IsAbsent() bool {
	return false
}
func (Log) IsNull() bool {
	return false
}
func (Log) AsBool() (bool, error) {
	return mixins.Map{"dageth.Log"}.AsBool()
}
func (Log) AsInt() (int64, error) {
	return mixins.Map{"dageth.Log"}.AsInt()
}
func (Log) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Log"}.AsFloat()
}
func (Log) AsString() (string, error) {
	return mixins.Map{"dageth.Log"}.AsString()
}
func (Log) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Log"}.AsBytes()
}
func (Log) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Log"}.AsLink()
}
func (Log) Prototype() ipld.NodePrototype {
	return _Log__Prototype{}
}

type _Log__Prototype struct{}

func (_Log__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Log__Builder
	nb.Reset()
	return &nb
}

type _Log__Builder struct {
	_Log__Assembler
}

func (nb *_Log__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Log__Builder) Reset() {
	var w _Log
	var m schema.Maybe
	*nb = _Log__Builder{_Log__Assembler{w: &w, m: &m}}
}

type _Log__Assembler struct {
	w     *_Log
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Address _Address__Assembler
	ca_Topics  _Topics__Assembler
	ca_Data    _Bytes__Assembler
}

func (na *_Log__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_Topics.reset()
	na.ca_Data.reset()
}

var (
	fieldBit__Log_Address     = 1 << 0
	fieldBit__Log_Topics      = 1 << 1
	fieldBit__Log_Data        = 1 << 2
	fieldBits__Log_sufficient = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_Log__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Log{}
	}
	return na, nil
}
func (_Log__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Log"}.BeginList(0)
}
func (na *_Log__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Log"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Log__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignBool(false)
}
func (_Log__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignInt(0)
}
func (_Log__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignFloat(0)
}
func (_Log__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignString("")
}
func (_Log__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignBytes(nil)
}
func (_Log__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Log"}.AssignLink(nil)
}
func (na *_Log__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Log); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Log", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Log__Assembler) Prototype() ipld.NodePrototype {
	return _Log__Prototype{}
}
func (ma *_Log__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Topics.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Log__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Log_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address}
		}
		ma.s += fieldBit__Log_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "Topics":
		if ma.s&fieldBit__Log_Topics != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics}
		}
		ma.s += fieldBit__Log_Topics
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics, nil
	case "Data":
		if ma.s&fieldBit__Log_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data}
		}
		ma.s += fieldBit__Log_Data
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Log", Key: &_String{k}}
}
func (ma *_Log__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Log__KeyAssembler)(ma)
}
func (ma *_Log__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics
	case 2:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	default:
		panic("unreachable")
	}
}
func (ma *_Log__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Log_sufficient != fieldBits__Log_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Log_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Log_Topics == 0 {
			err.Missing = append(err.Missing, "Topics")
		}
		if ma.s&fieldBit__Log_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Log__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Log__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Log__KeyAssembler _Log__Assembler

func (_Log__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.BeginMap(0)
}
func (_Log__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.BeginList(0)
}
func (na *_Log__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignNull()
}
func (_Log__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignBool(false)
}
func (_Log__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignInt(0)
}
func (_Log__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Log__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Log_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address}
		}
		ka.s += fieldBit__Log_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "Topics":
		if ka.s&fieldBit__Log_Topics != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics}
		}
		ka.s += fieldBit__Log_Topics
		ka.state = maState_expectValue
		ka.f = 1
	case "Data":
		if ka.s&fieldBit__Log_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data}
		}
		ka.s += fieldBit__Log_Data
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Log", Key: &_String{k}}
	}
	return nil
}
func (_Log__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignBytes(nil)
}
func (_Log__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Log.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Log__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Log__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Log) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Log) Representation() ipld.Node {
	return (*_Log__Repr)(n)
}

type _Log__Repr _Log

var (
	fieldName__Log_Address_serial = _String{"Address"}
	fieldName__Log_Topics_serial  = _String{"Topics"}
	fieldName__Log_Data_serial    = _String{"Data"}
)
var _ ipld.Node = &_Log__Repr{}

func (_Log__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Log__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "Topics":
		return n.Topics.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Log__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Log__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Log.Repr"}.LookupByIndex(0)
}
func (n _Log__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Log__Repr) MapIterator() ipld.MapIterator {
	return &_Log__ReprMapItr{n, 0}
}

type _Log__ReprMapItr struct {
	n   *_Log__Repr
	idx int
}

func (itr *_Log__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Log_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__Log_Topics_serial
		v = itr.n.Topics.Representation()
	case 2:
		k = &fieldName__Log_Data_serial
		v = itr.n.Data.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Log__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_Log__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Log__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_Log__Repr) IsAbsent() bool {
	return false
}
func (_Log__Repr) IsNull() bool {
	return false
}
func (_Log__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsBool()
}
func (_Log__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsInt()
}
func (_Log__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsFloat()
}
func (_Log__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsString()
}
func (_Log__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsBytes()
}
func (_Log__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Log.Repr"}.AsLink()
}
func (_Log__Repr) Prototype() ipld.NodePrototype {
	return _Log__ReprPrototype{}
}

type _Log__ReprPrototype struct{}

func (_Log__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Log__ReprBuilder
	nb.Reset()
	return &nb
}

type _Log__ReprBuilder struct {
	_Log__ReprAssembler
}

func (nb *_Log__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Log__ReprBuilder) Reset() {
	var w _Log
	var m schema.Maybe
	*nb = _Log__ReprBuilder{_Log__ReprAssembler{w: &w, m: &m}}
}

type _Log__ReprAssembler struct {
	w     *_Log
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Address _Address__ReprAssembler
	ca_Topics  _Topics__ReprAssembler
	ca_Data    _Bytes__ReprAssembler
}

func (na *_Log__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_Topics.reset()
	na.ca_Data.reset()
}
func (na *_Log__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Log{}
	}
	return na, nil
}
func (_Log__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Log.Repr"}.BeginList(0)
}
func (na *_Log__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Log.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Log__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignBool(false)
}
func (_Log__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignInt(0)
}
func (_Log__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignFloat(0)
}
func (_Log__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignString("")
}
func (_Log__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignBytes(nil)
}
func (_Log__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Log.Repr"}.AssignLink(nil)
}
func (na *_Log__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Log); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Log.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Log__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Log__ReprPrototype{}
}
func (ma *_Log__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Log__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Log_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address_serial}
		}
		ma.s += fieldBit__Log_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "Topics":
		if ma.s&fieldBit__Log_Topics != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics_serial}
		}
		ma.s += fieldBit__Log_Topics
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics, nil
	case "Data":
		if ma.s&fieldBit__Log_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data_serial}
		}
		ma.s += fieldBit__Log_Data
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Log.Repr", Key: &_String{k}}
}
func (ma *_Log__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Log__ReprKeyAssembler)(ma)
}
func (ma *_Log__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics
	case 2:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	default:
		panic("unreachable")
	}
}
func (ma *_Log__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Log_sufficient != fieldBits__Log_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Log_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Log_Topics == 0 {
			err.Missing = append(err.Missing, "Topics")
		}
		if ma.s&fieldBit__Log_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Log__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Log__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Log__ReprKeyAssembler _Log__ReprAssembler

func (_Log__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Log__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Log__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignNull()
}
func (_Log__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Log__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Log__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Log__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Log_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address_serial}
		}
		ka.s += fieldBit__Log_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Topics":
		if ka.s&fieldBit__Log_Topics != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics_serial}
		}
		ka.s += fieldBit__Log_Topics
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Data":
		if ka.s&fieldBit__Log_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data_serial}
		}
		ka.s += fieldBit__Log_Data
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Log.Repr", Key: &_String{k}}
}
func (_Log__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Log__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Log.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Log__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Log__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Logs) Lookup(idx int64) Log {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Logs) LookupMaybe(idx int64) MaybeLog {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Log__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Logs__valueAbsent = _Log__Maybe{m: schema.Maybe_Absent}

func (n Logs) Iterator() *Logs__Itr {
	return &Logs__Itr{n, 0}
}

type Logs__Itr struct {
	n   Logs
	idx int
}

func (itr *Logs__Itr) Next() (idx int64, v Log) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Logs__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Logs__Maybe struct {
	m schema.Maybe
	v Logs
}
type MaybeLogs = *_Logs__Maybe

func (m MaybeLogs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLogs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLogs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLogs) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLogs) Must() Logs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Logs)(&_Logs{})
var _ schema.TypedNode = (Logs)(&_Logs{})

func (Logs) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Logs) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Logs"}.LookupByString("")
}
func (n Logs) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Logs) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Logs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Logs", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Logs) MapIterator() ipld.MapIterator {
	return nil
}
func (n Logs) ListIterator() ipld.ListIterator {
	return &_Logs__ListItr{n, 0}
}

type _Logs__ListItr struct {
	n   Logs
	idx int
}

func (itr *_Logs__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Logs__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Logs) Length() int64 {
	return int64(len(n.x))
}
func (Logs) IsAbsent() bool {
	return false
}
func (Logs) IsNull() bool {
	return false
}
func (Logs) AsBool() (bool, error) {
	return mixins.List{"dageth.Logs"}.AsBool()
}
func (Logs) AsInt() (int64, error) {
	return mixins.List{"dageth.Logs"}.AsInt()
}
func (Logs) AsFloat() (float64, error) {
	return mixins.List{"dageth.Logs"}.AsFloat()
}
func (Logs) AsString() (string, error) {
	return mixins.List{"dageth.Logs"}.AsString()
}
func (Logs) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Logs"}.AsBytes()
}
func (Logs) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Logs"}.AsLink()
}
func (Logs) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}

type _Logs__Prototype struct{}

func (_Logs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__Builder
	nb.Reset()
	return &nb
}

type _Logs__Builder struct {
	_Logs__Assembler
}

func (nb *_Logs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__Builder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__Builder{_Logs__Assembler{w: &w, m: &m}}
}

type _Logs__Assembler struct {
	w     *_Logs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Log__Assembler
}

func (na *_Logs__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Logs__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Logs"}.BeginMap(0)
}
func (na *_Logs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Logs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Log, 0, sizeHint)
	}
	return na, nil
}
func (na *_Logs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Logs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignBool(false)
}
func (_Logs__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignInt(0)
}
func (_Logs__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignFloat(0)
}
func (_Logs__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignString("")
}
func (_Logs__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignBytes(nil)
}
func (_Logs__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Logs"}.AssignLink(nil)
}
func (na *_Logs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Logs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__Assembler) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}
func (la *_Logs__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Logs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Log{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Logs__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Logs__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Log__Prototype{}
}
func (Logs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Logs) Representation() ipld.Node {
	return (*_Logs__Repr)(n)
}

type _Logs__Repr _Logs

var _ ipld.Node = &_Logs__Repr{}

func (_Logs__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Logs__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Logs.Repr"}.LookupByString("")
}
func (nr *_Logs__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Logs)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Log).Representation(), nil
}
func (nr *_Logs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Logs)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Log).Representation(), nil
}
func (n _Logs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Logs.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Logs__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Logs__Repr) ListIterator() ipld.ListIterator {
	return &_Logs__ReprListItr{(Logs)(nr), 0}
}

type _Logs__ReprListItr _Logs__ListItr

func (itr *_Logs__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Logs__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Log).Representation(), nil
}
func (itr *_Logs__ReprListItr) Done() bool {
	return (*_Logs__ListItr)(itr).Done()
}

func (rn *_Logs__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Logs__Repr) IsAbsent() bool {
	return false
}
func (_Logs__Repr) IsNull() bool {
	return false
}
func (_Logs__Repr) AsBool() (bool, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsBool()
}
func (_Logs__Repr) AsInt() (int64, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsInt()
}
func (_Logs__Repr) AsFloat() (float64, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsFloat()
}
func (_Logs__Repr) AsString() (string, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsString()
}
func (_Logs__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsBytes()
}
func (_Logs__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Logs.Repr"}.AsLink()
}
func (_Logs__Repr) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}

type _Logs__ReprPrototype struct{}

func (_Logs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__ReprBuilder
	nb.Reset()
	return &nb
}

type _Logs__ReprBuilder struct {
	_Logs__ReprAssembler
}

func (nb *_Logs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__ReprBuilder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__ReprBuilder{_Logs__ReprAssembler{w: &w, m: &m}}
}

type _Logs__ReprAssembler struct {
	w     *_Logs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Log__ReprAssembler
}

func (na *_Logs__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Logs__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.BeginMap(0)
}
func (na *_Logs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Logs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Log, 0, sizeHint)
	}
	return na, nil
}
func (na *_Logs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Logs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignBool(false)
}
func (_Logs__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignInt(0)
}
func (_Logs__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignFloat(0)
}
func (_Logs__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignString("")
}
func (_Logs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignBytes(nil)
}
func (_Logs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Logs.Repr"}.AssignLink(nil)
}
func (na *_Logs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Logs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}
func (la *_Logs__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Logs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Log{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Logs__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Logs__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Log__ReprPrototype{}
}

func (n OpCode) Bytes() []byte {
	return n.x
}
func (_OpCode__Prototype) FromBytes(v []byte) (OpCode, error) {
	n := _OpCode{v}
	return &n, nil
}

type _OpCode__Maybe struct {
	m schema.Maybe
	v OpCode
}
type MaybeOpCode = *_OpCode__Maybe

func (m MaybeOpCode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeOpCode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeOpCode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeOpCode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeOpCode) Must() OpCode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (OpCode)(&_OpCode{})
var _ schema.TypedNode = (OpCode)(&_OpCode{})

func (OpCode) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (OpCode) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.OpCode"}.LookupByString("")
}
func (OpCode) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.OpCode"}.LookupByNode(nil)
}
func (OpCode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.OpCode"}.LookupByIndex(0)
}
func (OpCode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.OpCode"}.LookupBySegment(seg)
}
func (OpCode) MapIterator() ipld.MapIterator {
	return nil
}
func (OpCode) ListIterator() ipld.ListIterator {
	return nil
}
func (OpCode) Length() int64 {
	return -1
}
func (OpCode) IsAbsent() bool {
	return false
}
func (OpCode) IsNull() bool {
	return false
}
func (OpCode) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.OpCode"}.AsBool()
}
func (OpCode) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.OpCode"}.AsInt()
}
func (OpCode) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.OpCode"}.AsFloat()
}
func (OpCode) AsString() (string, error) {
	return mixins.Bytes{"dageth.OpCode"}.AsString()
}
func (n OpCode) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (OpCode) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.OpCode"}.AsLink()
}
func (OpCode) Prototype() ipld.NodePrototype {
	return _OpCode__Prototype{}
}

type _OpCode__Prototype struct{}

func (_OpCode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _OpCode__Builder
	nb.Reset()
	return &nb
}

type _OpCode__Builder struct {
	_OpCode__Assembler
}

func (nb *_OpCode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_OpCode__Builder) Reset() {
	var w _OpCode
	var m schema.Maybe
	*nb = _OpCode__Builder{_OpCode__Assembler{w: &w, m: &m}}
}

type _OpCode__Assembler struct {
	w *_OpCode
	m *schema.Maybe
}

func (na *_OpCode__Assembler) reset() {}
func (_OpCode__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.OpCode"}.BeginMap(0)
}
func (_OpCode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.OpCode"}.BeginList(0)
}
func (na *_OpCode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.OpCode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_OpCode__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.OpCode"}.AssignBool(false)
}
func (_OpCode__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.OpCode"}.AssignInt(0)
}
func (_OpCode__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.OpCode"}.AssignFloat(0)
}
func (_OpCode__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.OpCode"}.AssignString("")
}
func (na *_OpCode__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_OpCode{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_OpCode__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.OpCode"}.AssignLink(nil)
}
func (na *_OpCode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_OpCode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_OpCode__Assembler) Prototype() ipld.NodePrototype {
	return _OpCode__Prototype{}
}
func (OpCode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n OpCode) Representation() ipld.Node {
	return (*_OpCode__Repr)(n)
}

type _OpCode__Repr = _OpCode

var _ ipld.Node = &_OpCode__Repr{}

type _OpCode__ReprPrototype = _OpCode__Prototype
type _OpCode__ReprAssembler = _OpCode__Assembler

func (n _Receipt) FieldPostStateOrStatus() Bytes {
	return &n.PostStateOrStatus
}
func (n _Receipt) FieldCumulativeGasUsed() Uint {
	return &n.CumulativeGasUsed
}
func (n _Receipt) FieldBloom() Bloom {
	return &n.Bloom
}
func (n _Receipt) FieldLogs() Logs {
	return &n.Logs
}

type _Receipt__Maybe struct {
	m schema.Maybe
	v Receipt
}
type MaybeReceipt = *_Receipt__Maybe

func (m MaybeReceipt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeReceipt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeReceipt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeReceipt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeReceipt) Must() Receipt {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Receipt_PostStateOrStatus = _String{"PostStateOrStatus"}
	fieldName__Receipt_CumulativeGasUsed = _String{"CumulativeGasUsed"}
	fieldName__Receipt_Bloom             = _String{"Bloom"}
	fieldName__Receipt_Logs              = _String{"Logs"}
)
var _ ipld.Node = (Receipt)(&_Receipt{})
var _ schema.TypedNode = (Receipt)(&_Receipt{})

func (Receipt) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Receipt) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PostStateOrStatus":
		return &n.PostStateOrStatus, nil
	case "CumulativeGasUsed":
		return &n.CumulativeGasUsed, nil
	case "Bloom":
		return &n.Bloom, nil
	case "Logs":
		return &n.Logs, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Receipt) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Receipt) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Receipt"}.LookupByIndex(0)
}
func (n Receipt) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Receipt) MapIterator() ipld.MapIterator {
	return &_Receipt__MapItr{n, 0}
}

type _Receipt__MapItr struct {
	n   Receipt
	idx int
}

func (itr *_Receipt__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Receipt_PostStateOrStatus
		v = &itr.n.PostStateOrStatus
	case 1:
		k = &fieldName__Receipt_CumulativeGasUsed
		v = &itr.n.CumulativeGasUsed
	case 2:
		k = &fieldName__Receipt_Bloom
		v = &itr.n.Bloom
	case 3:
		k = &fieldName__Receipt_Logs
		v = &itr.n.Logs
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Receipt__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Receipt) ListIterator() ipld.ListIterator {
	return nil
}
func (Receipt) Length() int64 {
	return 4
}
func (Receipt) IsAbsent() bool {
	return false
}
func (Receipt) IsNull() bool {
	return false
}
func (Receipt) AsBool() (bool, error) {
	return mixins.Map{"dageth.Receipt"}.AsBool()
}
func (Receipt) AsInt() (int64, error) {
	return mixins.Map{"dageth.Receipt"}.AsInt()
}
func (Receipt) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Receipt"}.AsFloat()
}
func (Receipt) AsString() (string, error) {
	return mixins.Map{"dageth.Receipt"}.AsString()
}
func (Receipt) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Receipt"}.AsBytes()
}
func (Receipt) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Receipt"}.AsLink()
}
func (Receipt) Prototype() ipld.NodePrototype {
	return _Receipt__Prototype{}
}

type _Receipt__Prototype struct{}

func (_Receipt__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipt__Builder
	nb.Reset()
	return &nb
}

type _Receipt__Builder struct {
	_Receipt__Assembler
}

func (nb *_Receipt__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipt__Builder) Reset() {
	var w _Receipt
	var m schema.Maybe
	*nb = _Receipt__Builder{_Receipt__Assembler{w: &w, m: &m}}
}

type _Receipt__Assembler struct {
	w     *_Receipt
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                   schema.Maybe
	ca_PostStateOrStatus _Bytes__Assembler
	ca_CumulativeGasUsed _Uint__Assembler
	ca_Bloom             _Bloom__Assembler
	ca_Logs              _Logs__Assembler
}

func (na *_Receipt__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PostStateOrStatus.reset()
	na.ca_CumulativeGasUsed.reset()
	na.ca_Bloom.reset()
	na.ca_Logs.reset()
}

var (
	fieldBit__Receipt_PostStateOrStatus = 1 << 0
	fieldBit__Receipt_CumulativeGasUsed = 1 << 1
	fieldBit__Receipt_Bloom             = 1 << 2
	fieldBit__Receipt_Logs              = 1 << 3
	fieldBits__Receipt_sufficient       = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Receipt__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Receipt{}
	}
	return na, nil
}
func (_Receipt__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Receipt"}.BeginList(0)
}
func (na *_Receipt__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Receipt"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipt__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignBool(false)
}
func (_Receipt__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignInt(0)
}
func (_Receipt__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignFloat(0)
}
func (_Receipt__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignString("")
}
func (_Receipt__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignBytes(nil)
}
func (_Receipt__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Receipt"}.AssignLink(nil)
}
func (na *_Receipt__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipt", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipt__Assembler) Prototype() ipld.NodePrototype {
	return _Receipt__Prototype{}
}
func (ma *_Receipt__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PostStateOrStatus.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CumulativeGasUsed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bloom.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Logs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PostStateOrStatus":
		if ma.s&fieldBit__Receipt_PostStateOrStatus != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostStateOrStatus}
		}
		ma.s += fieldBit__Receipt_PostStateOrStatus
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PostStateOrStatus.w = &ma.w.PostStateOrStatus
		ma.ca_PostStateOrStatus.m = &ma.cm
		return &ma.ca_PostStateOrStatus, nil
	case "CumulativeGasUsed":
		if ma.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed}
		}
		ma.s += fieldBit__Receipt_CumulativeGasUsed
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed, nil
	case "Bloom":
		if ma.s&fieldBit__Receipt_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom}
		}
		ma.s += fieldBit__Receipt_Bloom
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Logs":
		if ma.s&fieldBit__Receipt_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs}
		}
		ma.s += fieldBit__Receipt_Logs
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Receipt", Key: &_String{k}}
}
func (ma *_Receipt__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Receipt__KeyAssembler)(ma)
}
func (ma *_Receipt__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PostStateOrStatus.w = &ma.w.PostStateOrStatus
		ma.ca_PostStateOrStatus.m = &ma.cm
		return &ma.ca_PostStateOrStatus
	case 1:
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed
	case 2:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 3:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Receipt_sufficient != fieldBits__Receipt_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Receipt_PostStateOrStatus == 0 {
			err.Missing = append(err.Missing, "PostStateOrStatus")
		}
		if ma.s&fieldBit__Receipt_CumulativeGasUsed == 0 {
			err.Missing = append(err.Missing, "CumulativeGasUsed")
		}
		if ma.s&fieldBit__Receipt_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Receipt_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Receipt__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Receipt__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Receipt__KeyAssembler _Receipt__Assembler

func (_Receipt__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.BeginMap(0)
}
func (_Receipt__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.BeginList(0)
}
func (na *_Receipt__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignNull()
}
func (_Receipt__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignBool(false)
}
func (_Receipt__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignInt(0)
}
func (_Receipt__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Receipt__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PostStateOrStatus":
		if ka.s&fieldBit__Receipt_PostStateOrStatus != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostStateOrStatus}
		}
		ka.s += fieldBit__Receipt_PostStateOrStatus
		ka.state = maState_expectValue
		ka.f = 0
	case "CumulativeGasUsed":
		if ka.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed}
		}
		ka.s += fieldBit__Receipt_CumulativeGasUsed
		ka.state = maState_expectValue
		ka.f = 1
	case "Bloom":
		if ka.s&fieldBit__Receipt_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom}
		}
		ka.s += fieldBit__Receipt_Bloom
		ka.state = maState_expectValue
		ka.f = 2
	case "Logs":
		if ka.s&fieldBit__Receipt_Logs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs}
		}
		ka.s += fieldBit__Receipt_Logs
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Receipt", Key: &_String{k}}
	}
	return nil
}
func (_Receipt__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignBytes(nil)
}
func (_Receipt__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Receipt.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Receipt__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Receipt__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Receipt) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Receipt) Representation() ipld.Node {
	return (*_Receipt__Repr)(n)
}

type _Receipt__Repr _Receipt

var (
	fieldName__Receipt_PostStateOrStatus_serial = _String{"PostStateOrStatus"}
	fieldName__Receipt_CumulativeGasUsed_serial = _String{"CumulativeGasUsed"}
	fieldName__Receipt_Bloom_serial             = _String{"Bloom"}
	fieldName__Receipt_Logs_serial              = _String{"Logs"}
)
var _ ipld.Node = &_Receipt__Repr{}

func (_Receipt__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Receipt__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PostStateOrStatus":
		return n.PostStateOrStatus.Representation(), nil
	case "CumulativeGasUsed":
		return n.CumulativeGasUsed.Representation(), nil
	case "Bloom":
		return n.Bloom.Representation(), nil
	case "Logs":
		return n.Logs.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Receipt__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Receipt__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.LookupByIndex(0)
}
func (n _Receipt__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Receipt__Repr) MapIterator() ipld.MapIterator {
	return &_Receipt__ReprMapItr{n, 0}
}

type _Receipt__ReprMapItr struct {
	n   *_Receipt__Repr
	idx int
}

func (itr *_Receipt__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Receipt_PostStateOrStatus_serial
		v = itr.n.PostStateOrStatus.Representation()
	case 1:
		k = &fieldName__Receipt_CumulativeGasUsed_serial
		v = itr.n.CumulativeGasUsed.Representation()
	case 2:
		k = &fieldName__Receipt_Bloom_serial
		v = itr.n.Bloom.Representation()
	case 3:
		k = &fieldName__Receipt_Logs_serial
		v = itr.n.Logs.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Receipt__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Receipt__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Receipt__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Receipt__Repr) IsAbsent() bool {
	return false
}
func (_Receipt__Repr) IsNull() bool {
	return false
}
func (_Receipt__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsBool()
}
func (_Receipt__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsInt()
}
func (_Receipt__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsFloat()
}
func (_Receipt__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsString()
}
func (_Receipt__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsBytes()
}
func (_Receipt__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Receipt.Repr"}.AsLink()
}
func (_Receipt__Repr) Prototype() ipld.NodePrototype {
	return _Receipt__ReprPrototype{}
}

type _Receipt__ReprPrototype struct{}

func (_Receipt__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipt__ReprBuilder
	nb.Reset()
	return &nb
}

type _Receipt__ReprBuilder struct {
	_Receipt__ReprAssembler
}

func (nb *_Receipt__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipt__ReprBuilder) Reset() {
	var w _Receipt
	var m schema.Maybe
	*nb = _Receipt__ReprBuilder{_Receipt__ReprAssembler{w: &w, m: &m}}
}

type _Receipt__ReprAssembler struct {
	w     *_Receipt
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                   schema.Maybe
	ca_PostStateOrStatus _Bytes__ReprAssembler
	ca_CumulativeGasUsed _Uint__ReprAssembler
	ca_Bloom             _Bloom__ReprAssembler
	ca_Logs              _Logs__ReprAssembler
}

func (na *_Receipt__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PostStateOrStatus.reset()
	na.ca_CumulativeGasUsed.reset()
	na.ca_Bloom.reset()
	na.ca_Logs.reset()
}
func (na *_Receipt__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Receipt{}
	}
	return na, nil
}
func (_Receipt__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.BeginList(0)
}
func (na *_Receipt__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Receipt.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipt__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignBool(false)
}
func (_Receipt__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignInt(0)
}
func (_Receipt__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignFloat(0)
}
func (_Receipt__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignString("")
}
func (_Receipt__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignBytes(nil)
}
func (_Receipt__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Receipt.Repr"}.AssignLink(nil)
}
func (na *_Receipt__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipt.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipt__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Receipt__ReprPrototype{}
}
func (ma *_Receipt__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PostStateOrStatus":
		if ma.s&fieldBit__Receipt_PostStateOrStatus != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostStateOrStatus_serial}
		}
		ma.s += fieldBit__Receipt_PostStateOrStatus
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PostStateOrStatus.w = &ma.w.PostStateOrStatus
		ma.ca_PostStateOrStatus.m = &ma.cm
		return &ma.ca_PostStateOrStatus, nil
	case "CumulativeGasUsed":
		if ma.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed_serial}
		}
		ma.s += fieldBit__Receipt_CumulativeGasUsed
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed, nil
	case "Bloom":
		if ma.s&fieldBit__Receipt_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom_serial}
		}
		ma.s += fieldBit__Receipt_Bloom
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Logs":
		if ma.s&fieldBit__Receipt_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs_serial}
		}
		ma.s += fieldBit__Receipt_Logs
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Receipt.Repr", Key: &_String{k}}
}
func (ma *_Receipt__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Receipt__ReprKeyAssembler)(ma)
}
func (ma *_Receipt__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PostStateOrStatus.w = &ma.w.PostStateOrStatus
		ma.ca_PostStateOrStatus.m = &ma.cm
		return &ma.ca_PostStateOrStatus
	case 1:
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed
	case 2:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 3:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Receipt_sufficient != fieldBits__Receipt_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Receipt_PostStateOrStatus == 0 {
			err.Missing = append(err.Missing, "PostStateOrStatus")
		}
		if ma.s&fieldBit__Receipt_CumulativeGasUsed == 0 {
			err.Missing = append(err.Missing, "CumulativeGasUsed")
		}
		if ma.s&fieldBit__Receipt_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Receipt_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Receipt__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Receipt__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Receipt__ReprKeyAssembler _Receipt__ReprAssembler

func (_Receipt__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Receipt__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Receipt__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignNull()
}
func (_Receipt__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Receipt__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Receipt__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Receipt__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PostStateOrStatus":
		if ka.s&fieldBit__Receipt_PostStateOrStatus != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostStateOrStatus_serial}
		}
		ka.s += fieldBit__Receipt_PostStateOrStatus
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "CumulativeGasUsed":
		if ka.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed_serial}
		}
		ka.s += fieldBit__Receipt_CumulativeGasUsed
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Bloom":
		if ka.s&fieldBit__Receipt_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom_serial}
		}
		ka.s += fieldBit__Receipt_Bloom
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Logs":
		if ka.s&fieldBit__Receipt_Logs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs_serial}
		}
		ka.s += fieldBit__Receipt_Logs
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Receipt.Repr", Key: &_String{k}}
}
func (_Receipt__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Receipt__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Receipt.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Receipt__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Receipt__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _StateAccount) FieldNonce() Uint {
	return &n.Nonce
}
func (n _StateAccount) FieldBalance() Balance {
	return &n.Balance
}
func (n _StateAccount) FieldStorageRootCID() Link {
	return &n.StorageRootCID
}
func (n _StateAccount) FieldCodeCID() Link {
	return &n.CodeCID
}

type _StateAccount__Maybe struct {
	m schema.Maybe
	v StateAccount
}
type MaybeStateAccount = *_StateAccount__Maybe

func (m MaybeStateAccount) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStateAccount) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStateAccount) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStateAccount) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeStateAccount) Must() StateAccount {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__StateAccount_Nonce          = _String{"Nonce"}
	fieldName__StateAccount_Balance        = _String{"Balance"}
	fieldName__StateAccount_StorageRootCID = _String{"StorageRootCID"}
	fieldName__StateAccount_CodeCID        = _String{"CodeCID"}
)
var _ ipld.Node = (StateAccount)(&_StateAccount{})
var _ schema.TypedNode = (StateAccount)(&_StateAccount{})

func (StateAccount) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n StateAccount) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Nonce":
		return &n.Nonce, nil
	case "Balance":
		return &n.Balance, nil
	case "StorageRootCID":
		return &n.StorageRootCID, nil
	case "CodeCID":
		return &n.CodeCID, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StateAccount) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StateAccount) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.StateAccount"}.LookupByIndex(0)
}
func (n StateAccount) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StateAccount) MapIterator() ipld.MapIterator {
	return &_StateAccount__MapItr{n, 0}
}

type _StateAccount__MapItr struct {
	n   StateAccount
	idx int
}

func (itr *_StateAccount__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StateAccount_Nonce
		v = &itr.n.Nonce
	case 1:
		k = &fieldName__StateAccount_Balance
		v = &itr.n.Balance
	case 2:
		k = &fieldName__StateAccount_StorageRootCID
		v = &itr.n.StorageRootCID
	case 3:
		k = &fieldName__StateAccount_CodeCID
		v = &itr.n.CodeCID
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StateAccount__MapItr) Done() bool {
	return itr.idx >= 4
}

func (StateAccount) ListIterator() ipld.ListIterator {
	return nil
}
func (StateAccount) Length() int64 {
	return 4
}
func (StateAccount) IsAbsent() bool {
	return false
}
func (StateAccount) IsNull() bool {
	return false
}
func (StateAccount) AsBool() (bool, error) {
	return mixins.Map{"dageth.StateAccount"}.AsBool()
}
func (StateAccount) AsInt() (int64, error) {
	return mixins.Map{"dageth.StateAccount"}.AsInt()
}
func (StateAccount) AsFloat() (float64, error) {
	return mixins.Map{"dageth.StateAccount"}.AsFloat()
}
func (StateAccount) AsString() (string, error) {
	return mixins.Map{"dageth.StateAccount"}.AsString()
}
func (StateAccount) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.StateAccount"}.AsBytes()
}
func (StateAccount) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.StateAccount"}.AsLink()
}
func (StateAccount) Prototype() ipld.NodePrototype {
	return _StateAccount__Prototype{}
}

type _StateAccount__Prototype struct{}

func (_StateAccount__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StateAccount__Builder
	nb.Reset()
	return &nb
}

type _StateAccount__Builder struct {
	_StateAccount__Assembler
}

func (nb *_StateAccount__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StateAccount__Builder) Reset() {
	var w _StateAccount
	var m schema.Maybe
	*nb = _StateAccount__Builder{_StateAccount__Assembler{w: &w, m: &m}}
}

type _StateAccount__Assembler struct {
	w     *_StateAccount
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                schema.Maybe
	ca_Nonce          _Uint__Assembler
	ca_Balance        _Balance__Assembler
	ca_StorageRootCID _Link__Assembler
	ca_CodeCID        _Link__Assembler
}

func (na *_StateAccount__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Nonce.reset()
	na.ca_Balance.reset()
	na.ca_StorageRootCID.reset()
	na.ca_CodeCID.reset()
}

var (
	fieldBit__StateAccount_Nonce          = 1 << 0
	fieldBit__StateAccount_Balance        = 1 << 1
	fieldBit__StateAccount_StorageRootCID = 1 << 2
	fieldBit__StateAccount_CodeCID        = 1 << 3
	fieldBits__StateAccount_sufficient    = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_StateAccount__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StateAccount{}
	}
	return na, nil
}
func (_StateAccount__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.StateAccount"}.BeginList(0)
}
func (na *_StateAccount__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.StateAccount"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StateAccount__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignBool(false)
}
func (_StateAccount__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignInt(0)
}
func (_StateAccount__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignFloat(0)
}
func (_StateAccount__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignString("")
}
func (_StateAccount__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignBytes(nil)
}
func (_StateAccount__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.StateAccount"}.AssignLink(nil)
}
func (na *_StateAccount__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StateAccount); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.StateAccount", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StateAccount__Assembler) Prototype() ipld.NodePrototype {
	return _StateAccount__Prototype{}
}
func (ma *_StateAccount__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Balance.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StorageRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CodeCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StateAccount__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Nonce":
		if ma.s&fieldBit__StateAccount_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Nonce}
		}
		ma.s += fieldBit__StateAccount_Nonce
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "Balance":
		if ma.s&fieldBit__StateAccount_Balance != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Balance}
		}
		ma.s += fieldBit__StateAccount_Balance
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance, nil
	case "StorageRootCID":
		if ma.s&fieldBit__StateAccount_StorageRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_StorageRootCID}
		}
		ma.s += fieldBit__StateAccount_StorageRootCID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID, nil
	case "CodeCID":
		if ma.s&fieldBit__StateAccount_CodeCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_CodeCID}
		}
		ma.s += fieldBit__StateAccount_CodeCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.StateAccount", Key: &_String{k}}
}
func (ma *_StateAccount__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StateAccount__KeyAssembler)(ma)
}
func (ma *_StateAccount__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 1:
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance
	case 2:
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID
	case 3:
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID
	default:
		panic("unreachable")
	}
}
func (ma *_StateAccount__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__StateAccount_sufficient != fieldBits__StateAccount_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__StateAccount_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		if ma.s&fieldBit__StateAccount_Balance == 0 {
			err.Missing = append(err.Missing, "Balance")
		}
		if ma.s&fieldBit__StateAccount_StorageRootCID == 0 {
			err.Missing = append(err.Missing, "StorageRootCID")
		}
		if ma.s&fieldBit__StateAccount_CodeCID == 0 {
			err.Missing = append(err.Missing, "CodeCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StateAccount__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StateAccount__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _StateAccount__KeyAssembler _StateAccount__Assembler

func (_StateAccount__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.BeginMap(0)
}
func (_StateAccount__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.BeginList(0)
}
func (na *_StateAccount__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignNull()
}
func (_StateAccount__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignBool(false)
}
func (_StateAccount__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignInt(0)
}
func (_StateAccount__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StateAccount__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Nonce":
		if ka.s&fieldBit__StateAccount_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Nonce}
		}
		ka.s += fieldBit__StateAccount_Nonce
		ka.state = maState_expectValue
		ka.f = 0
	case "Balance":
		if ka.s&fieldBit__StateAccount_Balance != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Balance}
		}
		ka.s += fieldBit__StateAccount_Balance
		ka.state = maState_expectValue
		ka.f = 1
	case "StorageRootCID":
		if ka.s&fieldBit__StateAccount_StorageRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_StorageRootCID}
		}
		ka.s += fieldBit__StateAccount_StorageRootCID
		ka.state = maState_expectValue
		ka.f = 2
	case "CodeCID":
		if ka.s&fieldBit__StateAccount_CodeCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_CodeCID}
		}
		ka.s += fieldBit__StateAccount_CodeCID
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.StateAccount", Key: &_String{k}}
	}
	return nil
}
func (_StateAccount__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignBytes(nil)
}
func (_StateAccount__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.StateAccount.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StateAccount__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StateAccount__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StateAccount) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StateAccount) Representation() ipld.Node {
	return (*_StateAccount__Repr)(n)
}

type _StateAccount__Repr _StateAccount

var (
	fieldName__StateAccount_Nonce_serial          = _String{"Nonce"}
	fieldName__StateAccount_Balance_serial        = _String{"Balance"}
	fieldName__StateAccount_StorageRootCID_serial = _String{"StorageRootCID"}
	fieldName__StateAccount_CodeCID_serial        = _String{"CodeCID"}
)
var _ ipld.Node = &_StateAccount__Repr{}

func (_StateAccount__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_StateAccount__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Nonce":
		return n.Nonce.Representation(), nil
	case "Balance":
		return n.Balance.Representation(), nil
	case "StorageRootCID":
		return n.StorageRootCID.Representation(), nil
	case "CodeCID":
		return n.CodeCID.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StateAccount__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StateAccount__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.LookupByIndex(0)
}
func (n _StateAccount__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StateAccount__Repr) MapIterator() ipld.MapIterator {
	return &_StateAccount__ReprMapItr{n, 0}
}

type _StateAccount__ReprMapItr struct {
	n   *_StateAccount__Repr
	idx int
}

func (itr *_StateAccount__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StateAccount_Nonce_serial
		v = itr.n.Nonce.Representation()
	case 1:
		k = &fieldName__StateAccount_Balance_serial
		v = itr.n.Balance.Representation()
	case 2:
		k = &fieldName__StateAccount_StorageRootCID_serial
		v = itr.n.StorageRootCID.Representation()
	case 3:
		k = &fieldName__StateAccount_CodeCID_serial
		v = itr.n.CodeCID.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StateAccount__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_StateAccount__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StateAccount__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_StateAccount__Repr) IsAbsent() bool {
	return false
}
func (_StateAccount__Repr) IsNull() bool {
	return false
}
func (_StateAccount__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsBool()
}
func (_StateAccount__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsInt()
}
func (_StateAccount__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsFloat()
}
func (_StateAccount__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsString()
}
func (_StateAccount__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsBytes()
}
func (_StateAccount__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.StateAccount.Repr"}.AsLink()
}
func (_StateAccount__Repr) Prototype() ipld.NodePrototype {
	return _StateAccount__ReprPrototype{}
}

type _StateAccount__ReprPrototype struct{}

func (_StateAccount__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StateAccount__ReprBuilder
	nb.Reset()
	return &nb
}

type _StateAccount__ReprBuilder struct {
	_StateAccount__ReprAssembler
}

func (nb *_StateAccount__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StateAccount__ReprBuilder) Reset() {
	var w _StateAccount
	var m schema.Maybe
	*nb = _StateAccount__ReprBuilder{_StateAccount__ReprAssembler{w: &w, m: &m}}
}

type _StateAccount__ReprAssembler struct {
	w     *_StateAccount
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                schema.Maybe
	ca_Nonce          _Uint__ReprAssembler
	ca_Balance        _Balance__ReprAssembler
	ca_StorageRootCID _Link__ReprAssembler
	ca_CodeCID        _Link__ReprAssembler
}

func (na *_StateAccount__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Nonce.reset()
	na.ca_Balance.reset()
	na.ca_StorageRootCID.reset()
	na.ca_CodeCID.reset()
}
func (na *_StateAccount__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StateAccount{}
	}
	return na, nil
}
func (_StateAccount__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.BeginList(0)
}
func (na *_StateAccount__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.StateAccount.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StateAccount__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignBool(false)
}
func (_StateAccount__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignInt(0)
}
func (_StateAccount__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignFloat(0)
}
func (_StateAccount__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignString("")
}
func (_StateAccount__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignBytes(nil)
}
func (_StateAccount__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.StateAccount.Repr"}.AssignLink(nil)
}
func (na *_StateAccount__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StateAccount); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.StateAccount.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StateAccount__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StateAccount__ReprPrototype{}
}
func (ma *_StateAccount__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StateAccount__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Nonce":
		if ma.s&fieldBit__StateAccount_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Nonce_serial}
		}
		ma.s += fieldBit__StateAccount_Nonce
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "Balance":
		if ma.s&fieldBit__StateAccount_Balance != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Balance_serial}
		}
		ma.s += fieldBit__StateAccount_Balance
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance, nil
	case "StorageRootCID":
		if ma.s&fieldBit__StateAccount_StorageRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_StorageRootCID_serial}
		}
		ma.s += fieldBit__StateAccount_StorageRootCID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID, nil
	case "CodeCID":
		if ma.s&fieldBit__StateAccount_CodeCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_CodeCID_serial}
		}
		ma.s += fieldBit__StateAccount_CodeCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.StateAccount.Repr", Key: &_String{k}}
}
func (ma *_StateAccount__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StateAccount__ReprKeyAssembler)(ma)
}
func (ma *_StateAccount__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 1:
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance
	case 2:
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID
	case 3:
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID
	default:
		panic("unreachable")
	}
}
func (ma *_StateAccount__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__StateAccount_sufficient != fieldBits__StateAccount_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__StateAccount_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		if ma.s&fieldBit__StateAccount_Balance == 0 {
			err.Missing = append(err.Missing, "Balance")
		}
		if ma.s&fieldBit__StateAccount_StorageRootCID == 0 {
			err.Missing = append(err.Missing, "StorageRootCID")
		}
		if ma.s&fieldBit__StateAccount_CodeCID == 0 {
			err.Missing = append(err.Missing, "CodeCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StateAccount__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StateAccount__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _StateAccount__ReprKeyAssembler _StateAccount__ReprAssembler

func (_StateAccount__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StateAccount__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StateAccount__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignNull()
}
func (_StateAccount__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StateAccount__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StateAccount__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StateAccount__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Nonce":
		if ka.s&fieldBit__StateAccount_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Nonce_serial}
		}
		ka.s += fieldBit__StateAccount_Nonce
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Balance":
		if ka.s&fieldBit__StateAccount_Balance != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_Balance_serial}
		}
		ka.s += fieldBit__StateAccount_Balance
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "StorageRootCID":
		if ka.s&fieldBit__StateAccount_StorageRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_StorageRootCID_serial}
		}
		ka.s += fieldBit__StateAccount_StorageRootCID
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "CodeCID":
		if ka.s&fieldBit__StateAccount_CodeCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__StateAccount_CodeCID_serial}
		}
		ka.s += fieldBit__StateAccount_CodeCID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.StateAccount.Repr", Key: &_String{k}}
}
func (_StateAccount__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StateAccount__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.StateAccount.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StateAccount__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StateAccount__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_StorageKeys) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_StorageKeys) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _StorageKeys__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n StorageKeys) Iterator() *StorageKeys__Itr {
	return &StorageKeys__Itr{n, 0}
}

type StorageKeys__Itr struct {
	n   StorageKeys
	idx int
}

func (itr *StorageKeys__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *StorageKeys__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _StorageKeys__Maybe struct {
	m schema.Maybe
	v StorageKeys
}
type MaybeStorageKeys = *_StorageKeys__Maybe

func (m MaybeStorageKeys) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStorageKeys) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStorageKeys) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStorageKeys) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeStorageKeys) Must() StorageKeys {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (StorageKeys)(&_StorageKeys{})
var _ schema.TypedNode = (StorageKeys)(&_StorageKeys{})

func (StorageKeys) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (StorageKeys) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.StorageKeys"}.LookupByString("")
}
func (n StorageKeys) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n StorageKeys) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n StorageKeys) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.StorageKeys", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (StorageKeys) MapIterator() ipld.MapIterator {
	return nil
}
func (n StorageKeys) ListIterator() ipld.ListIterator {
	return &_StorageKeys__ListItr{n, 0}
}

type _StorageKeys__ListItr struct {
	n   StorageKeys
	idx int
}

func (itr *_StorageKeys__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_StorageKeys__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n StorageKeys) Length() int64 {
	return int64(len(n.x))
}
func (StorageKeys) IsAbsent() bool {
	return false
}
func (StorageKeys) IsNull() bool {
	return false
}
func (StorageKeys) AsBool() (bool, error) {
	return mixins.List{"dageth.StorageKeys"}.AsBool()
}
func (StorageKeys) AsInt() (int64, error) {
	return mixins.List{"dageth.StorageKeys"}.AsInt()
}
func (StorageKeys) AsFloat() (float64, error) {
	return mixins.List{"dageth.StorageKeys"}.AsFloat()
}
func (StorageKeys) AsString() (string, error) {
	return mixins.List{"dageth.StorageKeys"}.AsString()
}
func (StorageKeys) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.StorageKeys"}.AsBytes()
}
func (StorageKeys) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.StorageKeys"}.AsLink()
}
func (StorageKeys) Prototype() ipld.NodePrototype {
	return _StorageKeys__Prototype{}
}

type _StorageKeys__Prototype struct{}

func (_StorageKeys__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageKeys__Builder
	nb.Reset()
	return &nb
}

type _StorageKeys__Builder struct {
	_StorageKeys__Assembler
}

func (nb *_StorageKeys__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageKeys__Builder) Reset() {
	var w _StorageKeys
	var m schema.Maybe
	*nb = _StorageKeys__Builder{_StorageKeys__Assembler{w: &w, m: &m}}
}

type _StorageKeys__Assembler struct {
	w     *_StorageKeys
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_StorageKeys__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_StorageKeys__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.StorageKeys"}.BeginMap(0)
}
func (na *_StorageKeys__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_StorageKeys{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_StorageKeys__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.StorageKeys"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageKeys__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignBool(false)
}
func (_StorageKeys__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignInt(0)
}
func (_StorageKeys__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignFloat(0)
}
func (_StorageKeys__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignString("")
}
func (_StorageKeys__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignBytes(nil)
}
func (_StorageKeys__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.StorageKeys"}.AssignLink(nil)
}
func (na *_StorageKeys__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageKeys); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.StorageKeys", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageKeys__Assembler) Prototype() ipld.NodePrototype {
	return _StorageKeys__Prototype{}
}
func (la *_StorageKeys__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_StorageKeys__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_StorageKeys__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_StorageKeys__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (StorageKeys) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StorageKeys) Representation() ipld.Node {
	return (*_StorageKeys__Repr)(n)
}

type _StorageKeys__Repr _StorageKeys

var _ ipld.Node = &_StorageKeys__Repr{}

func (_StorageKeys__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_StorageKeys__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.LookupByString("")
}
func (nr *_StorageKeys__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (StorageKeys)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_StorageKeys__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (StorageKeys)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _StorageKeys__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.StorageKeys.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_StorageKeys__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_StorageKeys__Repr) ListIterator() ipld.ListIterator {
	return &_StorageKeys__ReprListItr{(StorageKeys)(nr), 0}
}

type _StorageKeys__ReprListItr _StorageKeys__ListItr

func (itr *_StorageKeys__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_StorageKeys__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_StorageKeys__ReprListItr) Done() bool {
	return (*_StorageKeys__ListItr)(itr).Done()
}

func (rn *_StorageKeys__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_StorageKeys__Repr) IsAbsent() bool {
	return false
}
func (_StorageKeys__Repr) IsNull() bool {
	return false
}
func (_StorageKeys__Repr) AsBool() (bool, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsBool()
}
func (_StorageKeys__Repr) AsInt() (int64, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsInt()
}
func (_StorageKeys__Repr) AsFloat() (float64, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsFloat()
}
func (_StorageKeys__Repr) AsString() (string, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsString()
}
func (_StorageKeys__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsBytes()
}
func (_StorageKeys__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.StorageKeys.Repr"}.AsLink()
}
func (_StorageKeys__Repr) Prototype() ipld.NodePrototype {
	return _StorageKeys__ReprPrototype{}
}

type _StorageKeys__ReprPrototype struct{}

func (_StorageKeys__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageKeys__ReprBuilder
	nb.Reset()
	return &nb
}

type _StorageKeys__ReprBuilder struct {
	_StorageKeys__ReprAssembler
}

func (nb *_StorageKeys__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageKeys__ReprBuilder) Reset() {
	var w _StorageKeys
	var m schema.Maybe
	*nb = _StorageKeys__ReprBuilder{_StorageKeys__ReprAssembler{w: &w, m: &m}}
}

type _StorageKeys__ReprAssembler struct {
	w     *_StorageKeys
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_StorageKeys__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_StorageKeys__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.BeginMap(0)
}
func (na *_StorageKeys__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_StorageKeys{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_StorageKeys__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.StorageKeys.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageKeys__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignBool(false)
}
func (_StorageKeys__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignInt(0)
}
func (_StorageKeys__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignFloat(0)
}
func (_StorageKeys__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignString("")
}
func (_StorageKeys__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignBytes(nil)
}
func (_StorageKeys__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.StorageKeys.Repr"}.AssignLink(nil)
}
func (na *_StorageKeys__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageKeys); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.StorageKeys.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageKeys__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StorageKeys__ReprPrototype{}
}
func (la *_StorageKeys__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_StorageKeys__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_StorageKeys__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_StorageKeys__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}

type _String__Maybe struct {
	m schema.Maybe
	v String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})

func (String) Kind() ipld.Kind {
	return ipld.Kind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"dageth.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"dageth.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.String{"dageth.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"dageth.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int64 {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{"dageth.String"}.AsBool()
}
func (String) AsInt() (int64, error) {
	return mixins.String{"dageth.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{"dageth.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{"dageth.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{"dageth.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}

type _String__Builder struct {
	_String__Assembler
}

func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}

type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"dageth.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_String{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}

type _String__Repr = _String

var _ ipld.Node = &_String__Repr{}

type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler

func (n Time) Bytes() []byte {
	return n.x
}
func (_Time__Prototype) FromBytes(v []byte) (Time, error) {
	n := _Time{v}
	return &n, nil
}

type _Time__Maybe struct {
	m schema.Maybe
	v Time
}
type MaybeTime = *_Time__Maybe

func (m MaybeTime) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTime) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTime) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTime) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTime) Must() Time {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Time)(&_Time{})
var _ schema.TypedNode = (Time)(&_Time{})

func (Time) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Time) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Time"}.LookupByString("")
}
func (Time) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Time"}.LookupByNode(nil)
}
func (Time) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Time"}.LookupByIndex(0)
}
func (Time) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Time"}.LookupBySegment(seg)
}
func (Time) MapIterator() ipld.MapIterator {
	return nil
}
func (Time) ListIterator() ipld.ListIterator {
	return nil
}
func (Time) Length() int64 {
	return -1
}
func (Time) IsAbsent() bool {
	return false
}
func (Time) IsNull() bool {
	return false
}
func (Time) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Time"}.AsBool()
}
func (Time) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Time"}.AsInt()
}
func (Time) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Time"}.AsFloat()
}
func (Time) AsString() (string, error) {
	return mixins.Bytes{"dageth.Time"}.AsString()
}
func (n Time) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Time) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Time"}.AsLink()
}
func (Time) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}

type _Time__Prototype struct{}

func (_Time__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__Builder
	nb.Reset()
	return &nb
}

type _Time__Builder struct {
	_Time__Assembler
}

func (nb *_Time__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__Builder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__Builder{_Time__Assembler{w: &w, m: &m}}
}

type _Time__Assembler struct {
	w *_Time
	m *schema.Maybe
}

func (na *_Time__Assembler) reset() {}
func (_Time__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Time"}.BeginMap(0)
}
func (_Time__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Time"}.BeginList(0)
}
func (na *_Time__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Time"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Time__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Time"}.AssignBool(false)
}
func (_Time__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Time"}.AssignInt(0)
}
func (_Time__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Time"}.AssignFloat(0)
}
func (_Time__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Time"}.AssignString("")
}
func (na *_Time__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Time{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Time__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Time"}.AssignLink(nil)
}
func (na *_Time__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Time__Assembler) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
func (Time) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Time) Representation() ipld.Node {
	return (*_Time__Repr)(n)
}

type _Time__Repr = _Time

var _ ipld.Node = &_Time__Repr{}

type _Time__ReprPrototype = _Time__Prototype
type _Time__ReprAssembler = _Time__Assembler

func (n *_Topics) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Topics) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Topics__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n Topics) Iterator() *Topics__Itr {
	return &Topics__Itr{n, 0}
}

type Topics__Itr struct {
	n   Topics
	idx int
}

func (itr *Topics__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Topics__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Topics__Maybe struct {
	m schema.Maybe
	v Topics
}
type MaybeTopics = *_Topics__Maybe

func (m MaybeTopics) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTopics) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTopics) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTopics) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTopics) Must() Topics {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Topics)(&_Topics{})
var _ schema.TypedNode = (Topics)(&_Topics{})

func (Topics) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Topics) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Topics"}.LookupByString("")
}
func (n Topics) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Topics) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Topics) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Topics", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Topics) MapIterator() ipld.MapIterator {
	return nil
}
func (n Topics) ListIterator() ipld.ListIterator {
	return &_Topics__ListItr{n, 0}
}

type _Topics__ListItr struct {
	n   Topics
	idx int
}

func (itr *_Topics__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Topics__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Topics) Length() int64 {
	return int64(len(n.x))
}
func (Topics) IsAbsent() bool {
	return false
}
func (Topics) IsNull() bool {
	return false
}
func (Topics) AsBool() (bool, error) {
	return mixins.List{"dageth.Topics"}.AsBool()
}
func (Topics) AsInt() (int64, error) {
	return mixins.List{"dageth.Topics"}.AsInt()
}
func (Topics) AsFloat() (float64, error) {
	return mixins.List{"dageth.Topics"}.AsFloat()
}
func (Topics) AsString() (string, error) {
	return mixins.List{"dageth.Topics"}.AsString()
}
func (Topics) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Topics"}.AsBytes()
}
func (Topics) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Topics"}.AsLink()
}
func (Topics) Prototype() ipld.NodePrototype {
	return _Topics__Prototype{}
}

type _Topics__Prototype struct{}

func (_Topics__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Topics__Builder
	nb.Reset()
	return &nb
}

type _Topics__Builder struct {
	_Topics__Assembler
}

func (nb *_Topics__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Topics__Builder) Reset() {
	var w _Topics
	var m schema.Maybe
	*nb = _Topics__Builder{_Topics__Assembler{w: &w, m: &m}}
}

type _Topics__Assembler struct {
	w     *_Topics
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_Topics__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Topics__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Topics"}.BeginMap(0)
}
func (na *_Topics__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Topics{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Topics__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Topics"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Topics__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignBool(false)
}
func (_Topics__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignInt(0)
}
func (_Topics__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignFloat(0)
}
func (_Topics__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignString("")
}
func (_Topics__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignBytes(nil)
}
func (_Topics__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Topics"}.AssignLink(nil)
}
func (na *_Topics__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Topics); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Topics", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Topics__Assembler) Prototype() ipld.NodePrototype {
	return _Topics__Prototype{}
}
func (la *_Topics__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Topics__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Topics__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Topics__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Topics) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Topics) Representation() ipld.Node {
	return (*_Topics__Repr)(n)
}

type _Topics__Repr _Topics

var _ ipld.Node = &_Topics__Repr{}

func (_Topics__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Topics__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Topics.Repr"}.LookupByString("")
}
func (nr *_Topics__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Topics)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_Topics__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Topics)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _Topics__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Topics.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Topics__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Topics__Repr) ListIterator() ipld.ListIterator {
	return &_Topics__ReprListItr{(Topics)(nr), 0}
}

type _Topics__ReprListItr _Topics__ListItr

func (itr *_Topics__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Topics__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_Topics__ReprListItr) Done() bool {
	return (*_Topics__ListItr)(itr).Done()
}

func (rn *_Topics__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Topics__Repr) IsAbsent() bool {
	return false
}
func (_Topics__Repr) IsNull() bool {
	return false
}
func (_Topics__Repr) AsBool() (bool, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsBool()
}
func (_Topics__Repr) AsInt() (int64, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsInt()
}
func (_Topics__Repr) AsFloat() (float64, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsFloat()
}
func (_Topics__Repr) AsString() (string, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsString()
}
func (_Topics__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsBytes()
}
func (_Topics__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Topics.Repr"}.AsLink()
}
func (_Topics__Repr) Prototype() ipld.NodePrototype {
	return _Topics__ReprPrototype{}
}

type _Topics__ReprPrototype struct{}

func (_Topics__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Topics__ReprBuilder
	nb.Reset()
	return &nb
}

type _Topics__ReprBuilder struct {
	_Topics__ReprAssembler
}

func (nb *_Topics__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Topics__ReprBuilder) Reset() {
	var w _Topics
	var m schema.Maybe
	*nb = _Topics__ReprBuilder{_Topics__ReprAssembler{w: &w, m: &m}}
}

type _Topics__ReprAssembler struct {
	w     *_Topics
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_Topics__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Topics__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.BeginMap(0)
}
func (na *_Topics__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Topics{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Topics__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Topics.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Topics__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignBool(false)
}
func (_Topics__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignInt(0)
}
func (_Topics__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignFloat(0)
}
func (_Topics__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignString("")
}
func (_Topics__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignBytes(nil)
}
func (_Topics__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Topics.Repr"}.AssignLink(nil)
}
func (na *_Topics__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Topics); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Topics.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Topics__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Topics__ReprPrototype{}
}
func (la *_Topics__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Topics__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Topics__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Topics__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n _Transaction) FieldChainID() MaybeBigInt {
	return &n.ChainID
}
func (n _Transaction) FieldAccountNonce() Uint {
	return &n.AccountNonce
}
func (n _Transaction) FieldGasPrice() BigInt {
	return &n.GasPrice
}
func (n _Transaction) FieldGasLimit() Uint {
	return &n.GasLimit
}
func (n _Transaction) FieldRecipient() MaybeAddress {
	return &n.Recipient
}
func (n _Transaction) FieldAmount() BigInt {
	return &n.Amount
}
func (n _Transaction) FieldData() Bytes {
	return &n.Data
}
func (n _Transaction) FieldAccessList() MaybeAccessList {
	return &n.AccessList
}
func (n _Transaction) FieldV() BigInt {
	return &n.V
}
func (n _Transaction) FieldR() BigInt {
	return &n.R
}
func (n _Transaction) FieldS() BigInt {
	return &n.S
}

type _Transaction__Maybe struct {
	m schema.Maybe
	v Transaction
}
type MaybeTransaction = *_Transaction__Maybe

func (m MaybeTransaction) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTransaction) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTransaction) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTransaction) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTransaction) Must() Transaction {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Transaction_ChainID      = _String{"ChainID"}
	fieldName__Transaction_AccountNonce = _String{"AccountNonce"}
	fieldName__Transaction_GasPrice     = _String{"GasPrice"}
	fieldName__Transaction_GasLimit     = _String{"GasLimit"}
	fieldName__Transaction_Recipient    = _String{"Recipient"}
	fieldName__Transaction_Amount       = _String{"Amount"}
	fieldName__Transaction_Data         = _String{"Data"}
	fieldName__Transaction_AccessList   = _String{"AccessList"}
	fieldName__Transaction_V            = _String{"V"}
	fieldName__Transaction_R            = _String{"R"}
	fieldName__Transaction_S            = _String{"S"}
)
var _ ipld.Node = (Transaction)(&_Transaction{})
var _ schema.TypedNode = (Transaction)(&_Transaction{})

func (Transaction) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Transaction) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ChainID":
		if n.ChainID.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChainID.v, nil
	case "AccountNonce":
		return &n.AccountNonce, nil
	case "GasPrice":
		return &n.GasPrice, nil
	case "GasLimit":
		return &n.GasLimit, nil
	case "Recipient":
		if n.Recipient.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Recipient.v, nil
	case "Amount":
		return &n.Amount, nil
	case "Data":
		return &n.Data, nil
	case "AccessList":
		if n.AccessList.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.AccessList.v, nil
	case "V":
		return &n.V, nil
	case "R":
		return &n.R, nil
	case "S":
		return &n.S, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Transaction) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Transaction) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Transaction"}.LookupByIndex(0)
}
func (n Transaction) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Transaction) MapIterator() ipld.MapIterator {
	return &_Transaction__MapItr{n, 0}
}

type _Transaction__MapItr struct {
	n   Transaction
	idx int
}

func (itr *_Transaction__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 11 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Transaction_ChainID
		if itr.n.ChainID.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChainID.v
	case 1:
		k = &fieldName__Transaction_AccountNonce
		v = &itr.n.AccountNonce
	case 2:
		k = &fieldName__Transaction_GasPrice
		v = &itr.n.GasPrice
	case 3:
		k = &fieldName__Transaction_GasLimit
		v = &itr.n.GasLimit
	case 4:
		k = &fieldName__Transaction_Recipient
		if itr.n.Recipient.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Recipient.v
	case 5:
		k = &fieldName__Transaction_Amount
		v = &itr.n.Amount
	case 6:
		k = &fieldName__Transaction_Data
		v = &itr.n.Data
	case 7:
		k = &fieldName__Transaction_AccessList
		if itr.n.AccessList.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.AccessList.v
	case 8:
		k = &fieldName__Transaction_V
		v = &itr.n.V
	case 9:
		k = &fieldName__Transaction_R
		v = &itr.n.R
	case 10:
		k = &fieldName__Transaction_S
		v = &itr.n.S
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Transaction__MapItr) Done() bool {
	return itr.idx >= 11
}

func (Transaction) ListIterator() ipld.ListIterator {
	return nil
}
func (Transaction) Length() int64 {
	return 11
}
func (Transaction) IsAbsent() bool {
	return false
}
func (Transaction) IsNull() bool {
	return false
}
func (Transaction) AsBool() (bool, error) {
	return mixins.Map{"dageth.Transaction"}.AsBool()
}
func (Transaction) AsInt() (int64, error) {
	return mixins.Map{"dageth.Transaction"}.AsInt()
}
func (Transaction) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Transaction"}.AsFloat()
}
func (Transaction) AsString() (string, error) {
	return mixins.Map{"dageth.Transaction"}.AsString()
}
func (Transaction) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Transaction"}.AsBytes()
}
func (Transaction) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Transaction"}.AsLink()
}
func (Transaction) Prototype() ipld.NodePrototype {
	return _Transaction__Prototype{}
}

type _Transaction__Prototype struct{}

func (_Transaction__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transaction__Builder
	nb.Reset()
	return &nb
}

type _Transaction__Builder struct {
	_Transaction__Assembler
}

func (nb *_Transaction__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transaction__Builder) Reset() {
	var w _Transaction
	var m schema.Maybe
	*nb = _Transaction__Builder{_Transaction__Assembler{w: &w, m: &m}}
}

type _Transaction__Assembler struct {
	w     *_Transaction
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ChainID      _BigInt__Assembler
	ca_AccountNonce _Uint__Assembler
	ca_GasPrice     _BigInt__Assembler
	ca_GasLimit     _Uint__Assembler
	ca_Recipient    _Address__Assembler
	ca_Amount       _BigInt__Assembler
	ca_Data         _Bytes__Assembler
	ca_AccessList   _AccessList__Assembler
	ca_V            _BigInt__Assembler
	ca_R            _BigInt__Assembler
	ca_S            _BigInt__Assembler
}

func (na *_Transaction__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ChainID.reset()
	na.ca_AccountNonce.reset()
	na.ca_GasPrice.reset()
	na.ca_GasLimit.reset()
	na.ca_Recipient.reset()
	na.ca_Amount.reset()
	na.ca_Data.reset()
	na.ca_AccessList.reset()
	na.ca_V.reset()
	na.ca_R.reset()
	na.ca_S.reset()
}

var (
	fieldBit__Transaction_ChainID      = 1 << 0
	fieldBit__Transaction_AccountNonce = 1 << 1
	fieldBit__Transaction_GasPrice     = 1 << 2
	fieldBit__Transaction_GasLimit     = 1 << 3
	fieldBit__Transaction_Recipient    = 1 << 4
	fieldBit__Transaction_Amount       = 1 << 5
	fieldBit__Transaction_Data         = 1 << 6
	fieldBit__Transaction_AccessList   = 1 << 7
	fieldBit__Transaction_V            = 1 << 8
	fieldBit__Transaction_R            = 1 << 9
	fieldBit__Transaction_S            = 1 << 10
	fieldBits__Transaction_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10
)

func (na *_Transaction__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Transaction{}
	}
	return na, nil
}
func (_Transaction__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Transaction"}.BeginList(0)
}
func (na *_Transaction__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Transaction"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transaction__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignBool(false)
}
func (_Transaction__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignInt(0)
}
func (_Transaction__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignFloat(0)
}
func (_Transaction__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignString("")
}
func (_Transaction__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignBytes(nil)
}
func (_Transaction__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Transaction"}.AssignLink(nil)
}
func (na *_Transaction__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transaction); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Transaction", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transaction__Assembler) Prototype() ipld.NodePrototype {
	return _Transaction__Prototype{}
}
func (ma *_Transaction__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.ChainID.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChainID.v = ma.ca_ChainID.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_AccountNonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasPrice.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasLimit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Recipient.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Recipient.v = ma.ca_Recipient.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Amount.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.AccessList.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.AccessList.v = ma.ca_AccessList.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_V.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_R.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_S.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ChainID":
		if ma.s&fieldBit__Transaction_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID}
		}
		ma.s += fieldBit__Transaction_ChainID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ChainID.w = ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID, nil
	case "AccountNonce":
		if ma.s&fieldBit__Transaction_AccountNonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce}
		}
		ma.s += fieldBit__Transaction_AccountNonce
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce, nil
	case "GasPrice":
		if ma.s&fieldBit__Transaction_GasPrice != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice}
		}
		ma.s += fieldBit__Transaction_GasPrice
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_GasPrice.w = &ma.w.GasPrice
		ma.ca_GasPrice.m = &ma.cm
		return &ma.ca_GasPrice, nil
	case "GasLimit":
		if ma.s&fieldBit__Transaction_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit}
		}
		ma.s += fieldBit__Transaction_GasLimit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "Recipient":
		if ma.s&fieldBit__Transaction_Recipient != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient}
		}
		ma.s += fieldBit__Transaction_Recipient
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Recipient.w = ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient, nil
	case "Amount":
		if ma.s&fieldBit__Transaction_Amount != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount}
		}
		ma.s += fieldBit__Transaction_Amount
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount, nil
	case "Data":
		if ma.s&fieldBit__Transaction_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data}
		}
		ma.s += fieldBit__Transaction_Data
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "AccessList":
		if ma.s&fieldBit__Transaction_AccessList != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList}
		}
		ma.s += fieldBit__Transaction_AccessList
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_AccessList.w = ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList, nil
	case "V":
		if ma.s&fieldBit__Transaction_V != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V}
		}
		ma.s += fieldBit__Transaction_V
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V, nil
	case "R":
		if ma.s&fieldBit__Transaction_R != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R}
		}
		ma.s += fieldBit__Transaction_R
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R, nil
	case "S":
		if ma.s&fieldBit__Transaction_S != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S}
		}
		ma.s += fieldBit__Transaction_S
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Transaction", Key: &_String{k}}
}
func (ma *_Transaction__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Transaction__KeyAssembler)(ma)
}
func (ma *_Transaction__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ChainID.w = ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID
	case 1:
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce
	case 2:
		ma.ca_GasPrice.w = &ma.w.GasPrice
		ma.ca_GasPrice.m = &ma.cm
		return &ma.ca_GasPrice
	case 3:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 4:
		ma.ca_Recipient.w = ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient
	case 5:
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount
	case 6:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 7:
		ma.ca_AccessList.w = ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList
	case 8:
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V
	case 9:
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R
	case 10:
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Transaction_sufficient != fieldBits__Transaction_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Transaction_AccountNonce == 0 {
			err.Missing = append(err.Missing, "AccountNonce")
		}
		if ma.s&fieldBit__Transaction_GasPrice == 0 {
			err.Missing = append(err.Missing, "GasPrice")
		}
		if ma.s&fieldBit__Transaction_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Transaction_Amount == 0 {
			err.Missing = append(err.Missing, "Amount")
		}
		if ma.s&fieldBit__Transaction_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Transaction_V == 0 {
			err.Missing = append(err.Missing, "V")
		}
		if ma.s&fieldBit__Transaction_R == 0 {
			err.Missing = append(err.Missing, "R")
		}
		if ma.s&fieldBit__Transaction_S == 0 {
			err.Missing = append(err.Missing, "S")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Transaction__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Transaction__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Transaction__KeyAssembler _Transaction__Assembler

func (_Transaction__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.BeginMap(0)
}
func (_Transaction__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.BeginList(0)
}
func (na *_Transaction__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignNull()
}
func (_Transaction__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignBool(false)
}
func (_Transaction__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignInt(0)
}
func (_Transaction__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Transaction__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ChainID":
		if ka.s&fieldBit__Transaction_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID}
		}
		ka.s += fieldBit__Transaction_ChainID
		ka.state = maState_expectValue
		ka.f = 0
	case "AccountNonce":
		if ka.s&fieldBit__Transaction_AccountNonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce}
		}
		ka.s += fieldBit__Transaction_AccountNonce
		ka.state = maState_expectValue
		ka.f = 1
	case "GasPrice":
		if ka.s&fieldBit__Transaction_GasPrice != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice}
		}
		ka.s += fieldBit__Transaction_GasPrice
		ka.state = maState_expectValue
		ka.f = 2
	case "GasLimit":
		if ka.s&fieldBit__Transaction_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit}
		}
		ka.s += fieldBit__Transaction_GasLimit
		ka.state = maState_expectValue
		ka.f = 3
	case "Recipient":
		if ka.s&fieldBit__Transaction_Recipient != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient}
		}
		ka.s += fieldBit__Transaction_Recipient
		ka.state = maState_expectValue
		ka.f = 4
	case "Amount":
		if ka.s&fieldBit__Transaction_Amount != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount}
		}
		ka.s += fieldBit__Transaction_Amount
		ka.state = maState_expectValue
		ka.f = 5
	case "Data":
		if ka.s&fieldBit__Transaction_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data}
		}
		ka.s += fieldBit__Transaction_Data
		ka.state = maState_expectValue
		ka.f = 6
	case "AccessList":
		if ka.s&fieldBit__Transaction_AccessList != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList}
		}
		ka.s += fieldBit__Transaction_AccessList
		ka.state = maState_expectValue
		ka.f = 7
	case "V":
		if ka.s&fieldBit__Transaction_V != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V}
		}
		ka.s += fieldBit__Transaction_V
		ka.state = maState_expectValue
		ka.f = 8
	case "R":
		if ka.s&fieldBit__Transaction_R != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R}
		}
		ka.s += fieldBit__Transaction_R
		ka.state = maState_expectValue
		ka.f = 9
	case "S":
		if ka.s&fieldBit__Transaction_S != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S}
		}
		ka.s += fieldBit__Transaction_S
		ka.state = maState_expectValue
		ka.f = 10
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Transaction", Key: &_String{k}}
	}
	return nil
}
func (_Transaction__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignBytes(nil)
}
func (_Transaction__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Transaction.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Transaction__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Transaction__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Transaction) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Transaction) Representation() ipld.Node {
	return (*_Transaction__Repr)(n)
}

type _Transaction__Repr _Transaction

var (
	fieldName__Transaction_ChainID_serial      = _String{"ChainID"}
	fieldName__Transaction_AccountNonce_serial = _String{"AccountNonce"}
	fieldName__Transaction_GasPrice_serial     = _String{"GasPrice"}
	fieldName__Transaction_GasLimit_serial     = _String{"GasLimit"}
	fieldName__Transaction_Recipient_serial    = _String{"Recipient"}
	fieldName__Transaction_Amount_serial       = _String{"Amount"}
	fieldName__Transaction_Data_serial         = _String{"Data"}
	fieldName__Transaction_AccessList_serial   = _String{"AccessList"}
	fieldName__Transaction_V_serial            = _String{"V"}
	fieldName__Transaction_R_serial            = _String{"R"}
	fieldName__Transaction_S_serial            = _String{"S"}
)
var _ ipld.Node = &_Transaction__Repr{}

func (_Transaction__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Transaction__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ChainID":
		if n.ChainID.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChainID.v.Representation(), nil
	case "AccountNonce":
		return n.AccountNonce.Representation(), nil
	case "GasPrice":
		return n.GasPrice.Representation(), nil
	case "GasLimit":
		return n.GasLimit.Representation(), nil
	case "Recipient":
		if n.Recipient.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Recipient.v.Representation(), nil
	case "Amount":
		return n.Amount.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	case "AccessList":
		if n.AccessList.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.AccessList.v.Representation(), nil
	case "V":
		return n.V.Representation(), nil
	case "R":
		return n.R.Representation(), nil
	case "S":
		return n.S.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Transaction__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Transaction__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.LookupByIndex(0)
}
func (n _Transaction__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Transaction__Repr) MapIterator() ipld.MapIterator {
	return &_Transaction__ReprMapItr{n, 0}
}

type _Transaction__ReprMapItr struct {
	n   *_Transaction__Repr
	idx int
}

func (itr *_Transaction__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 11 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Transaction_ChainID_serial
		if itr.n.ChainID.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChainID.v.Representation()
	case 1:
		k = &fieldName__Transaction_AccountNonce_serial
		v = itr.n.AccountNonce.Representation()
	case 2:
		k = &fieldName__Transaction_GasPrice_serial
		v = itr.n.GasPrice.Representation()
	case 3:
		k = &fieldName__Transaction_GasLimit_serial
		v = itr.n.GasLimit.Representation()
	case 4:
		k = &fieldName__Transaction_Recipient_serial
		if itr.n.Recipient.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Recipient.v.Representation()
	case 5:
		k = &fieldName__Transaction_Amount_serial
		v = itr.n.Amount.Representation()
	case 6:
		k = &fieldName__Transaction_Data_serial
		v = itr.n.Data.Representation()
	case 7:
		k = &fieldName__Transaction_AccessList_serial
		if itr.n.AccessList.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.AccessList.v.Representation()
	case 8:
		k = &fieldName__Transaction_V_serial
		v = itr.n.V.Representation()
	case 9:
		k = &fieldName__Transaction_R_serial
		v = itr.n.R.Representation()
	case 10:
		k = &fieldName__Transaction_S_serial
		v = itr.n.S.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Transaction__ReprMapItr) Done() bool {
	return itr.idx >= 11
}
func (_Transaction__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Transaction__Repr) Length() int64 {
	l := 11
	return int64(l)
}
func (_Transaction__Repr) IsAbsent() bool {
	return false
}
func (_Transaction__Repr) IsNull() bool {
	return false
}
func (_Transaction__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsBool()
}
func (_Transaction__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsInt()
}
func (_Transaction__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsFloat()
}
func (_Transaction__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsString()
}
func (_Transaction__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsBytes()
}
func (_Transaction__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.Transaction.Repr"}.AsLink()
}
func (_Transaction__Repr) Prototype() ipld.NodePrototype {
	return _Transaction__ReprPrototype{}
}

type _Transaction__ReprPrototype struct{}

func (_Transaction__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transaction__ReprBuilder
	nb.Reset()
	return &nb
}

type _Transaction__ReprBuilder struct {
	_Transaction__ReprAssembler
}

func (nb *_Transaction__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transaction__ReprBuilder) Reset() {
	var w _Transaction
	var m schema.Maybe
	*nb = _Transaction__ReprBuilder{_Transaction__ReprAssembler{w: &w, m: &m}}
}

type _Transaction__ReprAssembler struct {
	w     *_Transaction
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ChainID      _BigInt__ReprAssembler
	ca_AccountNonce _Uint__ReprAssembler
	ca_GasPrice     _BigInt__ReprAssembler
	ca_GasLimit     _Uint__ReprAssembler
	ca_Recipient    _Address__ReprAssembler
	ca_Amount       _BigInt__ReprAssembler
	ca_Data         _Bytes__ReprAssembler
	ca_AccessList   _AccessList__ReprAssembler
	ca_V            _BigInt__ReprAssembler
	ca_R            _BigInt__ReprAssembler
	ca_S            _BigInt__ReprAssembler
}

func (na *_Transaction__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ChainID.reset()
	na.ca_AccountNonce.reset()
	na.ca_GasPrice.reset()
	na.ca_GasLimit.reset()
	na.ca_Recipient.reset()
	na.ca_Amount.reset()
	na.ca_Data.reset()
	na.ca_AccessList.reset()
	na.ca_V.reset()
	na.ca_R.reset()
	na.ca_S.reset()
}
func (na *_Transaction__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Transaction{}
	}
	return na, nil
}
func (_Transaction__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.BeginList(0)
}
func (na *_Transaction__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.Transaction.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transaction__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignBool(false)
}
func (_Transaction__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignInt(0)
}
func (_Transaction__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignFloat(0)
}
func (_Transaction__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignString("")
}
func (_Transaction__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignBytes(nil)
}
func (_Transaction__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.Transaction.Repr"}.AssignLink(nil)
}
func (na *_Transaction__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transaction); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Transaction.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transaction__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Transaction__ReprPrototype{}
}
func (ma *_Transaction__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.ChainID.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChainID.v = ma.ca_ChainID.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Recipient.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Recipient.v = ma.ca_Recipient.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.AccessList.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.AccessList.v = ma.ca_AccessList.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ChainID":
		if ma.s&fieldBit__Transaction_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID_serial}
		}
		ma.s += fieldBit__Transaction_ChainID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ChainID.w = ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID, nil
	case "AccountNonce":
		if ma.s&fieldBit__Transaction_AccountNonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce_serial}
		}
		ma.s += fieldBit__Transaction_AccountNonce
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce, nil
	case "GasPrice":
		if ma.s&fieldBit__Transaction_GasPrice != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice_serial}
		}
		ma.s += fieldBit__Transaction_GasPrice
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_GasPrice.w = &ma.w.GasPrice
		ma.ca_GasPrice.m = &ma.cm
		return &ma.ca_GasPrice, nil
	case "GasLimit":
		if ma.s&fieldBit__Transaction_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit_serial}
		}
		ma.s += fieldBit__Transaction_GasLimit
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "Recipient":
		if ma.s&fieldBit__Transaction_Recipient != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient_serial}
		}
		ma.s += fieldBit__Transaction_Recipient
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Recipient.w = ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient, nil
	case "Amount":
		if ma.s&fieldBit__Transaction_Amount != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount_serial}
		}
		ma.s += fieldBit__Transaction_Amount
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount, nil
	case "Data":
		if ma.s&fieldBit__Transaction_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data_serial}
		}
		ma.s += fieldBit__Transaction_Data
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "AccessList":
		if ma.s&fieldBit__Transaction_AccessList != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList_serial}
		}
		ma.s += fieldBit__Transaction_AccessList
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_AccessList.w = ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList, nil
	case "V":
		if ma.s&fieldBit__Transaction_V != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V_serial}
		}
		ma.s += fieldBit__Transaction_V
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V, nil
	case "R":
		if ma.s&fieldBit__Transaction_R != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R_serial}
		}
		ma.s += fieldBit__Transaction_R
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R, nil
	case "S":
		if ma.s&fieldBit__Transaction_S != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S_serial}
		}
		ma.s += fieldBit__Transaction_S
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Transaction.Repr", Key: &_String{k}}
}
func (ma *_Transaction__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Transaction__ReprKeyAssembler)(ma)
}
func (ma *_Transaction__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ChainID.w = ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID
	case 1:
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce
	case 2:
		ma.ca_GasPrice.w = &ma.w.GasPrice
		ma.ca_GasPrice.m = &ma.cm
		return &ma.ca_GasPrice
	case 3:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 4:
		ma.ca_Recipient.w = ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient
	case 5:
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount
	case 6:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 7:
		ma.ca_AccessList.w = ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList
	case 8:
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V
	case 9:
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R
	case 10:
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Transaction_sufficient != fieldBits__Transaction_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Transaction_AccountNonce == 0 {
			err.Missing = append(err.Missing, "AccountNonce")
		}
		if ma.s&fieldBit__Transaction_GasPrice == 0 {
			err.Missing = append(err.Missing, "GasPrice")
		}
		if ma.s&fieldBit__Transaction_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Transaction_Amount == 0 {
			err.Missing = append(err.Missing, "Amount")
		}
		if ma.s&fieldBit__Transaction_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Transaction_V == 0 {
			err.Missing = append(err.Missing, "V")
		}
		if ma.s&fieldBit__Transaction_R == 0 {
			err.Missing = append(err.Missing, "R")
		}
		if ma.s&fieldBit__Transaction_S == 0 {
			err.Missing = append(err.Missing, "S")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Transaction__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Transaction__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Transaction__ReprKeyAssembler _Transaction__ReprAssembler

func (_Transaction__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Transaction__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Transaction__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignNull()
}
func (_Transaction__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Transaction__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Transaction__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Transaction__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ChainID":
		if ka.s&fieldBit__Transaction_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID_serial}
		}
		ka.s += fieldBit__Transaction_ChainID
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "AccountNonce":
		if ka.s&fieldBit__Transaction_AccountNonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce_serial}
		}
		ka.s += fieldBit__Transaction_AccountNonce
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "GasPrice":
		if ka.s&fieldBit__Transaction_GasPrice != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice_serial}
		}
		ka.s += fieldBit__Transaction_GasPrice
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "GasLimit":
		if ka.s&fieldBit__Transaction_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit_serial}
		}
		ka.s += fieldBit__Transaction_GasLimit
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Recipient":
		if ka.s&fieldBit__Transaction_Recipient != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient_serial}
		}
		ka.s += fieldBit__Transaction_Recipient
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Amount":
		if ka.s&fieldBit__Transaction_Amount != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount_serial}
		}
		ka.s += fieldBit__Transaction_Amount
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Data":
		if ka.s&fieldBit__Transaction_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data_serial}
		}
		ka.s += fieldBit__Transaction_Data
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "AccessList":
		if ka.s&fieldBit__Transaction_AccessList != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList_serial}
		}
		ka.s += fieldBit__Transaction_AccessList
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "V":
		if ka.s&fieldBit__Transaction_V != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V_serial}
		}
		ka.s += fieldBit__Transaction_V
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "R":
		if ka.s&fieldBit__Transaction_R != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R_serial}
		}
		ka.s += fieldBit__Transaction_R
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "S":
		if ka.s&fieldBit__Transaction_S != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S_serial}
		}
		ka.s += fieldBit__Transaction_S
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Transaction.Repr", Key: &_String{k}}
}
func (_Transaction__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Transaction__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.Transaction.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Transaction__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Transaction__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieBranchNode) FieldChild0() MaybeLink {
	return &n.Child0
}
func (n _TrieBranchNode) FieldChild1() MaybeLink {
	return &n.Child1
}
func (n _TrieBranchNode) FieldChild2() MaybeLink {
	return &n.Child2
}
func (n _TrieBranchNode) FieldChild3() MaybeLink {
	return &n.Child3
}
func (n _TrieBranchNode) FieldChild4() MaybeLink {
	return &n.Child4
}
func (n _TrieBranchNode) FieldChild5() MaybeLink {
	return &n.Child5
}
func (n _TrieBranchNode) FieldChild6() MaybeLink {
	return &n.Child6
}
func (n _TrieBranchNode) FieldChild7() MaybeLink {
	return &n.Child7
}
func (n _TrieBranchNode) FieldChild8() MaybeLink {
	return &n.Child8
}
func (n _TrieBranchNode) FieldChild9() MaybeLink {
	return &n.Child9
}
func (n _TrieBranchNode) FieldChildA() MaybeLink {
	return &n.ChildA
}
func (n _TrieBranchNode) FieldChildB() MaybeLink {
	return &n.ChildB
}
func (n _TrieBranchNode) FieldChildC() MaybeLink {
	return &n.ChildC
}
func (n _TrieBranchNode) FieldChildD() MaybeLink {
	return &n.ChildD
}
func (n _TrieBranchNode) FieldChildE() MaybeLink {
	return &n.ChildE
}
func (n _TrieBranchNode) FieldChildF() MaybeLink {
	return &n.ChildF
}
func (n _TrieBranchNode) FieldValue() Bytes {
	return &n.Value
}

type _TrieBranchNode__Maybe struct {
	m schema.Maybe
	v TrieBranchNode
}
type MaybeTrieBranchNode = *_TrieBranchNode__Maybe

func (m MaybeTrieBranchNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieBranchNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieBranchNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieBranchNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieBranchNode) Must() TrieBranchNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieBranchNode_Child0 = _String{"Child0"}
	fieldName__TrieBranchNode_Child1 = _String{"Child1"}
	fieldName__TrieBranchNode_Child2 = _String{"Child2"}
	fieldName__TrieBranchNode_Child3 = _String{"Child3"}
	fieldName__TrieBranchNode_Child4 = _String{"Child4"}
	fieldName__TrieBranchNode_Child5 = _String{"Child5"}
	fieldName__TrieBranchNode_Child6 = _String{"Child6"}
	fieldName__TrieBranchNode_Child7 = _String{"Child7"}
	fieldName__TrieBranchNode_Child8 = _String{"Child8"}
	fieldName__TrieBranchNode_Child9 = _String{"Child9"}
	fieldName__TrieBranchNode_ChildA = _String{"ChildA"}
	fieldName__TrieBranchNode_ChildB = _String{"ChildB"}
	fieldName__TrieBranchNode_ChildC = _String{"ChildC"}
	fieldName__TrieBranchNode_ChildD = _String{"ChildD"}
	fieldName__TrieBranchNode_ChildE = _String{"ChildE"}
	fieldName__TrieBranchNode_ChildF = _String{"ChildF"}
	fieldName__TrieBranchNode_Value  = _String{"Value"}
)
var _ ipld.Node = (TrieBranchNode)(&_TrieBranchNode{})
var _ schema.TypedNode = (TrieBranchNode)(&_TrieBranchNode{})

func (TrieBranchNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieBranchNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Child0":
		if n.Child0.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child0.v, nil
	case "Child1":
		if n.Child1.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child1.v, nil
	case "Child2":
		if n.Child2.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child2.v, nil
	case "Child3":
		if n.Child3.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child3.v, nil
	case "Child4":
		if n.Child4.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child4.v, nil
	case "Child5":
		if n.Child5.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child5.v, nil
	case "Child6":
		if n.Child6.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child6.v, nil
	case "Child7":
		if n.Child7.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child7.v, nil
	case "Child8":
		if n.Child8.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child8.v, nil
	case "Child9":
		if n.Child9.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child9.v, nil
	case "ChildA":
		if n.ChildA.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildA.v, nil
	case "ChildB":
		if n.ChildB.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildB.v, nil
	case "ChildC":
		if n.ChildC.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildC.v, nil
	case "ChildD":
		if n.ChildD.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildD.v, nil
	case "ChildE":
		if n.ChildE.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildE.v, nil
	case "ChildF":
		if n.ChildF.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildF.v, nil
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieBranchNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieBranchNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.LookupByIndex(0)
}
func (n TrieBranchNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieBranchNode) MapIterator() ipld.MapIterator {
	return &_TrieBranchNode__MapItr{n, 0}
}

type _TrieBranchNode__MapItr struct {
	n   TrieBranchNode
	idx int
}

func (itr *_TrieBranchNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 17 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieBranchNode_Child0
		if itr.n.Child0.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child0.v
	case 1:
		k = &fieldName__TrieBranchNode_Child1
		if itr.n.Child1.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child1.v
	case 2:
		k = &fieldName__TrieBranchNode_Child2
		if itr.n.Child2.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child2.v
	case 3:
		k = &fieldName__TrieBranchNode_Child3
		if itr.n.Child3.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child3.v
	case 4:
		k = &fieldName__TrieBranchNode_Child4
		if itr.n.Child4.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child4.v
	case 5:
		k = &fieldName__TrieBranchNode_Child5
		if itr.n.Child5.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child5.v
	case 6:
		k = &fieldName__TrieBranchNode_Child6
		if itr.n.Child6.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child6.v
	case 7:
		k = &fieldName__TrieBranchNode_Child7
		if itr.n.Child7.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child7.v
	case 8:
		k = &fieldName__TrieBranchNode_Child8
		if itr.n.Child8.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child8.v
	case 9:
		k = &fieldName__TrieBranchNode_Child9
		if itr.n.Child9.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child9.v
	case 10:
		k = &fieldName__TrieBranchNode_ChildA
		if itr.n.ChildA.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildA.v
	case 11:
		k = &fieldName__TrieBranchNode_ChildB
		if itr.n.ChildB.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildB.v
	case 12:
		k = &fieldName__TrieBranchNode_ChildC
		if itr.n.ChildC.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildC.v
	case 13:
		k = &fieldName__TrieBranchNode_ChildD
		if itr.n.ChildD.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildD.v
	case 14:
		k = &fieldName__TrieBranchNode_ChildE
		if itr.n.ChildE.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildE.v
	case 15:
		k = &fieldName__TrieBranchNode_ChildF
		if itr.n.ChildF.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildF.v
	case 16:
		k = &fieldName__TrieBranchNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieBranchNode__MapItr) Done() bool {
	return itr.idx >= 17
}

func (TrieBranchNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieBranchNode) Length() int64 {
	return 17
}
func (TrieBranchNode) IsAbsent() bool {
	return false
}
func (TrieBranchNode) IsNull() bool {
	return false
}
func (TrieBranchNode) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsBool()
}
func (TrieBranchNode) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsInt()
}
func (TrieBranchNode) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsFloat()
}
func (TrieBranchNode) AsString() (string, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsString()
}
func (TrieBranchNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsBytes()
}
func (TrieBranchNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieBranchNode"}.AsLink()
}
func (TrieBranchNode) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__Prototype{}
}

type _TrieBranchNode__Prototype struct{}

func (_TrieBranchNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieBranchNode__Builder
	nb.Reset()
	return &nb
}

type _TrieBranchNode__Builder struct {
	_TrieBranchNode__Assembler
}

func (nb *_TrieBranchNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieBranchNode__Builder) Reset() {
	var w _TrieBranchNode
	var m schema.Maybe
	*nb = _TrieBranchNode__Builder{_TrieBranchNode__Assembler{w: &w, m: &m}}
}

type _TrieBranchNode__Assembler struct {
	w     *_TrieBranchNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Child0 _Link__Assembler
	ca_Child1 _Link__Assembler
	ca_Child2 _Link__Assembler
	ca_Child3 _Link__Assembler
	ca_Child4 _Link__Assembler
	ca_Child5 _Link__Assembler
	ca_Child6 _Link__Assembler
	ca_Child7 _Link__Assembler
	ca_Child8 _Link__Assembler
	ca_Child9 _Link__Assembler
	ca_ChildA _Link__Assembler
	ca_ChildB _Link__Assembler
	ca_ChildC _Link__Assembler
	ca_ChildD _Link__Assembler
	ca_ChildE _Link__Assembler
	ca_ChildF _Link__Assembler
	ca_Value  _Bytes__Assembler
}

func (na *_TrieBranchNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Child0.reset()
	na.ca_Child1.reset()
	na.ca_Child2.reset()
	na.ca_Child3.reset()
	na.ca_Child4.reset()
	na.ca_Child5.reset()
	na.ca_Child6.reset()
	na.ca_Child7.reset()
	na.ca_Child8.reset()
	na.ca_Child9.reset()
	na.ca_ChildA.reset()
	na.ca_ChildB.reset()
	na.ca_ChildC.reset()
	na.ca_ChildD.reset()
	na.ca_ChildE.reset()
	na.ca_ChildF.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__TrieBranchNode_Child0      = 1 << 0
	fieldBit__TrieBranchNode_Child1      = 1 << 1
	fieldBit__TrieBranchNode_Child2      = 1 << 2
	fieldBit__TrieBranchNode_Child3      = 1 << 3
	fieldBit__TrieBranchNode_Child4      = 1 << 4
	fieldBit__TrieBranchNode_Child5      = 1 << 5
	fieldBit__TrieBranchNode_Child6      = 1 << 6
	fieldBit__TrieBranchNode_Child7      = 1 << 7
	fieldBit__TrieBranchNode_Child8      = 1 << 8
	fieldBit__TrieBranchNode_Child9      = 1 << 9
	fieldBit__TrieBranchNode_ChildA      = 1 << 10
	fieldBit__TrieBranchNode_ChildB      = 1 << 11
	fieldBit__TrieBranchNode_ChildC      = 1 << 12
	fieldBit__TrieBranchNode_ChildD      = 1 << 13
	fieldBit__TrieBranchNode_ChildE      = 1 << 14
	fieldBit__TrieBranchNode_ChildF      = 1 << 15
	fieldBit__TrieBranchNode_Value       = 1 << 16
	fieldBits__TrieBranchNode_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13 + 1<<14 + 1<<15 + 1<<16
)

func (na *_TrieBranchNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieBranchNode{}
	}
	return na, nil
}
func (_TrieBranchNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.BeginList(0)
}
func (na *_TrieBranchNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieBranchNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignBool(false)
}
func (_TrieBranchNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignInt(0)
}
func (_TrieBranchNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignFloat(0)
}
func (_TrieBranchNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignString("")
}
func (_TrieBranchNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignBytes(nil)
}
func (_TrieBranchNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode"}.AssignLink(nil)
}
func (na *_TrieBranchNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieBranchNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieBranchNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieBranchNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__Prototype{}
}
func (ma *_TrieBranchNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Child0.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child0.v = ma.ca_Child0.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Child1.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child1.v = ma.ca_Child1.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Child2.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child2.v = ma.ca_Child2.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Child3.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child3.v = ma.ca_Child3.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Child4.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child4.v = ma.ca_Child4.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.Child5.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child5.v = ma.ca_Child5.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Child6.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child6.v = ma.ca_Child6.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Child7.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child7.v = ma.ca_Child7.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.Child8.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child8.v = ma.ca_Child8.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.Child9.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child9.v = ma.ca_Child9.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.ChildA.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildA.v = ma.ca_ChildA.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.w.ChildB.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildB.v = ma.ca_ChildB.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.w.ChildC.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildC.v = ma.ca_ChildC.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.w.ChildD.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildD.v = ma.ca_ChildD.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.w.ChildE.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildE.v = ma.ca_ChildE.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.ChildF.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildF.v = ma.ca_ChildF.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 16:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Child0":
		if ma.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0}
		}
		ma.s += fieldBit__TrieBranchNode_Child0
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0, nil
	case "Child1":
		if ma.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1}
		}
		ma.s += fieldBit__TrieBranchNode_Child1
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1, nil
	case "Child2":
		if ma.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2}
		}
		ma.s += fieldBit__TrieBranchNode_Child2
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2, nil
	case "Child3":
		if ma.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3}
		}
		ma.s += fieldBit__TrieBranchNode_Child3
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3, nil
	case "Child4":
		if ma.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4}
		}
		ma.s += fieldBit__TrieBranchNode_Child4
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4, nil
	case "Child5":
		if ma.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5}
		}
		ma.s += fieldBit__TrieBranchNode_Child5
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5, nil
	case "Child6":
		if ma.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6}
		}
		ma.s += fieldBit__TrieBranchNode_Child6
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6, nil
	case "Child7":
		if ma.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7}
		}
		ma.s += fieldBit__TrieBranchNode_Child7
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7, nil
	case "Child8":
		if ma.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8}
		}
		ma.s += fieldBit__TrieBranchNode_Child8
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8, nil
	case "Child9":
		if ma.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9}
		}
		ma.s += fieldBit__TrieBranchNode_Child9
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9, nil
	case "ChildA":
		if ma.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA}
		}
		ma.s += fieldBit__TrieBranchNode_ChildA
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA, nil
	case "ChildB":
		if ma.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB}
		}
		ma.s += fieldBit__TrieBranchNode_ChildB
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB, nil
	case "ChildC":
		if ma.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC}
		}
		ma.s += fieldBit__TrieBranchNode_ChildC
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC, nil
	case "ChildD":
		if ma.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD}
		}
		ma.s += fieldBit__TrieBranchNode_ChildD
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD, nil
	case "ChildE":
		if ma.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE}
		}
		ma.s += fieldBit__TrieBranchNode_ChildE
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE, nil
	case "ChildF":
		if ma.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF}
		}
		ma.s += fieldBit__TrieBranchNode_ChildF
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF, nil
	case "Value":
		if ma.s&fieldBit__TrieBranchNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value}
		}
		ma.s += fieldBit__TrieBranchNode_Value
		ma.state = maState_midValue
		ma.f = 16
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode", Key: &_String{k}}
}
func (ma *_TrieBranchNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieBranchNode__KeyAssembler)(ma)
}
func (ma *_TrieBranchNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0
	case 1:
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1
	case 2:
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2
	case 3:
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3
	case 4:
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4
	case 5:
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5
	case 6:
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6
	case 7:
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7
	case 8:
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8
	case 9:
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9
	case 10:
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA
	case 11:
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB
	case 12:
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC
	case 13:
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD
	case 14:
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE
	case 15:
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF
	case 16:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieBranchNode_sufficient != fieldBits__TrieBranchNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieBranchNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieBranchNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieBranchNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieBranchNode__KeyAssembler _TrieBranchNode__Assembler

func (_TrieBranchNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieBranchNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieBranchNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignNull()
}
func (_TrieBranchNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieBranchNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieBranchNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieBranchNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Child0":
		if ka.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0}
		}
		ka.s += fieldBit__TrieBranchNode_Child0
		ka.state = maState_expectValue
		ka.f = 0
	case "Child1":
		if ka.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1}
		}
		ka.s += fieldBit__TrieBranchNode_Child1
		ka.state = maState_expectValue
		ka.f = 1
	case "Child2":
		if ka.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2}
		}
		ka.s += fieldBit__TrieBranchNode_Child2
		ka.state = maState_expectValue
		ka.f = 2
	case "Child3":
		if ka.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3}
		}
		ka.s += fieldBit__TrieBranchNode_Child3
		ka.state = maState_expectValue
		ka.f = 3
	case "Child4":
		if ka.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4}
		}
		ka.s += fieldBit__TrieBranchNode_Child4
		ka.state = maState_expectValue
		ka.f = 4
	case "Child5":
		if ka.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5}
		}
		ka.s += fieldBit__TrieBranchNode_Child5
		ka.state = maState_expectValue
		ka.f = 5
	case "Child6":
		if ka.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6}
		}
		ka.s += fieldBit__TrieBranchNode_Child6
		ka.state = maState_expectValue
		ka.f = 6
	case "Child7":
		if ka.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7}
		}
		ka.s += fieldBit__TrieBranchNode_Child7
		ka.state = maState_expectValue
		ka.f = 7
	case "Child8":
		if ka.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8}
		}
		ka.s += fieldBit__TrieBranchNode_Child8
		ka.state = maState_expectValue
		ka.f = 8
	case "Child9":
		if ka.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9}
		}
		ka.s += fieldBit__TrieBranchNode_Child9
		ka.state = maState_expectValue
		ka.f = 9
	case "ChildA":
		if ka.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA}
		}
		ka.s += fieldBit__TrieBranchNode_ChildA
		ka.state = maState_expectValue
		ka.f = 10
	case "ChildB":
		if ka.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB}
		}
		ka.s += fieldBit__TrieBranchNode_ChildB
		ka.state = maState_expectValue
		ka.f = 11
	case "ChildC":
		if ka.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC}
		}
		ka.s += fieldBit__TrieBranchNode_ChildC
		ka.state = maState_expectValue
		ka.f = 12
	case "ChildD":
		if ka.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD}
		}
		ka.s += fieldBit__TrieBranchNode_ChildD
		ka.state = maState_expectValue
		ka.f = 13
	case "ChildE":
		if ka.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE}
		}
		ka.s += fieldBit__TrieBranchNode_ChildE
		ka.state = maState_expectValue
		ka.f = 14
	case "ChildF":
		if ka.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF}
		}
		ka.s += fieldBit__TrieBranchNode_ChildF
		ka.state = maState_expectValue
		ka.f = 15
	case "Value":
		if ka.s&fieldBit__TrieBranchNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value}
		}
		ka.s += fieldBit__TrieBranchNode_Value
		ka.state = maState_expectValue
		ka.f = 16
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieBranchNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieBranchNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieBranchNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieBranchNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieBranchNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieBranchNode) Representation() ipld.Node {
	return (*_TrieBranchNode__Repr)(n)
}

type _TrieBranchNode__Repr _TrieBranchNode

var (
	fieldName__TrieBranchNode_Child0_serial = _String{"Child0"}
	fieldName__TrieBranchNode_Child1_serial = _String{"Child1"}
	fieldName__TrieBranchNode_Child2_serial = _String{"Child2"}
	fieldName__TrieBranchNode_Child3_serial = _String{"Child3"}
	fieldName__TrieBranchNode_Child4_serial = _String{"Child4"}
	fieldName__TrieBranchNode_Child5_serial = _String{"Child5"}
	fieldName__TrieBranchNode_Child6_serial = _String{"Child6"}
	fieldName__TrieBranchNode_Child7_serial = _String{"Child7"}
	fieldName__TrieBranchNode_Child8_serial = _String{"Child8"}
	fieldName__TrieBranchNode_Child9_serial = _String{"Child9"}
	fieldName__TrieBranchNode_ChildA_serial = _String{"ChildA"}
	fieldName__TrieBranchNode_ChildB_serial = _String{"ChildB"}
	fieldName__TrieBranchNode_ChildC_serial = _String{"ChildC"}
	fieldName__TrieBranchNode_ChildD_serial = _String{"ChildD"}
	fieldName__TrieBranchNode_ChildE_serial = _String{"ChildE"}
	fieldName__TrieBranchNode_ChildF_serial = _String{"ChildF"}
	fieldName__TrieBranchNode_Value_serial  = _String{"Value"}
)
var _ ipld.Node = &_TrieBranchNode__Repr{}

func (_TrieBranchNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieBranchNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Child0":
		if n.Child0.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child0.v.Representation(), nil
	case "Child1":
		if n.Child1.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child1.v.Representation(), nil
	case "Child2":
		if n.Child2.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child2.v.Representation(), nil
	case "Child3":
		if n.Child3.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child3.v.Representation(), nil
	case "Child4":
		if n.Child4.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child4.v.Representation(), nil
	case "Child5":
		if n.Child5.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child5.v.Representation(), nil
	case "Child6":
		if n.Child6.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child6.v.Representation(), nil
	case "Child7":
		if n.Child7.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child7.v.Representation(), nil
	case "Child8":
		if n.Child8.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child8.v.Representation(), nil
	case "Child9":
		if n.Child9.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child9.v.Representation(), nil
	case "ChildA":
		if n.ChildA.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildA.v.Representation(), nil
	case "ChildB":
		if n.ChildB.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildB.v.Representation(), nil
	case "ChildC":
		if n.ChildC.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildC.v.Representation(), nil
	case "ChildD":
		if n.ChildD.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildD.v.Representation(), nil
	case "ChildE":
		if n.ChildE.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildE.v.Representation(), nil
	case "ChildF":
		if n.ChildF.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildF.v.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieBranchNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieBranchNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.LookupByIndex(0)
}
func (n _TrieBranchNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieBranchNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieBranchNode__ReprMapItr{n, 0}
}

type _TrieBranchNode__ReprMapItr struct {
	n   *_TrieBranchNode__Repr
	idx int
}

func (itr *_TrieBranchNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 17 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieBranchNode_Child0_serial
		if itr.n.Child0.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child0.v.Representation()
	case 1:
		k = &fieldName__TrieBranchNode_Child1_serial
		if itr.n.Child1.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child1.v.Representation()
	case 2:
		k = &fieldName__TrieBranchNode_Child2_serial
		if itr.n.Child2.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child2.v.Representation()
	case 3:
		k = &fieldName__TrieBranchNode_Child3_serial
		if itr.n.Child3.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child3.v.Representation()
	case 4:
		k = &fieldName__TrieBranchNode_Child4_serial
		if itr.n.Child4.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child4.v.Representation()
	case 5:
		k = &fieldName__TrieBranchNode_Child5_serial
		if itr.n.Child5.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child5.v.Representation()
	case 6:
		k = &fieldName__TrieBranchNode_Child6_serial
		if itr.n.Child6.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child6.v.Representation()
	case 7:
		k = &fieldName__TrieBranchNode_Child7_serial
		if itr.n.Child7.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child7.v.Representation()
	case 8:
		k = &fieldName__TrieBranchNode_Child8_serial
		if itr.n.Child8.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child8.v.Representation()
	case 9:
		k = &fieldName__TrieBranchNode_Child9_serial
		if itr.n.Child9.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child9.v.Representation()
	case 10:
		k = &fieldName__TrieBranchNode_ChildA_serial
		if itr.n.ChildA.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildA.v.Representation()
	case 11:
		k = &fieldName__TrieBranchNode_ChildB_serial
		if itr.n.ChildB.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildB.v.Representation()
	case 12:
		k = &fieldName__TrieBranchNode_ChildC_serial
		if itr.n.ChildC.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildC.v.Representation()
	case 13:
		k = &fieldName__TrieBranchNode_ChildD_serial
		if itr.n.ChildD.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildD.v.Representation()
	case 14:
		k = &fieldName__TrieBranchNode_ChildE_serial
		if itr.n.ChildE.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildE.v.Representation()
	case 15:
		k = &fieldName__TrieBranchNode_ChildF_serial
		if itr.n.ChildF.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildF.v.Representation()
	case 16:
		k = &fieldName__TrieBranchNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieBranchNode__ReprMapItr) Done() bool {
	return itr.idx >= 17
}
func (_TrieBranchNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieBranchNode__Repr) Length() int64 {
	l := 17
	return int64(l)
}
func (_TrieBranchNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieBranchNode__Repr) IsNull() bool {
	return false
}
func (_TrieBranchNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsBool()
}
func (_TrieBranchNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsInt()
}
func (_TrieBranchNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsFloat()
}
func (_TrieBranchNode__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsString()
}
func (_TrieBranchNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsBytes()
}
func (_TrieBranchNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieBranchNode.Repr"}.AsLink()
}
func (_TrieBranchNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__ReprPrototype{}
}

type _TrieBranchNode__ReprPrototype struct{}

func (_TrieBranchNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieBranchNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieBranchNode__ReprBuilder struct {
	_TrieBranchNode__ReprAssembler
}

func (nb *_TrieBranchNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieBranchNode__ReprBuilder) Reset() {
	var w _TrieBranchNode
	var m schema.Maybe
	*nb = _TrieBranchNode__ReprBuilder{_TrieBranchNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieBranchNode__ReprAssembler struct {
	w     *_TrieBranchNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Child0 _Link__ReprAssembler
	ca_Child1 _Link__ReprAssembler
	ca_Child2 _Link__ReprAssembler
	ca_Child3 _Link__ReprAssembler
	ca_Child4 _Link__ReprAssembler
	ca_Child5 _Link__ReprAssembler
	ca_Child6 _Link__ReprAssembler
	ca_Child7 _Link__ReprAssembler
	ca_Child8 _Link__ReprAssembler
	ca_Child9 _Link__ReprAssembler
	ca_ChildA _Link__ReprAssembler
	ca_ChildB _Link__ReprAssembler
	ca_ChildC _Link__ReprAssembler
	ca_ChildD _Link__ReprAssembler
	ca_ChildE _Link__ReprAssembler
	ca_ChildF _Link__ReprAssembler
	ca_Value  _Bytes__ReprAssembler
}

func (na *_TrieBranchNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Child0.reset()
	na.ca_Child1.reset()
	na.ca_Child2.reset()
	na.ca_Child3.reset()
	na.ca_Child4.reset()
	na.ca_Child5.reset()
	na.ca_Child6.reset()
	na.ca_Child7.reset()
	na.ca_Child8.reset()
	na.ca_Child9.reset()
	na.ca_ChildA.reset()
	na.ca_ChildB.reset()
	na.ca_ChildC.reset()
	na.ca_ChildD.reset()
	na.ca_ChildE.reset()
	na.ca_ChildF.reset()
	na.ca_Value.reset()
}
func (na *_TrieBranchNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieBranchNode{}
	}
	return na, nil
}
func (_TrieBranchNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.BeginList(0)
}
func (na *_TrieBranchNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieBranchNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieBranchNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignBool(false)
}
func (_TrieBranchNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignInt(0)
}
func (_TrieBranchNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignFloat(0)
}
func (_TrieBranchNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignString("")
}
func (_TrieBranchNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignBytes(nil)
}
func (_TrieBranchNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieBranchNode.Repr"}.AssignLink(nil)
}
func (na *_TrieBranchNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieBranchNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieBranchNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieBranchNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__ReprPrototype{}
}
func (ma *_TrieBranchNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Child0.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child0.v = ma.ca_Child0.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Child1.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child1.v = ma.ca_Child1.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Child2.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child2.v = ma.ca_Child2.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Child3.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child3.v = ma.ca_Child3.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Child4.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child4.v = ma.ca_Child4.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.Child5.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child5.v = ma.ca_Child5.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Child6.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child6.v = ma.ca_Child6.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Child7.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child7.v = ma.ca_Child7.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.Child8.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child8.v = ma.ca_Child8.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.Child9.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child9.v = ma.ca_Child9.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.ChildA.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildA.v = ma.ca_ChildA.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.w.ChildB.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildB.v = ma.ca_ChildB.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.w.ChildC.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildC.v = ma.ca_ChildC.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.w.ChildD.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildD.v = ma.ca_ChildD.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.w.ChildE.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildE.v = ma.ca_ChildE.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.ChildF.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildF.v = ma.ca_ChildF.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 16:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Child0":
		if ma.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child0
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0, nil
	case "Child1":
		if ma.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child1
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1, nil
	case "Child2":
		if ma.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child2
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2, nil
	case "Child3":
		if ma.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child3
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3, nil
	case "Child4":
		if ma.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child4
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4, nil
	case "Child5":
		if ma.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child5
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5, nil
	case "Child6":
		if ma.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child6
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6, nil
	case "Child7":
		if ma.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child7
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7, nil
	case "Child8":
		if ma.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child8
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8, nil
	case "Child9":
		if ma.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child9
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9, nil
	case "ChildA":
		if ma.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildA
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA, nil
	case "ChildB":
		if ma.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildB
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB, nil
	case "ChildC":
		if ma.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildC
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC, nil
	case "ChildD":
		if ma.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildD
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD, nil
	case "ChildE":
		if ma.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildE
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE, nil
	case "ChildF":
		if ma.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildF
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF, nil
	case "Value":
		if ma.s&fieldBit__TrieBranchNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Value
		ma.state = maState_midValue
		ma.f = 16
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode.Repr", Key: &_String{k}}
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieBranchNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0
	case 1:
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1
	case 2:
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2
	case 3:
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3
	case 4:
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4
	case 5:
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5
	case 6:
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6
	case 7:
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7
	case 8:
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8
	case 9:
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9
	case 10:
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA
	case 11:
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB
	case 12:
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC
	case 13:
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD
	case 14:
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE
	case 15:
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF
	case 16:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieBranchNode_sufficient != fieldBits__TrieBranchNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieBranchNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieBranchNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieBranchNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieBranchNode__ReprKeyAssembler _TrieBranchNode__ReprAssembler

func (_TrieBranchNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieBranchNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieBranchNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieBranchNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieBranchNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Child0":
		if ka.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child0
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Child1":
		if ka.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child1
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Child2":
		if ka.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child2
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Child3":
		if ka.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child3
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Child4":
		if ka.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child4
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Child5":
		if ka.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child5
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Child6":
		if ka.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child6
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Child7":
		if ka.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child7
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "Child8":
		if ka.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child8
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "Child9":
		if ka.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child9
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "ChildA":
		if ka.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildA
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "ChildB":
		if ka.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildB
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "ChildC":
		if ka.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildC
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "ChildD":
		if ka.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildD
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	case "ChildE":
		if ka.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildE
		ka.state = maState_expectValue
		ka.f = 14
		return nil
	case "ChildF":
		if ka.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildF
		ka.state = maState_expectValue
		ka.f = 15
		return nil
	case "Value":
		if ka.s&fieldBit__TrieBranchNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Value
		ka.state = maState_expectValue
		ka.f = 16
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode.Repr", Key: &_String{k}}
}
func (_TrieBranchNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieBranchNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieBranchNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieExtensionNode) FieldPartialPath() Bytes {
	return &n.PartialPath
}
func (n _TrieExtensionNode) FieldChildNode() Link {
	return &n.ChildNode
}

type _TrieExtensionNode__Maybe struct {
	m schema.Maybe
	v TrieExtensionNode
}
type MaybeTrieExtensionNode = *_TrieExtensionNode__Maybe

func (m MaybeTrieExtensionNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieExtensionNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieExtensionNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieExtensionNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieExtensionNode) Must() TrieExtensionNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieExtensionNode_PartialPath = _String{"PartialPath"}
	fieldName__TrieExtensionNode_ChildNode   = _String{"ChildNode"}
)
var _ ipld.Node = (TrieExtensionNode)(&_TrieExtensionNode{})
var _ schema.TypedNode = (TrieExtensionNode)(&_TrieExtensionNode{})

func (TrieExtensionNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieExtensionNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return &n.PartialPath, nil
	case "ChildNode":
		return &n.ChildNode, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieExtensionNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieExtensionNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.LookupByIndex(0)
}
func (n TrieExtensionNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieExtensionNode) MapIterator() ipld.MapIterator {
	return &_TrieExtensionNode__MapItr{n, 0}
}

type _TrieExtensionNode__MapItr struct {
	n   TrieExtensionNode
	idx int
}

func (itr *_TrieExtensionNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieExtensionNode_PartialPath
		v = &itr.n.PartialPath
	case 1:
		k = &fieldName__TrieExtensionNode_ChildNode
		v = &itr.n.ChildNode
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieExtensionNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TrieExtensionNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieExtensionNode) Length() int64 {
	return 2
}
func (TrieExtensionNode) IsAbsent() bool {
	return false
}
func (TrieExtensionNode) IsNull() bool {
	return false
}
func (TrieExtensionNode) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsBool()
}
func (TrieExtensionNode) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsInt()
}
func (TrieExtensionNode) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsFloat()
}
func (TrieExtensionNode) AsString() (string, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsString()
}
func (TrieExtensionNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsBytes()
}
func (TrieExtensionNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieExtensionNode"}.AsLink()
}
func (TrieExtensionNode) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__Prototype{}
}

type _TrieExtensionNode__Prototype struct{}

func (_TrieExtensionNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieExtensionNode__Builder
	nb.Reset()
	return &nb
}

type _TrieExtensionNode__Builder struct {
	_TrieExtensionNode__Assembler
}

func (nb *_TrieExtensionNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieExtensionNode__Builder) Reset() {
	var w _TrieExtensionNode
	var m schema.Maybe
	*nb = _TrieExtensionNode__Builder{_TrieExtensionNode__Assembler{w: &w, m: &m}}
}

type _TrieExtensionNode__Assembler struct {
	w     *_TrieExtensionNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__Assembler
	ca_ChildNode   _Link__Assembler
}

func (na *_TrieExtensionNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_ChildNode.reset()
}

var (
	fieldBit__TrieExtensionNode_PartialPath = 1 << 0
	fieldBit__TrieExtensionNode_ChildNode   = 1 << 1
	fieldBits__TrieExtensionNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_TrieExtensionNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieExtensionNode{}
	}
	return na, nil
}
func (_TrieExtensionNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.BeginList(0)
}
func (na *_TrieExtensionNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieExtensionNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignBool(false)
}
func (_TrieExtensionNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignInt(0)
}
func (_TrieExtensionNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignFloat(0)
}
func (_TrieExtensionNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignString("")
}
func (_TrieExtensionNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignBytes(nil)
}
func (_TrieExtensionNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode"}.AssignLink(nil)
}
func (na *_TrieExtensionNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieExtensionNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieExtensionNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieExtensionNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__Prototype{}
}
func (ma *_TrieExtensionNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartialPath.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ChildNode.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath}
		}
		ma.s += fieldBit__TrieExtensionNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "ChildNode":
		if ma.s&fieldBit__TrieExtensionNode_ChildNode != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_ChildNode}
		}
		ma.s += fieldBit__TrieExtensionNode_ChildNode
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChildNode.w = &ma.w.ChildNode
		ma.ca_ChildNode.m = &ma.cm
		return &ma.ca_ChildNode, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode", Key: &_String{k}}
}
func (ma *_TrieExtensionNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieExtensionNode__KeyAssembler)(ma)
}
func (ma *_TrieExtensionNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_ChildNode.w = &ma.w.ChildNode
		ma.ca_ChildNode.m = &ma.cm
		return &ma.ca_ChildNode
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieExtensionNode_sufficient != fieldBits__TrieExtensionNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieExtensionNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieExtensionNode_ChildNode == 0 {
			err.Missing = append(err.Missing, "ChildNode")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieExtensionNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieExtensionNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieExtensionNode__KeyAssembler _TrieExtensionNode__Assembler

func (_TrieExtensionNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieExtensionNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieExtensionNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignNull()
}
func (_TrieExtensionNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieExtensionNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieExtensionNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieExtensionNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath}
		}
		ka.s += fieldBit__TrieExtensionNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
	case "ChildNode":
		if ka.s&fieldBit__TrieExtensionNode_ChildNode != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_ChildNode}
		}
		ka.s += fieldBit__TrieExtensionNode_ChildNode
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieExtensionNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieExtensionNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieExtensionNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieExtensionNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieExtensionNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieExtensionNode) Representation() ipld.Node {
	return (*_TrieExtensionNode__Repr)(n)
}

type _TrieExtensionNode__Repr _TrieExtensionNode

var (
	fieldName__TrieExtensionNode_PartialPath_serial = _String{"PartialPath"}
	fieldName__TrieExtensionNode_ChildNode_serial   = _String{"ChildNode"}
)
var _ ipld.Node = &_TrieExtensionNode__Repr{}

func (_TrieExtensionNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieExtensionNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return n.PartialPath.Representation(), nil
	case "ChildNode":
		return n.ChildNode.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieExtensionNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieExtensionNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.LookupByIndex(0)
}
func (n _TrieExtensionNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieExtensionNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieExtensionNode__ReprMapItr{n, 0}
}

type _TrieExtensionNode__ReprMapItr struct {
	n   *_TrieExtensionNode__Repr
	idx int
}

func (itr *_TrieExtensionNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieExtensionNode_PartialPath_serial
		v = itr.n.PartialPath.Representation()
	case 1:
		k = &fieldName__TrieExtensionNode_ChildNode_serial
		v = itr.n.ChildNode.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieExtensionNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TrieExtensionNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieExtensionNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_TrieExtensionNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieExtensionNode__Repr) IsNull() bool {
	return false
}
func (_TrieExtensionNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsBool()
}
func (_TrieExtensionNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsInt()
}
func (_TrieExtensionNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsFloat()
}
func (_TrieExtensionNode__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsString()
}
func (_TrieExtensionNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsBytes()
}
func (_TrieExtensionNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieExtensionNode.Repr"}.AsLink()
}
func (_TrieExtensionNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__ReprPrototype{}
}

type _TrieExtensionNode__ReprPrototype struct{}

func (_TrieExtensionNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieExtensionNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieExtensionNode__ReprBuilder struct {
	_TrieExtensionNode__ReprAssembler
}

func (nb *_TrieExtensionNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieExtensionNode__ReprBuilder) Reset() {
	var w _TrieExtensionNode
	var m schema.Maybe
	*nb = _TrieExtensionNode__ReprBuilder{_TrieExtensionNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieExtensionNode__ReprAssembler struct {
	w     *_TrieExtensionNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__ReprAssembler
	ca_ChildNode   _Link__ReprAssembler
}

func (na *_TrieExtensionNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_ChildNode.reset()
}
func (na *_TrieExtensionNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieExtensionNode{}
	}
	return na, nil
}
func (_TrieExtensionNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.BeginList(0)
}
func (na *_TrieExtensionNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieExtensionNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignBool(false)
}
func (_TrieExtensionNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignInt(0)
}
func (_TrieExtensionNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignFloat(0)
}
func (_TrieExtensionNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignString("")
}
func (_TrieExtensionNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignBytes(nil)
}
func (_TrieExtensionNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieExtensionNode.Repr"}.AssignLink(nil)
}
func (na *_TrieExtensionNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieExtensionNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieExtensionNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieExtensionNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__ReprPrototype{}
}
func (ma *_TrieExtensionNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath_serial}
		}
		ma.s += fieldBit__TrieExtensionNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "ChildNode":
		if ma.s&fieldBit__TrieExtensionNode_ChildNode != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_ChildNode_serial}
		}
		ma.s += fieldBit__TrieExtensionNode_ChildNode
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChildNode.w = &ma.w.ChildNode
		ma.ca_ChildNode.m = &ma.cm
		return &ma.ca_ChildNode, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode.Repr", Key: &_String{k}}
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieExtensionNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_ChildNode.w = &ma.w.ChildNode
		ma.ca_ChildNode.m = &ma.cm
		return &ma.ca_ChildNode
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieExtensionNode_sufficient != fieldBits__TrieExtensionNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieExtensionNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieExtensionNode_ChildNode == 0 {
			err.Missing = append(err.Missing, "ChildNode")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieExtensionNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieExtensionNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieExtensionNode__ReprKeyAssembler _TrieExtensionNode__ReprAssembler

func (_TrieExtensionNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieExtensionNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieExtensionNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieExtensionNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath_serial}
		}
		ka.s += fieldBit__TrieExtensionNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ChildNode":
		if ka.s&fieldBit__TrieExtensionNode_ChildNode != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_ChildNode_serial}
		}
		ka.s += fieldBit__TrieExtensionNode_ChildNode
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode.Repr", Key: &_String{k}}
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieExtensionNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieExtensionNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieLeafNode) FieldPartialPath() Bytes {
	return &n.PartialPath
}
func (n _TrieLeafNode) FieldValue() Bytes {
	return &n.Value
}

type _TrieLeafNode__Maybe struct {
	m schema.Maybe
	v TrieLeafNode
}
type MaybeTrieLeafNode = *_TrieLeafNode__Maybe

func (m MaybeTrieLeafNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieLeafNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieLeafNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieLeafNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieLeafNode) Must() TrieLeafNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieLeafNode_PartialPath = _String{"PartialPath"}
	fieldName__TrieLeafNode_Value       = _String{"Value"}
)
var _ ipld.Node = (TrieLeafNode)(&_TrieLeafNode{})
var _ schema.TypedNode = (TrieLeafNode)(&_TrieLeafNode{})

func (TrieLeafNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieLeafNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return &n.PartialPath, nil
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieLeafNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieLeafNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.LookupByIndex(0)
}
func (n TrieLeafNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieLeafNode) MapIterator() ipld.MapIterator {
	return &_TrieLeafNode__MapItr{n, 0}
}

type _TrieLeafNode__MapItr struct {
	n   TrieLeafNode
	idx int
}

func (itr *_TrieLeafNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieLeafNode_PartialPath
		v = &itr.n.PartialPath
	case 1:
		k = &fieldName__TrieLeafNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieLeafNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TrieLeafNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieLeafNode) Length() int64 {
	return 2
}
func (TrieLeafNode) IsAbsent() bool {
	return false
}
func (TrieLeafNode) IsNull() bool {
	return false
}
func (TrieLeafNode) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsBool()
}
func (TrieLeafNode) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsInt()
}
func (TrieLeafNode) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsFloat()
}
func (TrieLeafNode) AsString() (string, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsString()
}
func (TrieLeafNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsBytes()
}
func (TrieLeafNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieLeafNode"}.AsLink()
}
func (TrieLeafNode) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__Prototype{}
}

type _TrieLeafNode__Prototype struct{}

func (_TrieLeafNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieLeafNode__Builder
	nb.Reset()
	return &nb
}

type _TrieLeafNode__Builder struct {
	_TrieLeafNode__Assembler
}

func (nb *_TrieLeafNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieLeafNode__Builder) Reset() {
	var w _TrieLeafNode
	var m schema.Maybe
	*nb = _TrieLeafNode__Builder{_TrieLeafNode__Assembler{w: &w, m: &m}}
}

type _TrieLeafNode__Assembler struct {
	w     *_TrieLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__Assembler
	ca_Value       _Bytes__Assembler
}

func (na *_TrieLeafNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__TrieLeafNode_PartialPath = 1 << 0
	fieldBit__TrieLeafNode_Value       = 1 << 1
	fieldBits__TrieLeafNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_TrieLeafNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieLeafNode{}
	}
	return na, nil
}
func (_TrieLeafNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.BeginList(0)
}
func (na *_TrieLeafNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieLeafNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignBool(false)
}
func (_TrieLeafNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignInt(0)
}
func (_TrieLeafNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignFloat(0)
}
func (_TrieLeafNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignString("")
}
func (_TrieLeafNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignBytes(nil)
}
func (_TrieLeafNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode"}.AssignLink(nil)
}
func (na *_TrieLeafNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieLeafNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieLeafNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__Prototype{}
}
func (ma *_TrieLeafNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartialPath.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath}
		}
		ma.s += fieldBit__TrieLeafNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Value":
		if ma.s&fieldBit__TrieLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value}
		}
		ma.s += fieldBit__TrieLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode", Key: &_String{k}}
}
func (ma *_TrieLeafNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieLeafNode__KeyAssembler)(ma)
}
func (ma *_TrieLeafNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieLeafNode_sufficient != fieldBits__TrieLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieLeafNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieLeafNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieLeafNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieLeafNode__KeyAssembler _TrieLeafNode__Assembler

func (_TrieLeafNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieLeafNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieLeafNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignNull()
}
func (_TrieLeafNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieLeafNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieLeafNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieLeafNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath}
		}
		ka.s += fieldBit__TrieLeafNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
	case "Value":
		if ka.s&fieldBit__TrieLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value}
		}
		ka.s += fieldBit__TrieLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieLeafNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieLeafNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieLeafNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieLeafNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieLeafNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieLeafNode) Representation() ipld.Node {
	return (*_TrieLeafNode__Repr)(n)
}

type _TrieLeafNode__Repr _TrieLeafNode

var (
	fieldName__TrieLeafNode_PartialPath_serial = _String{"PartialPath"}
	fieldName__TrieLeafNode_Value_serial       = _String{"Value"}
)
var _ ipld.Node = &_TrieLeafNode__Repr{}

func (_TrieLeafNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieLeafNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return n.PartialPath.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieLeafNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieLeafNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.LookupByIndex(0)
}
func (n _TrieLeafNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieLeafNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieLeafNode__ReprMapItr{n, 0}
}

type _TrieLeafNode__ReprMapItr struct {
	n   *_TrieLeafNode__Repr
	idx int
}

func (itr *_TrieLeafNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieLeafNode_PartialPath_serial
		v = itr.n.PartialPath.Representation()
	case 1:
		k = &fieldName__TrieLeafNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieLeafNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TrieLeafNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieLeafNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_TrieLeafNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieLeafNode__Repr) IsNull() bool {
	return false
}
func (_TrieLeafNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsBool()
}
func (_TrieLeafNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsInt()
}
func (_TrieLeafNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsFloat()
}
func (_TrieLeafNode__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsString()
}
func (_TrieLeafNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsBytes()
}
func (_TrieLeafNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieLeafNode.Repr"}.AsLink()
}
func (_TrieLeafNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__ReprPrototype{}
}

type _TrieLeafNode__ReprPrototype struct{}

func (_TrieLeafNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieLeafNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieLeafNode__ReprBuilder struct {
	_TrieLeafNode__ReprAssembler
}

func (nb *_TrieLeafNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieLeafNode__ReprBuilder) Reset() {
	var w _TrieLeafNode
	var m schema.Maybe
	*nb = _TrieLeafNode__ReprBuilder{_TrieLeafNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieLeafNode__ReprAssembler struct {
	w     *_TrieLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__ReprAssembler
	ca_Value       _Bytes__ReprAssembler
}

func (na *_TrieLeafNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Value.reset()
}
func (na *_TrieLeafNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieLeafNode{}
	}
	return na, nil
}
func (_TrieLeafNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.BeginList(0)
}
func (na *_TrieLeafNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieLeafNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieLeafNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignBool(false)
}
func (_TrieLeafNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignInt(0)
}
func (_TrieLeafNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignFloat(0)
}
func (_TrieLeafNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignString("")
}
func (_TrieLeafNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignBytes(nil)
}
func (_TrieLeafNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieLeafNode.Repr"}.AssignLink(nil)
}
func (na *_TrieLeafNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieLeafNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieLeafNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__ReprPrototype{}
}
func (ma *_TrieLeafNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath_serial}
		}
		ma.s += fieldBit__TrieLeafNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Value":
		if ma.s&fieldBit__TrieLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value_serial}
		}
		ma.s += fieldBit__TrieLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode.Repr", Key: &_String{k}}
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieLeafNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieLeafNode_sufficient != fieldBits__TrieLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieLeafNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieLeafNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieLeafNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieLeafNode__ReprKeyAssembler _TrieLeafNode__ReprAssembler

func (_TrieLeafNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieLeafNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieLeafNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieLeafNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieLeafNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath_serial}
		}
		ka.s += fieldBit__TrieLeafNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Value":
		if ka.s&fieldBit__TrieLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value_serial}
		}
		ka.s += fieldBit__TrieLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode.Repr", Key: &_String{k}}
}
func (_TrieLeafNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieLeafNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieLeafNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieNode) AsInterface() _TrieNode__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _TrieNode__Maybe struct {
	m schema.Maybe
	v TrieNode
}
type MaybeTrieNode = *_TrieNode__Maybe

func (m MaybeTrieNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieNode) Must() TrieNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__TrieNode_TrieBranchNode    = _String{"TrieBranchNode"}
	memberName__TrieNode_TrieExtensionNode = _String{"TrieExtensionNode"}
	memberName__TrieNode_TrieLeafNode      = _String{"TrieLeafNode"}
	memberName__TrieNode_TrieValueNode     = _String{"TrieValueNode"}
)
var _ ipld.Node = (TrieNode)(&_TrieNode{})
var _ schema.TypedNode = (TrieNode)(&_TrieNode{})

func (TrieNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TrieBranchNode":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "TrieExtensionNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "TrieLeafNode":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "TrieValueNode":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieNode"}.LookupByIndex(0)
}
func (n TrieNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieNode) MapIterator() ipld.MapIterator {
	return &_TrieNode__MapItr{n, false}
}

type _TrieNode__MapItr struct {
	n    TrieNode
	done bool
}

func (itr *_TrieNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TrieNode_TrieBranchNode, &itr.n.x1
	case 2:
		k, v = &memberName__TrieNode_TrieExtensionNode, &itr.n.x2
	case 3:
		k, v = &memberName__TrieNode_TrieLeafNode, &itr.n.x3
	case 4:
		k, v = &memberName__TrieNode_TrieValueNode, &itr.n.x4
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TrieNode__MapItr) Done() bool {
	return itr.done
}

func (TrieNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieNode) Length() int64 {
	return 1
}
func (TrieNode) IsAbsent() bool {
	return false
}
func (TrieNode) IsNull() bool {
	return false
}
func (TrieNode) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieNode"}.AsBool()
}
func (TrieNode) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieNode"}.AsInt()
}
func (TrieNode) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieNode"}.AsFloat()
}
func (TrieNode) AsString() (string, error) {
	return mixins.Map{"dageth.TrieNode"}.AsString()
}
func (TrieNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieNode"}.AsBytes()
}
func (TrieNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieNode"}.AsLink()
}
func (TrieNode) Prototype() ipld.NodePrototype {
	return _TrieNode__Prototype{}
}

type _TrieNode__Prototype struct{}

func (_TrieNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieNode__Builder
	nb.Reset()
	return &nb
}

type _TrieNode__Builder struct {
	_TrieNode__Assembler
}

func (nb *_TrieNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieNode__Builder) Reset() {
	var w _TrieNode
	var m schema.Maybe
	*nb = _TrieNode__Builder{_TrieNode__Assembler{w: &w, m: &m}}
}

type _TrieNode__Assembler struct {
	w     *_TrieNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _TrieBranchNode__Assembler

	ca2 _TrieExtensionNode__Assembler

	ca3 _TrieLeafNode__Assembler

	ca4 _TrieValueNode__Assembler
	ca  uint
}

func (na *_TrieNode__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TrieNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieNode{}
	}
	return na, nil
}
func (_TrieNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieNode"}.BeginList(0)
}
func (na *_TrieNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignBool(false)
}
func (_TrieNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignInt(0)
}
func (_TrieNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignFloat(0)
}
func (_TrieNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignString("")
}
func (_TrieNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignBytes(nil)
}
func (_TrieNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieNode"}.AssignLink(nil)
}
func (na *_TrieNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieNode__Prototype{}
}
func (ma *_TrieNode__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TrieNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TrieBranchNode":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "TrieExtensionNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "TrieLeafNode":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "TrieValueNode":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieNode", Key: &_String{k}}
}
func (ma *_TrieNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieNode__KeyAssembler)(ma)
}
func (ma *_TrieNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	default:
		panic("unreachable")
	}
}
func (ma *_TrieNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TrieBranchNode":
		return _TrieBranchNode__Prototype{}
	case "TrieExtensionNode":
		return _TrieExtensionNode__Prototype{}
	case "TrieLeafNode":
		return _TrieLeafNode__Prototype{}
	case "TrieValueNode":
		return _TrieValueNode__Prototype{}
	default:
		return nil
	}
}

type _TrieNode__KeyAssembler _TrieNode__Assembler

func (_TrieNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignNull()
}
func (_TrieNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TrieBranchNode":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "TrieExtensionNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "TrieLeafNode":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "TrieValueNode":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieNode", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_TrieNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieNode) Representation() ipld.Node {
	return (*_TrieNode__Repr)(n)
}

type _TrieNode__Repr _TrieNode

var (
	memberName__TrieNode_TrieBranchNode_serial    = _String{"branch"}
	memberName__TrieNode_TrieExtensionNode_serial = _String{"extension"}
	memberName__TrieNode_TrieLeafNode_serial      = _String{"leaf"}
	memberName__TrieNode_TrieValueNode_serial     = _String{"value"}
)
var _ ipld.Node = &_TrieNode__Repr{}

func (_TrieNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "branch":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "extension":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "leaf":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "value":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.LookupByIndex(0)
}
func (n _TrieNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieNode__ReprMapItr{n, false}
}

type _TrieNode__ReprMapItr struct {
	n    *_TrieNode__Repr
	done bool
}

func (itr *_TrieNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TrieNode_TrieBranchNode_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__TrieNode_TrieExtensionNode_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__TrieNode_TrieLeafNode_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__TrieNode_TrieValueNode_serial, itr.n.x4.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TrieNode__ReprMapItr) Done() bool {
	return itr.done
}

func (_TrieNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_TrieNode__Repr) Length() int64 {
	return 1
}
func (_TrieNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieNode__Repr) IsNull() bool {
	return false
}
func (_TrieNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsBool()
}
func (_TrieNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsInt()
}
func (_TrieNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsFloat()
}
func (_TrieNode__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsString()
}
func (_TrieNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsBytes()
}
func (_TrieNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieNode.Repr"}.AsLink()
}
func (_TrieNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieNode__ReprPrototype{}
}

type _TrieNode__ReprPrototype struct{}

func (_TrieNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieNode__ReprBuilder struct {
	_TrieNode__ReprAssembler
}

func (nb *_TrieNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieNode__ReprBuilder) Reset() {
	var w _TrieNode
	var m schema.Maybe
	*nb = _TrieNode__ReprBuilder{_TrieNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieNode__ReprAssembler struct {
	w     *_TrieNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _TrieBranchNode__ReprAssembler

	ca2 _TrieExtensionNode__ReprAssembler

	ca3 _TrieLeafNode__ReprAssembler

	ca4 _TrieValueNode__ReprAssembler
	ca  uint
}

func (na *_TrieNode__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TrieNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieNode{}
	}
	return na, nil
}
func (_TrieNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.BeginList(0)
}
func (na *_TrieNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignBool(false)
}
func (_TrieNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignInt(0)
}
func (_TrieNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignFloat(0)
}
func (_TrieNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignString("")
}
func (_TrieNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignBytes(nil)
}
func (_TrieNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieNode.Repr"}.AssignLink(nil)
}
func (na *_TrieNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieNode__ReprPrototype{}
}
func (ma *_TrieNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TrieNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "branch":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "extension":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "leaf":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "value":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieNode.Repr", Key: &_String{k}}
}
func (ma *_TrieNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	default:
		panic("unreachable")
	}
}
func (ma *_TrieNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TrieBranchNode":
		return _TrieBranchNode__ReprPrototype{}
	case "TrieExtensionNode":
		return _TrieExtensionNode__ReprPrototype{}
	case "TrieLeafNode":
		return _TrieLeafNode__ReprPrototype{}
	case "TrieValueNode":
		return _TrieValueNode__ReprPrototype{}
	default:
		return nil
	}
}

type _TrieNode__ReprKeyAssembler _TrieNode__ReprAssembler

func (_TrieNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "branch":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "extension":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "leaf":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "value":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieNode.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_TrieNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieValueNode) FieldValue() Bytes {
	return &n.Value
}

type _TrieValueNode__Maybe struct {
	m schema.Maybe
	v TrieValueNode
}
type MaybeTrieValueNode = *_TrieValueNode__Maybe

func (m MaybeTrieValueNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieValueNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieValueNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieValueNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieValueNode) Must() TrieValueNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieValueNode_Value = _String{"Value"}
)
var _ ipld.Node = (TrieValueNode)(&_TrieValueNode{})
var _ schema.TypedNode = (TrieValueNode)(&_TrieValueNode{})

func (TrieValueNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieValueNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieValueNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieValueNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieValueNode"}.LookupByIndex(0)
}
func (n TrieValueNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieValueNode) MapIterator() ipld.MapIterator {
	return &_TrieValueNode__MapItr{n, 0}
}

type _TrieValueNode__MapItr struct {
	n   TrieValueNode
	idx int
}

func (itr *_TrieValueNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieValueNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieValueNode__MapItr) Done() bool {
	return itr.idx >= 1
}

func (TrieValueNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieValueNode) Length() int64 {
	return 1
}
func (TrieValueNode) IsAbsent() bool {
	return false
}
func (TrieValueNode) IsNull() bool {
	return false
}
func (TrieValueNode) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsBool()
}
func (TrieValueNode) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsInt()
}
func (TrieValueNode) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsFloat()
}
func (TrieValueNode) AsString() (string, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsString()
}
func (TrieValueNode) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsBytes()
}
func (TrieValueNode) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieValueNode"}.AsLink()
}
func (TrieValueNode) Prototype() ipld.NodePrototype {
	return _TrieValueNode__Prototype{}
}

type _TrieValueNode__Prototype struct{}

func (_TrieValueNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieValueNode__Builder
	nb.Reset()
	return &nb
}

type _TrieValueNode__Builder struct {
	_TrieValueNode__Assembler
}

func (nb *_TrieValueNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieValueNode__Builder) Reset() {
	var w _TrieValueNode
	var m schema.Maybe
	*nb = _TrieValueNode__Builder{_TrieValueNode__Assembler{w: &w, m: &m}}
}

type _TrieValueNode__Assembler struct {
	w     *_TrieValueNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Value _Bytes__Assembler
}

func (na *_TrieValueNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Value.reset()
}

var (
	fieldBit__TrieValueNode_Value       = 1 << 0
	fieldBits__TrieValueNode_sufficient = 0 + 1<<0
)

func (na *_TrieValueNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieValueNode{}
	}
	return na, nil
}
func (_TrieValueNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.BeginList(0)
}
func (na *_TrieValueNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieValueNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignBool(false)
}
func (_TrieValueNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignInt(0)
}
func (_TrieValueNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignFloat(0)
}
func (_TrieValueNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignString("")
}
func (_TrieValueNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignBytes(nil)
}
func (_TrieValueNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieValueNode"}.AssignLink(nil)
}
func (na *_TrieValueNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieValueNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieValueNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieValueNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieValueNode__Prototype{}
}
func (ma *_TrieValueNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieValueNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Value":
		if ma.s&fieldBit__TrieValueNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieValueNode_Value}
		}
		ma.s += fieldBit__TrieValueNode_Value
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieValueNode", Key: &_String{k}}
}
func (ma *_TrieValueNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieValueNode__KeyAssembler)(ma)
}
func (ma *_TrieValueNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieValueNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieValueNode_sufficient != fieldBits__TrieValueNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieValueNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieValueNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieValueNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieValueNode__KeyAssembler _TrieValueNode__Assembler

func (_TrieValueNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieValueNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieValueNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignNull()
}
func (_TrieValueNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieValueNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieValueNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieValueNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Value":
		if ka.s&fieldBit__TrieValueNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieValueNode_Value}
		}
		ka.s += fieldBit__TrieValueNode_Value
		ka.state = maState_expectValue
		ka.f = 0
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieValueNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieValueNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieValueNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieValueNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieValueNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieValueNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieValueNode) Representation() ipld.Node {
	return (*_TrieValueNode__Repr)(n)
}

type _TrieValueNode__Repr _TrieValueNode

var (
	fieldName__TrieValueNode_Value_serial = _String{"Value"}
)
var _ ipld.Node = &_TrieValueNode__Repr{}

func (_TrieValueNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieValueNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieValueNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieValueNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.LookupByIndex(0)
}
func (n _TrieValueNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieValueNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieValueNode__ReprMapItr{n, 0}
}

type _TrieValueNode__ReprMapItr struct {
	n   *_TrieValueNode__Repr
	idx int
}

func (itr *_TrieValueNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 1 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieValueNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieValueNode__ReprMapItr) Done() bool {
	return itr.idx >= 1
}
func (_TrieValueNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieValueNode__Repr) Length() int64 {
	l := 1
	return int64(l)
}
func (_TrieValueNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieValueNode__Repr) IsNull() bool {
	return false
}
func (_TrieValueNode__Repr) AsBool() (bool, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsBool()
}
func (_TrieValueNode__Repr) AsInt() (int64, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsInt()
}
func (_TrieValueNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsFloat()
}
func (_TrieValueNode__Repr) AsString() (string, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsString()
}
func (_TrieValueNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsBytes()
}
func (_TrieValueNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"dageth.TrieValueNode.Repr"}.AsLink()
}
func (_TrieValueNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieValueNode__ReprPrototype{}
}

type _TrieValueNode__ReprPrototype struct{}

func (_TrieValueNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieValueNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieValueNode__ReprBuilder struct {
	_TrieValueNode__ReprAssembler
}

func (nb *_TrieValueNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieValueNode__ReprBuilder) Reset() {
	var w _TrieValueNode
	var m schema.Maybe
	*nb = _TrieValueNode__ReprBuilder{_TrieValueNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieValueNode__ReprAssembler struct {
	w     *_TrieValueNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm       schema.Maybe
	ca_Value _Bytes__ReprAssembler
}

func (na *_TrieValueNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Value.reset()
}
func (na *_TrieValueNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieValueNode{}
	}
	return na, nil
}
func (_TrieValueNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.BeginList(0)
}
func (na *_TrieValueNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"dageth.TrieValueNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieValueNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignBool(false)
}
func (_TrieValueNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignInt(0)
}
func (_TrieValueNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignFloat(0)
}
func (_TrieValueNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignString("")
}
func (_TrieValueNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignBytes(nil)
}
func (_TrieValueNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"dageth.TrieValueNode.Repr"}.AssignLink(nil)
}
func (na *_TrieValueNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieValueNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieValueNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieValueNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieValueNode__ReprPrototype{}
}
func (ma *_TrieValueNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieValueNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Value":
		if ma.s&fieldBit__TrieValueNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieValueNode_Value_serial}
		}
		ma.s += fieldBit__TrieValueNode_Value
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieValueNode.Repr", Key: &_String{k}}
}
func (ma *_TrieValueNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieValueNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieValueNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieValueNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieValueNode_sufficient != fieldBits__TrieValueNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieValueNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieValueNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieValueNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieValueNode__ReprKeyAssembler _TrieValueNode__ReprAssembler

func (_TrieValueNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieValueNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieValueNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieValueNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieValueNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieValueNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieValueNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Value":
		if ka.s&fieldBit__TrieValueNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieValueNode_Value_serial}
		}
		ka.s += fieldBit__TrieValueNode_Value
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieValueNode.Repr", Key: &_String{k}}
}
func (_TrieValueNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieValueNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"dageth.TrieValueNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieValueNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieValueNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Uint) Bytes() []byte {
	return n.x
}
func (_Uint__Prototype) FromBytes(v []byte) (Uint, error) {
	n := _Uint{v}
	return &n, nil
}

type _Uint__Maybe struct {
	m schema.Maybe
	v Uint
}
type MaybeUint = *_Uint__Maybe

func (m MaybeUint) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUint) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUint) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUint) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUint) Must() Uint {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Uint)(&_Uint{})
var _ schema.TypedNode = (Uint)(&_Uint{})

func (Uint) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Uint) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Uint"}.LookupByString("")
}
func (Uint) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Uint"}.LookupByNode(nil)
}
func (Uint) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Uint"}.LookupByIndex(0)
}
func (Uint) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"dageth.Uint"}.LookupBySegment(seg)
}
func (Uint) MapIterator() ipld.MapIterator {
	return nil
}
func (Uint) ListIterator() ipld.ListIterator {
	return nil
}
func (Uint) Length() int64 {
	return -1
}
func (Uint) IsAbsent() bool {
	return false
}
func (Uint) IsNull() bool {
	return false
}
func (Uint) AsBool() (bool, error) {
	return mixins.Bytes{"dageth.Uint"}.AsBool()
}
func (Uint) AsInt() (int64, error) {
	return mixins.Bytes{"dageth.Uint"}.AsInt()
}
func (Uint) AsFloat() (float64, error) {
	return mixins.Bytes{"dageth.Uint"}.AsFloat()
}
func (Uint) AsString() (string, error) {
	return mixins.Bytes{"dageth.Uint"}.AsString()
}
func (n Uint) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Uint) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"dageth.Uint"}.AsLink()
}
func (Uint) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}

type _Uint__Prototype struct{}

func (_Uint__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uint__Builder
	nb.Reset()
	return &nb
}

type _Uint__Builder struct {
	_Uint__Assembler
}

func (nb *_Uint__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uint__Builder) Reset() {
	var w _Uint
	var m schema.Maybe
	*nb = _Uint__Builder{_Uint__Assembler{w: &w, m: &m}}
}

type _Uint__Assembler struct {
	w *_Uint
	m *schema.Maybe
}

func (na *_Uint__Assembler) reset() {}
func (_Uint__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"dageth.Uint"}.BeginMap(0)
}
func (_Uint__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"dageth.Uint"}.BeginList(0)
}
func (na *_Uint__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"dageth.Uint"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Uint__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"dageth.Uint"}.AssignBool(false)
}
func (_Uint__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"dageth.Uint"}.AssignInt(0)
}
func (_Uint__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"dageth.Uint"}.AssignFloat(0)
}
func (_Uint__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"dageth.Uint"}.AssignString("")
}
func (na *_Uint__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Uint{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Uint__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"dageth.Uint"}.AssignLink(nil)
}
func (na *_Uint__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uint); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Uint__Assembler) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}
func (Uint) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uint) Representation() ipld.Node {
	return (*_Uint__Repr)(n)
}

type _Uint__Repr = _Uint

var _ ipld.Node = &_Uint__Repr{}

type _Uint__ReprPrototype = _Uint__Prototype
type _Uint__ReprAssembler = _Uint__Assembler

func (n *_Uncles) Lookup(idx int64) Header {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Uncles) LookupMaybe(idx int64) MaybeHeader {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Header__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Uncles__valueAbsent = _Header__Maybe{m: schema.Maybe_Absent}

func (n Uncles) Iterator() *Uncles__Itr {
	return &Uncles__Itr{n, 0}
}

type Uncles__Itr struct {
	n   Uncles
	idx int
}

func (itr *Uncles__Itr) Next() (idx int64, v Header) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Uncles__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Uncles__Maybe struct {
	m schema.Maybe
	v Uncles
}
type MaybeUncles = *_Uncles__Maybe

func (m MaybeUncles) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUncles) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUncles) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUncles) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUncles) Must() Uncles {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var _ ipld.Node = (Uncles)(&_Uncles{})
var _ schema.TypedNode = (Uncles)(&_Uncles{})

func (Uncles) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Uncles) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Uncles"}.LookupByString("")
}
func (n Uncles) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Uncles) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Uncles) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Uncles", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Uncles) MapIterator() ipld.MapIterator {
	return nil
}
func (n Uncles) ListIterator() ipld.ListIterator {
	return &_Uncles__ListItr{n, 0}
}

type _Uncles__ListItr struct {
	n   Uncles
	idx int
}

func (itr *_Uncles__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Uncles__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Uncles) Length() int64 {
	return int64(len(n.x))
}
func (Uncles) IsAbsent() bool {
	return false
}
func (Uncles) IsNull() bool {
	return false
}
func (Uncles) AsBool() (bool, error) {
	return mixins.List{"dageth.Uncles"}.AsBool()
}
func (Uncles) AsInt() (int64, error) {
	return mixins.List{"dageth.Uncles"}.AsInt()
}
func (Uncles) AsFloat() (float64, error) {
	return mixins.List{"dageth.Uncles"}.AsFloat()
}
func (Uncles) AsString() (string, error) {
	return mixins.List{"dageth.Uncles"}.AsString()
}
func (Uncles) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Uncles"}.AsBytes()
}
func (Uncles) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Uncles"}.AsLink()
}
func (Uncles) Prototype() ipld.NodePrototype {
	return _Uncles__Prototype{}
}

type _Uncles__Prototype struct{}

func (_Uncles__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uncles__Builder
	nb.Reset()
	return &nb
}

type _Uncles__Builder struct {
	_Uncles__Assembler
}

func (nb *_Uncles__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uncles__Builder) Reset() {
	var w _Uncles
	var m schema.Maybe
	*nb = _Uncles__Builder{_Uncles__Assembler{w: &w, m: &m}}
}

type _Uncles__Assembler struct {
	w     *_Uncles
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Header__Assembler
}

func (na *_Uncles__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Uncles__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Uncles"}.BeginMap(0)
}
func (na *_Uncles__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Uncles{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Header, 0, sizeHint)
	}
	return na, nil
}
func (na *_Uncles__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Uncles"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Uncles__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignBool(false)
}
func (_Uncles__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignInt(0)
}
func (_Uncles__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignFloat(0)
}
func (_Uncles__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignString("")
}
func (_Uncles__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignBytes(nil)
}
func (_Uncles__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Uncles"}.AssignLink(nil)
}
func (na *_Uncles__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uncles); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Uncles", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Uncles__Assembler) Prototype() ipld.NodePrototype {
	return _Uncles__Prototype{}
}
func (la *_Uncles__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Uncles__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Header{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Uncles__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Uncles__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Header__Prototype{}
}
func (Uncles) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uncles) Representation() ipld.Node {
	return (*_Uncles__Repr)(n)
}

type _Uncles__Repr _Uncles

var _ ipld.Node = &_Uncles__Repr{}

func (_Uncles__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Uncles__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"dageth.Uncles.Repr"}.LookupByString("")
}
func (nr *_Uncles__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Uncles)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Header).Representation(), nil
}
func (nr *_Uncles__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Uncles)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Header).Representation(), nil
}
func (n _Uncles__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Uncles.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Uncles__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Uncles__Repr) ListIterator() ipld.ListIterator {
	return &_Uncles__ReprListItr{(Uncles)(nr), 0}
}

type _Uncles__ReprListItr _Uncles__ListItr

func (itr *_Uncles__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Uncles__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Header).Representation(), nil
}
func (itr *_Uncles__ReprListItr) Done() bool {
	return (*_Uncles__ListItr)(itr).Done()
}

func (rn *_Uncles__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Uncles__Repr) IsAbsent() bool {
	return false
}
func (_Uncles__Repr) IsNull() bool {
	return false
}
func (_Uncles__Repr) AsBool() (bool, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsBool()
}
func (_Uncles__Repr) AsInt() (int64, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsInt()
}
func (_Uncles__Repr) AsFloat() (float64, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsFloat()
}
func (_Uncles__Repr) AsString() (string, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsString()
}
func (_Uncles__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsBytes()
}
func (_Uncles__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"dageth.Uncles.Repr"}.AsLink()
}
func (_Uncles__Repr) Prototype() ipld.NodePrototype {
	return _Uncles__ReprPrototype{}
}

type _Uncles__ReprPrototype struct{}

func (_Uncles__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uncles__ReprBuilder
	nb.Reset()
	return &nb
}

type _Uncles__ReprBuilder struct {
	_Uncles__ReprAssembler
}

func (nb *_Uncles__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uncles__ReprBuilder) Reset() {
	var w _Uncles
	var m schema.Maybe
	*nb = _Uncles__ReprBuilder{_Uncles__ReprAssembler{w: &w, m: &m}}
}

type _Uncles__ReprAssembler struct {
	w     *_Uncles
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Header__ReprAssembler
}

func (na *_Uncles__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Uncles__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.BeginMap(0)
}
func (na *_Uncles__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Uncles{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Header, 0, sizeHint)
	}
	return na, nil
}
func (na *_Uncles__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"dageth.Uncles.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Uncles__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignBool(false)
}
func (_Uncles__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignInt(0)
}
func (_Uncles__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignFloat(0)
}
func (_Uncles__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignString("")
}
func (_Uncles__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignBytes(nil)
}
func (_Uncles__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"dageth.Uncles.Repr"}.AssignLink(nil)
}
func (na *_Uncles__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uncles); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Uncles.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Uncles__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Uncles__ReprPrototype{}
}
func (la *_Uncles__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Uncles__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Header{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Uncles__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Uncles__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Header__ReprPrototype{}
}
