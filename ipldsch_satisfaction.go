package dageth

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n _AccessElement) FieldAddress() Address {
	return &n.Address
}
func (n _AccessElement) FieldStorageKeys() StorageKeys {
	return &n.StorageKeys
}

type _AccessElement__Maybe struct {
	m schema.Maybe
	v AccessElement
}
type MaybeAccessElement = *_AccessElement__Maybe

func (m MaybeAccessElement) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAccessElement) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAccessElement) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAccessElement) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAccessElement) Must() AccessElement {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__AccessElement_Address     = _String{"Address"}
	fieldName__AccessElement_StorageKeys = _String{"StorageKeys"}
)
var _ ipld.Node = (AccessElement)(&_AccessElement{})
var _ schema.TypedNode = (AccessElement)(&_AccessElement{})

func (AccessElement) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n AccessElement) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "StorageKeys":
		return &n.StorageKeys, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n AccessElement) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (AccessElement) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.LookupByIndex(0)
}
func (n AccessElement) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n AccessElement) MapIterator() ipld.MapIterator {
	return &_AccessElement__MapItr{n, 0}
}

type _AccessElement__MapItr struct {
	n   AccessElement
	idx int
}

func (itr *_AccessElement__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AccessElement_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__AccessElement_StorageKeys
		v = &itr.n.StorageKeys
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AccessElement__MapItr) Done() bool {
	return itr.idx >= 2
}

func (AccessElement) ListIterator() ipld.ListIterator {
	return nil
}
func (AccessElement) Length() int64 {
	return 2
}
func (AccessElement) IsAbsent() bool {
	return false
}
func (AccessElement) IsNull() bool {
	return false
}
func (AccessElement) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsBool()
}
func (AccessElement) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsInt()
}
func (AccessElement) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsFloat()
}
func (AccessElement) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsString()
}
func (AccessElement) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsBytes()
}
func (AccessElement) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.AccessElement"}.AsLink()
}
func (AccessElement) Prototype() ipld.NodePrototype {
	return _AccessElement__Prototype{}
}

type _AccessElement__Prototype struct{}

func (_AccessElement__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessElement__Builder
	nb.Reset()
	return &nb
}

type _AccessElement__Builder struct {
	_AccessElement__Assembler
}

func (nb *_AccessElement__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessElement__Builder) Reset() {
	var w _AccessElement
	var m schema.Maybe
	*nb = _AccessElement__Builder{_AccessElement__Assembler{w: &w, m: &m}}
}

type _AccessElement__Assembler struct {
	w     *_AccessElement
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Address     _Address__Assembler
	ca_StorageKeys _StorageKeys__Assembler
}

func (na *_AccessElement__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_StorageKeys.reset()
}

var (
	fieldBit__AccessElement_Address     = 1 << 0
	fieldBit__AccessElement_StorageKeys = 1 << 1
	fieldBits__AccessElement_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_AccessElement__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AccessElement{}
	}
	return na, nil
}
func (_AccessElement__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.BeginList(0)
}
func (na *_AccessElement__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessElement__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignBool(false)
}
func (_AccessElement__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignInt(0)
}
func (_AccessElement__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignFloat(0)
}
func (_AccessElement__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignString("")
}
func (_AccessElement__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignBytes(nil)
}
func (_AccessElement__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement"}.AssignLink(nil)
}
func (na *_AccessElement__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessElement); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessElement", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessElement__Assembler) Prototype() ipld.NodePrototype {
	return _AccessElement__Prototype{}
}
func (ma *_AccessElement__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StorageKeys.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__AccessElement_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address}
		}
		ma.s += fieldBit__AccessElement_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "StorageKeys":
		if ma.s&fieldBit__AccessElement_StorageKeys != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys}
		}
		ma.s += fieldBit__AccessElement_StorageKeys
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.AccessElement", Key: &_String{k}}
}
func (ma *_AccessElement__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AccessElement__KeyAssembler)(ma)
}
func (ma *_AccessElement__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__AccessElement_sufficient != fieldBits__AccessElement_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__AccessElement_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__AccessElement_StorageKeys == 0 {
			err.Missing = append(err.Missing, "StorageKeys")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AccessElement__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AccessElement__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _AccessElement__KeyAssembler _AccessElement__Assembler

func (_AccessElement__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.BeginMap(0)
}
func (_AccessElement__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.BeginList(0)
}
func (na *_AccessElement__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignNull()
}
func (_AccessElement__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignBool(false)
}
func (_AccessElement__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignInt(0)
}
func (_AccessElement__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AccessElement__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__AccessElement_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address}
		}
		ka.s += fieldBit__AccessElement_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "StorageKeys":
		if ka.s&fieldBit__AccessElement_StorageKeys != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys}
		}
		ka.s += fieldBit__AccessElement_StorageKeys
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.AccessElement", Key: &_String{k}}
	}
	return nil
}
func (_AccessElement__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignBytes(nil)
}
func (_AccessElement__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AccessElement__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AccessElement__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (AccessElement) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AccessElement) Representation() ipld.Node {
	return (*_AccessElement__Repr)(n)
}

type _AccessElement__Repr _AccessElement

var (
	fieldName__AccessElement_Address_serial     = _String{"Address"}
	fieldName__AccessElement_StorageKeys_serial = _String{"StorageKeys"}
)
var _ ipld.Node = &_AccessElement__Repr{}

func (_AccessElement__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_AccessElement__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "StorageKeys":
		return n.StorageKeys.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_AccessElement__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_AccessElement__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.LookupByIndex(0)
}
func (n _AccessElement__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_AccessElement__Repr) MapIterator() ipld.MapIterator {
	return &_AccessElement__ReprMapItr{n, 0}
}

type _AccessElement__ReprMapItr struct {
	n   *_AccessElement__Repr
	idx int
}

func (itr *_AccessElement__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AccessElement_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__AccessElement_StorageKeys_serial
		v = itr.n.StorageKeys.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AccessElement__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_AccessElement__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_AccessElement__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_AccessElement__Repr) IsAbsent() bool {
	return false
}
func (_AccessElement__Repr) IsNull() bool {
	return false
}
func (_AccessElement__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsBool()
}
func (_AccessElement__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsInt()
}
func (_AccessElement__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsFloat()
}
func (_AccessElement__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsString()
}
func (_AccessElement__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsBytes()
}
func (_AccessElement__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.AccessElement.Repr"}.AsLink()
}
func (_AccessElement__Repr) Prototype() ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}

type _AccessElement__ReprPrototype struct{}

func (_AccessElement__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessElement__ReprBuilder
	nb.Reset()
	return &nb
}

type _AccessElement__ReprBuilder struct {
	_AccessElement__ReprAssembler
}

func (nb *_AccessElement__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessElement__ReprBuilder) Reset() {
	var w _AccessElement
	var m schema.Maybe
	*nb = _AccessElement__ReprBuilder{_AccessElement__ReprAssembler{w: &w, m: &m}}
}

type _AccessElement__ReprAssembler struct {
	w     *_AccessElement
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_Address     _Address__ReprAssembler
	ca_StorageKeys _StorageKeys__ReprAssembler
}

func (na *_AccessElement__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_StorageKeys.reset()
}
func (na *_AccessElement__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AccessElement{}
	}
	return na, nil
}
func (_AccessElement__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.BeginList(0)
}
func (na *_AccessElement__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessElement__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignBool(false)
}
func (_AccessElement__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignInt(0)
}
func (_AccessElement__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignFloat(0)
}
func (_AccessElement__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignString("")
}
func (_AccessElement__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignBytes(nil)
}
func (_AccessElement__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.AccessElement.Repr"}.AssignLink(nil)
}
func (na *_AccessElement__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessElement); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessElement.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessElement__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}
func (ma *_AccessElement__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__AccessElement_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address_serial}
		}
		ma.s += fieldBit__AccessElement_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "StorageKeys":
		if ma.s&fieldBit__AccessElement_StorageKeys != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys_serial}
		}
		ma.s += fieldBit__AccessElement_StorageKeys
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.AccessElement.Repr", Key: &_String{k}}
}
func (ma *_AccessElement__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AccessElement__ReprKeyAssembler)(ma)
}
func (ma *_AccessElement__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_StorageKeys.w = &ma.w.StorageKeys
		ma.ca_StorageKeys.m = &ma.cm
		return &ma.ca_StorageKeys
	default:
		panic("unreachable")
	}
}
func (ma *_AccessElement__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__AccessElement_sufficient != fieldBits__AccessElement_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__AccessElement_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__AccessElement_StorageKeys == 0 {
			err.Missing = append(err.Missing, "StorageKeys")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AccessElement__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AccessElement__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _AccessElement__ReprKeyAssembler _AccessElement__ReprAssembler

func (_AccessElement__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.BeginMap(0)
}
func (_AccessElement__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_AccessElement__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignNull()
}
func (_AccessElement__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignBool(false)
}
func (_AccessElement__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignInt(0)
}
func (_AccessElement__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AccessElement__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__AccessElement_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_Address_serial}
		}
		ka.s += fieldBit__AccessElement_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "StorageKeys":
		if ka.s&fieldBit__AccessElement_StorageKeys != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__AccessElement_StorageKeys_serial}
		}
		ka.s += fieldBit__AccessElement_StorageKeys
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.AccessElement.Repr", Key: &_String{k}}
}
func (_AccessElement__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_AccessElement__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.AccessElement.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AccessElement__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AccessElement__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_AccessList) Lookup(idx int64) AccessElement {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_AccessList) LookupMaybe(idx int64) MaybeAccessElement {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_AccessElement__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _AccessList__valueAbsent = _AccessElement__Maybe{m: schema.Maybe_Absent}

func (n AccessList) Iterator() *AccessList__Itr {
	return &AccessList__Itr{n, 0}
}

type AccessList__Itr struct {
	n   AccessList
	idx int
}

func (itr *AccessList__Itr) Next() (idx int64, v AccessElement) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *AccessList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _AccessList__Maybe struct {
	m schema.Maybe
	v _AccessList
}
type MaybeAccessList = *_AccessList__Maybe

func (m MaybeAccessList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAccessList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAccessList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAccessList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAccessList) Must() AccessList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (AccessList)(&_AccessList{})
var _ schema.TypedNode = (AccessList)(&_AccessList{})

func (AccessList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (AccessList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.LookupByString("")
}
func (n AccessList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n AccessList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n AccessList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.AccessList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (AccessList) MapIterator() ipld.MapIterator {
	return nil
}
func (n AccessList) ListIterator() ipld.ListIterator {
	return &_AccessList__ListItr{n, 0}
}

type _AccessList__ListItr struct {
	n   AccessList
	idx int
}

func (itr *_AccessList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_AccessList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n AccessList) Length() int64 {
	return int64(len(n.x))
}
func (AccessList) IsAbsent() bool {
	return false
}
func (AccessList) IsNull() bool {
	return false
}
func (AccessList) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsBool()
}
func (AccessList) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsInt()
}
func (AccessList) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsFloat()
}
func (AccessList) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsString()
}
func (AccessList) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsBytes()
}
func (AccessList) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.AccessList"}.AsLink()
}
func (AccessList) Prototype() ipld.NodePrototype {
	return _AccessList__Prototype{}
}

type _AccessList__Prototype struct{}

func (_AccessList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessList__Builder
	nb.Reset()
	return &nb
}

type _AccessList__Builder struct {
	_AccessList__Assembler
}

func (nb *_AccessList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessList__Builder) Reset() {
	var w _AccessList
	var m schema.Maybe
	*nb = _AccessList__Builder{_AccessList__Assembler{w: &w, m: &m}}
}

type _AccessList__Assembler struct {
	w     *_AccessList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _AccessElement__Assembler
}

func (na *_AccessList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_AccessList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.BeginMap(0)
}
func (na *_AccessList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_AccessElement, 0, sizeHint)
	}
	return na, nil
}
func (na *_AccessList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignBool(false)
}
func (_AccessList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignInt(0)
}
func (_AccessList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignFloat(0)
}
func (_AccessList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignString("")
}
func (_AccessList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignBytes(nil)
}
func (_AccessList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList"}.AssignLink(nil)
}
func (na *_AccessList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessList__Assembler) Prototype() ipld.NodePrototype {
	return _AccessList__Prototype{}
}
func (la *_AccessList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_AccessList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AccessElement{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_AccessList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_AccessList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AccessElement__Prototype{}
}
func (AccessList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AccessList) Representation() ipld.Node {
	return (*_AccessList__Repr)(n)
}

type _AccessList__Repr _AccessList

var _ ipld.Node = &_AccessList__Repr{}

func (_AccessList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_AccessList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.LookupByString("")
}
func (nr *_AccessList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (AccessList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AccessElement).Representation(), nil
}
func (nr *_AccessList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (AccessList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AccessElement).Representation(), nil
}
func (n _AccessList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.AccessList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_AccessList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_AccessList__Repr) ListIterator() ipld.ListIterator {
	return &_AccessList__ReprListItr{(AccessList)(nr), 0}
}

type _AccessList__ReprListItr _AccessList__ListItr

func (itr *_AccessList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_AccessList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(AccessElement).Representation(), nil
}
func (itr *_AccessList__ReprListItr) Done() bool {
	return (*_AccessList__ListItr)(itr).Done()
}

func (rn *_AccessList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_AccessList__Repr) IsAbsent() bool {
	return false
}
func (_AccessList__Repr) IsNull() bool {
	return false
}
func (_AccessList__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsBool()
}
func (_AccessList__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsInt()
}
func (_AccessList__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsFloat()
}
func (_AccessList__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsString()
}
func (_AccessList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsBytes()
}
func (_AccessList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.AccessList.Repr"}.AsLink()
}
func (_AccessList__Repr) Prototype() ipld.NodePrototype {
	return _AccessList__ReprPrototype{}
}

type _AccessList__ReprPrototype struct{}

func (_AccessList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AccessList__ReprBuilder
	nb.Reset()
	return &nb
}

type _AccessList__ReprBuilder struct {
	_AccessList__ReprAssembler
}

func (nb *_AccessList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AccessList__ReprBuilder) Reset() {
	var w _AccessList
	var m schema.Maybe
	*nb = _AccessList__ReprBuilder{_AccessList__ReprAssembler{w: &w, m: &m}}
}

type _AccessList__ReprAssembler struct {
	w     *_AccessList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _AccessElement__ReprAssembler
}

func (na *_AccessList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_AccessList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.BeginMap(0)
}
func (na *_AccessList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_AccessElement, 0, sizeHint)
	}
	return na, nil
}
func (na *_AccessList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AccessList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignBool(false)
}
func (_AccessList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignInt(0)
}
func (_AccessList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignFloat(0)
}
func (_AccessList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignString("")
}
func (_AccessList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignBytes(nil)
}
func (_AccessList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.AccessList.Repr"}.AssignLink(nil)
}
func (na *_AccessList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AccessList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.AccessList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AccessList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AccessList__ReprPrototype{}
}
func (la *_AccessList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_AccessList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AccessElement{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_AccessList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_AccessList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AccessElement__ReprPrototype{}
}

func (n _Account) FieldNonce() Uint {
	return &n.Nonce
}
func (n _Account) FieldBalance() Balance {
	return &n.Balance
}
func (n _Account) FieldStorageRootCID() Link {
	return &n.StorageRootCID
}
func (n _Account) FieldCodeCID() Link {
	return &n.CodeCID
}

type _Account__Maybe struct {
	m schema.Maybe
	v Account
}
type MaybeAccount = *_Account__Maybe

func (m MaybeAccount) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAccount) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAccount) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAccount) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAccount) Must() Account {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Account_Nonce          = _String{"Nonce"}
	fieldName__Account_Balance        = _String{"Balance"}
	fieldName__Account_StorageRootCID = _String{"StorageRootCID"}
	fieldName__Account_CodeCID        = _String{"CodeCID"}
)
var _ ipld.Node = (Account)(&_Account{})
var _ schema.TypedNode = (Account)(&_Account{})

func (Account) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Account) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Nonce":
		return &n.Nonce, nil
	case "Balance":
		return &n.Balance, nil
	case "StorageRootCID":
		return &n.StorageRootCID, nil
	case "CodeCID":
		return &n.CodeCID, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Account) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Account) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Account"}.LookupByIndex(0)
}
func (n Account) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Account) MapIterator() ipld.MapIterator {
	return &_Account__MapItr{n, 0}
}

type _Account__MapItr struct {
	n   Account
	idx int
}

func (itr *_Account__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Account_Nonce
		v = &itr.n.Nonce
	case 1:
		k = &fieldName__Account_Balance
		v = &itr.n.Balance
	case 2:
		k = &fieldName__Account_StorageRootCID
		v = &itr.n.StorageRootCID
	case 3:
		k = &fieldName__Account_CodeCID
		v = &itr.n.CodeCID
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Account__MapItr) Done() bool {
	return itr.idx >= 4
}

func (Account) ListIterator() ipld.ListIterator {
	return nil
}
func (Account) Length() int64 {
	return 4
}
func (Account) IsAbsent() bool {
	return false
}
func (Account) IsNull() bool {
	return false
}
func (Account) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsBool()
}
func (Account) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsInt()
}
func (Account) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsFloat()
}
func (Account) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsString()
}
func (Account) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsBytes()
}
func (Account) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Account"}.AsLink()
}
func (Account) Prototype() ipld.NodePrototype {
	return _Account__Prototype{}
}

type _Account__Prototype struct{}

func (_Account__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Account__Builder
	nb.Reset()
	return &nb
}

type _Account__Builder struct {
	_Account__Assembler
}

func (nb *_Account__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Account__Builder) Reset() {
	var w _Account
	var m schema.Maybe
	*nb = _Account__Builder{_Account__Assembler{w: &w, m: &m}}
}

type _Account__Assembler struct {
	w     *_Account
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                schema.Maybe
	ca_Nonce          _Uint__Assembler
	ca_Balance        _Balance__Assembler
	ca_StorageRootCID _Link__Assembler
	ca_CodeCID        _Link__Assembler
}

func (na *_Account__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Nonce.reset()
	na.ca_Balance.reset()
	na.ca_StorageRootCID.reset()
	na.ca_CodeCID.reset()
}

var (
	fieldBit__Account_Nonce          = 1 << 0
	fieldBit__Account_Balance        = 1 << 1
	fieldBit__Account_StorageRootCID = 1 << 2
	fieldBit__Account_CodeCID        = 1 << 3
	fieldBits__Account_sufficient    = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3
)

func (na *_Account__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Account{}
	}
	return na, nil
}
func (_Account__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.BeginList(0)
}
func (na *_Account__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Account__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignBool(false)
}
func (_Account__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignInt(0)
}
func (_Account__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignFloat(0)
}
func (_Account__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignString("")
}
func (_Account__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignBytes(nil)
}
func (_Account__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Account"}.AssignLink(nil)
}
func (na *_Account__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Account); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Account", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Account__Assembler) Prototype() ipld.NodePrototype {
	return _Account__Prototype{}
}
func (ma *_Account__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Balance.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StorageRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CodeCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Account__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Nonce":
		if ma.s&fieldBit__Account_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Nonce}
		}
		ma.s += fieldBit__Account_Nonce
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "Balance":
		if ma.s&fieldBit__Account_Balance != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Balance}
		}
		ma.s += fieldBit__Account_Balance
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance, nil
	case "StorageRootCID":
		if ma.s&fieldBit__Account_StorageRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_StorageRootCID}
		}
		ma.s += fieldBit__Account_StorageRootCID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID, nil
	case "CodeCID":
		if ma.s&fieldBit__Account_CodeCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_CodeCID}
		}
		ma.s += fieldBit__Account_CodeCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Account", Key: &_String{k}}
}
func (ma *_Account__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Account__KeyAssembler)(ma)
}
func (ma *_Account__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 1:
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance
	case 2:
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID
	case 3:
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID
	default:
		panic("unreachable")
	}
}
func (ma *_Account__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Account_sufficient != fieldBits__Account_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Account_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		if ma.s&fieldBit__Account_Balance == 0 {
			err.Missing = append(err.Missing, "Balance")
		}
		if ma.s&fieldBit__Account_StorageRootCID == 0 {
			err.Missing = append(err.Missing, "StorageRootCID")
		}
		if ma.s&fieldBit__Account_CodeCID == 0 {
			err.Missing = append(err.Missing, "CodeCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Account__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Account__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Account__KeyAssembler _Account__Assembler

func (_Account__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.BeginMap(0)
}
func (_Account__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.BeginList(0)
}
func (na *_Account__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignNull()
}
func (_Account__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignBool(false)
}
func (_Account__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignInt(0)
}
func (_Account__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Account__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Nonce":
		if ka.s&fieldBit__Account_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Nonce}
		}
		ka.s += fieldBit__Account_Nonce
		ka.state = maState_expectValue
		ka.f = 0
	case "Balance":
		if ka.s&fieldBit__Account_Balance != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Balance}
		}
		ka.s += fieldBit__Account_Balance
		ka.state = maState_expectValue
		ka.f = 1
	case "StorageRootCID":
		if ka.s&fieldBit__Account_StorageRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_StorageRootCID}
		}
		ka.s += fieldBit__Account_StorageRootCID
		ka.state = maState_expectValue
		ka.f = 2
	case "CodeCID":
		if ka.s&fieldBit__Account_CodeCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_CodeCID}
		}
		ka.s += fieldBit__Account_CodeCID
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Account", Key: &_String{k}}
	}
	return nil
}
func (_Account__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignBytes(nil)
}
func (_Account__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Account__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Account__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Account) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Account) Representation() ipld.Node {
	return (*_Account__Repr)(n)
}

type _Account__Repr _Account

var (
	fieldName__Account_Nonce_serial          = _String{"Nonce"}
	fieldName__Account_Balance_serial        = _String{"Balance"}
	fieldName__Account_StorageRootCID_serial = _String{"StorageRootCID"}
	fieldName__Account_CodeCID_serial        = _String{"CodeCID"}
)
var _ ipld.Node = &_Account__Repr{}

func (_Account__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Account__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Nonce":
		return n.Nonce.Representation(), nil
	case "Balance":
		return n.Balance.Representation(), nil
	case "StorageRootCID":
		return n.StorageRootCID.Representation(), nil
	case "CodeCID":
		return n.CodeCID.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Account__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Account__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.LookupByIndex(0)
}
func (n _Account__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Account__Repr) MapIterator() ipld.MapIterator {
	return &_Account__ReprMapItr{n, 0}
}

type _Account__ReprMapItr struct {
	n   *_Account__Repr
	idx int
}

func (itr *_Account__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Account_Nonce_serial
		v = itr.n.Nonce.Representation()
	case 1:
		k = &fieldName__Account_Balance_serial
		v = itr.n.Balance.Representation()
	case 2:
		k = &fieldName__Account_StorageRootCID_serial
		v = itr.n.StorageRootCID.Representation()
	case 3:
		k = &fieldName__Account_CodeCID_serial
		v = itr.n.CodeCID.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Account__ReprMapItr) Done() bool {
	return itr.idx >= 4
}
func (_Account__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Account__Repr) Length() int64 {
	l := 4
	return int64(l)
}
func (_Account__Repr) IsAbsent() bool {
	return false
}
func (_Account__Repr) IsNull() bool {
	return false
}
func (_Account__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsBool()
}
func (_Account__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsInt()
}
func (_Account__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsFloat()
}
func (_Account__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsString()
}
func (_Account__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsBytes()
}
func (_Account__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Account.Repr"}.AsLink()
}
func (_Account__Repr) Prototype() ipld.NodePrototype {
	return _Account__ReprPrototype{}
}

type _Account__ReprPrototype struct{}

func (_Account__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Account__ReprBuilder
	nb.Reset()
	return &nb
}

type _Account__ReprBuilder struct {
	_Account__ReprAssembler
}

func (nb *_Account__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Account__ReprBuilder) Reset() {
	var w _Account
	var m schema.Maybe
	*nb = _Account__ReprBuilder{_Account__ReprAssembler{w: &w, m: &m}}
}

type _Account__ReprAssembler struct {
	w     *_Account
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                schema.Maybe
	ca_Nonce          _Uint__ReprAssembler
	ca_Balance        _Balance__ReprAssembler
	ca_StorageRootCID _Link__ReprAssembler
	ca_CodeCID        _Link__ReprAssembler
}

func (na *_Account__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Nonce.reset()
	na.ca_Balance.reset()
	na.ca_StorageRootCID.reset()
	na.ca_CodeCID.reset()
}
func (na *_Account__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Account{}
	}
	return na, nil
}
func (_Account__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.BeginList(0)
}
func (na *_Account__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Account.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Account__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignBool(false)
}
func (_Account__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignInt(0)
}
func (_Account__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignFloat(0)
}
func (_Account__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignString("")
}
func (_Account__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignBytes(nil)
}
func (_Account__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Account.Repr"}.AssignLink(nil)
}
func (na *_Account__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Account); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Account.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Account__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Account__ReprPrototype{}
}
func (ma *_Account__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Account__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Nonce":
		if ma.s&fieldBit__Account_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Nonce_serial}
		}
		ma.s += fieldBit__Account_Nonce
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "Balance":
		if ma.s&fieldBit__Account_Balance != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Balance_serial}
		}
		ma.s += fieldBit__Account_Balance
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance, nil
	case "StorageRootCID":
		if ma.s&fieldBit__Account_StorageRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_StorageRootCID_serial}
		}
		ma.s += fieldBit__Account_StorageRootCID
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID, nil
	case "CodeCID":
		if ma.s&fieldBit__Account_CodeCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Account_CodeCID_serial}
		}
		ma.s += fieldBit__Account_CodeCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Account.Repr", Key: &_String{k}}
}
func (ma *_Account__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Account__ReprKeyAssembler)(ma)
}
func (ma *_Account__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 1:
		ma.ca_Balance.w = &ma.w.Balance
		ma.ca_Balance.m = &ma.cm
		return &ma.ca_Balance
	case 2:
		ma.ca_StorageRootCID.w = &ma.w.StorageRootCID
		ma.ca_StorageRootCID.m = &ma.cm
		return &ma.ca_StorageRootCID
	case 3:
		ma.ca_CodeCID.w = &ma.w.CodeCID
		ma.ca_CodeCID.m = &ma.cm
		return &ma.ca_CodeCID
	default:
		panic("unreachable")
	}
}
func (ma *_Account__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Account_sufficient != fieldBits__Account_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Account_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		if ma.s&fieldBit__Account_Balance == 0 {
			err.Missing = append(err.Missing, "Balance")
		}
		if ma.s&fieldBit__Account_StorageRootCID == 0 {
			err.Missing = append(err.Missing, "StorageRootCID")
		}
		if ma.s&fieldBit__Account_CodeCID == 0 {
			err.Missing = append(err.Missing, "CodeCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Account__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Account__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Account__ReprKeyAssembler _Account__ReprAssembler

func (_Account__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Account__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Account__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignNull()
}
func (_Account__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Account__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Account__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Account__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Nonce":
		if ka.s&fieldBit__Account_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Nonce_serial}
		}
		ka.s += fieldBit__Account_Nonce
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Balance":
		if ka.s&fieldBit__Account_Balance != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_Balance_serial}
		}
		ka.s += fieldBit__Account_Balance
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "StorageRootCID":
		if ka.s&fieldBit__Account_StorageRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_StorageRootCID_serial}
		}
		ka.s += fieldBit__Account_StorageRootCID
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "CodeCID":
		if ka.s&fieldBit__Account_CodeCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Account_CodeCID_serial}
		}
		ka.s += fieldBit__Account_CodeCID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Account.Repr", Key: &_String{k}}
}
func (_Account__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Account__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Account.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Account__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Account__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Address) Bytes() []byte {
	return n.x
}
func (_Address__Prototype) FromBytes(v []byte) (Address, error) {
	n := _Address{v}
	return &n, nil
}

type _Address__Maybe struct {
	m schema.Maybe
	v _Address
}
type MaybeAddress = *_Address__Maybe

func (m MaybeAddress) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAddress) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAddress) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAddress) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeAddress) Must() Address {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Address)(&_Address{})
var _ schema.TypedNode = (Address)(&_Address{})

func (Address) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Address) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.LookupByString("")
}
func (Address) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.LookupByNode(nil)
}
func (Address) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.LookupByIndex(0)
}
func (Address) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.LookupBySegment(seg)
}
func (Address) MapIterator() ipld.MapIterator {
	return nil
}
func (Address) ListIterator() ipld.ListIterator {
	return nil
}
func (Address) Length() int64 {
	return -1
}
func (Address) IsAbsent() bool {
	return false
}
func (Address) IsNull() bool {
	return false
}
func (Address) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.AsBool()
}
func (Address) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.AsInt()
}
func (Address) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.AsFloat()
}
func (Address) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.AsString()
}
func (n Address) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Address) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Address"}.AsLink()
}
func (Address) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}

type _Address__Prototype struct{}

func (_Address__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Address__Builder
	nb.Reset()
	return &nb
}

type _Address__Builder struct {
	_Address__Assembler
}

func (nb *_Address__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Address__Builder) Reset() {
	var w _Address
	var m schema.Maybe
	*nb = _Address__Builder{_Address__Assembler{w: &w, m: &m}}
}

type _Address__Assembler struct {
	w *_Address
	m *schema.Maybe
}

func (na *_Address__Assembler) reset() {}
func (_Address__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.BeginMap(0)
}
func (_Address__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.BeginList(0)
}
func (na *_Address__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Address__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignBool(false)
}
func (_Address__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignInt(0)
}
func (_Address__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignFloat(0)
}
func (_Address__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignString("")
}
func (na *_Address__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Address__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Address"}.AssignLink(nil)
}
func (na *_Address__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Address); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Address__Assembler) Prototype() ipld.NodePrototype {
	return _Address__Prototype{}
}
func (Address) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Address) Representation() ipld.Node {
	return (*_Address__Repr)(n)
}

type _Address__Repr = _Address

var _ ipld.Node = &_Address__Repr{}

type _Address__ReprPrototype = _Address__Prototype
type _Address__ReprAssembler = _Address__Assembler

func (n Balance) Bytes() []byte {
	return n.x
}
func (_Balance__Prototype) FromBytes(v []byte) (Balance, error) {
	n := _Balance{v}
	return &n, nil
}

type _Balance__Maybe struct {
	m schema.Maybe
	v _Balance
}
type MaybeBalance = *_Balance__Maybe

func (m MaybeBalance) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBalance) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBalance) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBalance) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBalance) Must() Balance {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Balance)(&_Balance{})
var _ schema.TypedNode = (Balance)(&_Balance{})

func (Balance) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Balance) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.LookupByString("")
}
func (Balance) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.LookupByNode(nil)
}
func (Balance) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.LookupByIndex(0)
}
func (Balance) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.LookupBySegment(seg)
}
func (Balance) MapIterator() ipld.MapIterator {
	return nil
}
func (Balance) ListIterator() ipld.ListIterator {
	return nil
}
func (Balance) Length() int64 {
	return -1
}
func (Balance) IsAbsent() bool {
	return false
}
func (Balance) IsNull() bool {
	return false
}
func (Balance) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.AsBool()
}
func (Balance) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.AsInt()
}
func (Balance) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.AsFloat()
}
func (Balance) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.AsString()
}
func (n Balance) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Balance) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Balance"}.AsLink()
}
func (Balance) Prototype() ipld.NodePrototype {
	return _Balance__Prototype{}
}

type _Balance__Prototype struct{}

func (_Balance__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Balance__Builder
	nb.Reset()
	return &nb
}

type _Balance__Builder struct {
	_Balance__Assembler
}

func (nb *_Balance__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Balance__Builder) Reset() {
	var w _Balance
	var m schema.Maybe
	*nb = _Balance__Builder{_Balance__Assembler{w: &w, m: &m}}
}

type _Balance__Assembler struct {
	w *_Balance
	m *schema.Maybe
}

func (na *_Balance__Assembler) reset() {}
func (_Balance__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.BeginMap(0)
}
func (_Balance__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.BeginList(0)
}
func (na *_Balance__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Balance__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignBool(false)
}
func (_Balance__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignInt(0)
}
func (_Balance__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignFloat(0)
}
func (_Balance__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignString("")
}
func (na *_Balance__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Balance__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Balance"}.AssignLink(nil)
}
func (na *_Balance__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Balance); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Balance__Assembler) Prototype() ipld.NodePrototype {
	return _Balance__Prototype{}
}
func (Balance) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Balance) Representation() ipld.Node {
	return (*_Balance__Repr)(n)
}

type _Balance__Repr = _Balance

var _ ipld.Node = &_Balance__Repr{}

type _Balance__ReprPrototype = _Balance__Prototype
type _Balance__ReprAssembler = _Balance__Assembler

func (n BigInt) Bytes() []byte {
	return n.x
}
func (_BigInt__Prototype) FromBytes(v []byte) (BigInt, error) {
	n := _BigInt{v}
	return &n, nil
}

type _BigInt__Maybe struct {
	m schema.Maybe
	v _BigInt
}
type MaybeBigInt = *_BigInt__Maybe

func (m MaybeBigInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBigInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBigInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBigInt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBigInt) Must() BigInt {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (BigInt)(&_BigInt{})
var _ schema.TypedNode = (BigInt)(&_BigInt{})

func (BigInt) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (BigInt) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.LookupByString("")
}
func (BigInt) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.LookupByNode(nil)
}
func (BigInt) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.LookupByIndex(0)
}
func (BigInt) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.LookupBySegment(seg)
}
func (BigInt) MapIterator() ipld.MapIterator {
	return nil
}
func (BigInt) ListIterator() ipld.ListIterator {
	return nil
}
func (BigInt) Length() int64 {
	return -1
}
func (BigInt) IsAbsent() bool {
	return false
}
func (BigInt) IsNull() bool {
	return false
}
func (BigInt) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.AsBool()
}
func (BigInt) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.AsInt()
}
func (BigInt) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.AsFloat()
}
func (BigInt) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.AsString()
}
func (n BigInt) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (BigInt) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.BigInt"}.AsLink()
}
func (BigInt) Prototype() ipld.NodePrototype {
	return _BigInt__Prototype{}
}

type _BigInt__Prototype struct{}

func (_BigInt__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _BigInt__Builder
	nb.Reset()
	return &nb
}

type _BigInt__Builder struct {
	_BigInt__Assembler
}

func (nb *_BigInt__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_BigInt__Builder) Reset() {
	var w _BigInt
	var m schema.Maybe
	*nb = _BigInt__Builder{_BigInt__Assembler{w: &w, m: &m}}
}

type _BigInt__Assembler struct {
	w *_BigInt
	m *schema.Maybe
}

func (na *_BigInt__Assembler) reset() {}
func (_BigInt__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.BeginMap(0)
}
func (_BigInt__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.BeginList(0)
}
func (na *_BigInt__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_BigInt__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignBool(false)
}
func (_BigInt__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignInt(0)
}
func (_BigInt__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignFloat(0)
}
func (_BigInt__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignString("")
}
func (na *_BigInt__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_BigInt__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.BigInt"}.AssignLink(nil)
}
func (na *_BigInt__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_BigInt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_BigInt__Assembler) Prototype() ipld.NodePrototype {
	return _BigInt__Prototype{}
}
func (BigInt) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n BigInt) Representation() ipld.Node {
	return (*_BigInt__Repr)(n)
}

type _BigInt__Repr = _BigInt

var _ ipld.Node = &_BigInt__Repr{}

type _BigInt__ReprPrototype = _BigInt__Prototype
type _BigInt__ReprAssembler = _BigInt__Assembler

func (n _Block) FieldHeader() Link {
	return &n.Header
}
func (n _Block) FieldTransactions() Link {
	return &n.Transactions
}
func (n _Block) FieldReceipts() Link {
	return &n.Receipts
}

type _Block__Maybe struct {
	m schema.Maybe
	v Block
}
type MaybeBlock = *_Block__Maybe

func (m MaybeBlock) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBlock) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBlock) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBlock) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBlock) Must() Block {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Block_Header       = _String{"Header"}
	fieldName__Block_Transactions = _String{"Transactions"}
	fieldName__Block_Receipts     = _String{"Receipts"}
)
var _ ipld.Node = (Block)(&_Block{})
var _ schema.TypedNode = (Block)(&_Block{})

func (Block) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Block) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return &n.Header, nil
	case "Transactions":
		return &n.Transactions, nil
	case "Receipts":
		return &n.Receipts, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Block) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Block) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Block"}.LookupByIndex(0)
}
func (n Block) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Block) MapIterator() ipld.MapIterator {
	return &_Block__MapItr{n, 0}
}

type _Block__MapItr struct {
	n   Block
	idx int
}

func (itr *_Block__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header
		v = &itr.n.Header
	case 1:
		k = &fieldName__Block_Transactions
		v = &itr.n.Transactions
	case 2:
		k = &fieldName__Block_Receipts
		v = &itr.n.Receipts
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__MapItr) Done() bool {
	return itr.idx >= 3
}

func (Block) ListIterator() ipld.ListIterator {
	return nil
}
func (Block) Length() int64 {
	return 3
}
func (Block) IsAbsent() bool {
	return false
}
func (Block) IsNull() bool {
	return false
}
func (Block) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsBool()
}
func (Block) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsInt()
}
func (Block) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsFloat()
}
func (Block) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsString()
}
func (Block) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsBytes()
}
func (Block) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Block"}.AsLink()
}
func (Block) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}

type _Block__Prototype struct{}

func (_Block__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__Builder
	nb.Reset()
	return &nb
}

type _Block__Builder struct {
	_Block__Assembler
}

func (nb *_Block__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__Builder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__Builder{_Block__Assembler{w: &w, m: &m}}
}

type _Block__Assembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_Header       _Link__Assembler
	ca_Transactions _Link__Assembler
	ca_Receipts     _Link__Assembler
}

func (na *_Block__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Transactions.reset()
	na.ca_Receipts.reset()
}

var (
	fieldBit__Block_Header       = 1 << 0
	fieldBit__Block_Transactions = 1 << 1
	fieldBit__Block_Receipts     = 1 << 2
	fieldBits__Block_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_Block__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.BeginList(0)
}
func (na *_Block__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignBool(false)
}
func (_Block__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignInt(0)
}
func (_Block__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignFloat(0)
}
func (_Block__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignString("")
}
func (_Block__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignBytes(nil)
}
func (_Block__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Block"}.AssignLink(nil)
}
func (na *_Block__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Block", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__Assembler) Prototype() ipld.NodePrototype {
	return _Block__Prototype{}
}
func (ma *_Block__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Header.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Transactions.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Receipts.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Transactions":
		if ma.s&fieldBit__Block_Transactions != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Transactions}
		}
		ma.s += fieldBit__Block_Transactions
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Transactions.w = &ma.w.Transactions
		ma.ca_Transactions.m = &ma.cm
		return &ma.ca_Transactions, nil
	case "Receipts":
		if ma.s&fieldBit__Block_Receipts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Receipts}
		}
		ma.s += fieldBit__Block_Receipts
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Receipts.w = &ma.w.Receipts
		ma.ca_Receipts.m = &ma.cm
		return &ma.ca_Receipts, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Block", Key: &_String{k}}
}
func (ma *_Block__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__KeyAssembler)(ma)
}
func (ma *_Block__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Transactions.w = &ma.w.Transactions
		ma.ca_Transactions.m = &ma.cm
		return &ma.ca_Transactions
	case 2:
		ma.ca_Receipts.w = &ma.w.Receipts
		ma.ca_Receipts.m = &ma.cm
		return &ma.ca_Receipts
	default:
		panic("unreachable")
	}
}
func (ma *_Block__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Transactions == 0 {
			err.Missing = append(err.Missing, "Transactions")
		}
		if ma.s&fieldBit__Block_Receipts == 0 {
			err.Missing = append(err.Missing, "Receipts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Block__KeyAssembler _Block__Assembler

func (_Block__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.BeginMap(0)
}
func (_Block__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.BeginList(0)
}
func (na *_Block__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignNull()
}
func (_Block__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignBool(false)
}
func (_Block__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignInt(0)
}
func (_Block__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
	case "Transactions":
		if ka.s&fieldBit__Block_Transactions != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Transactions}
		}
		ka.s += fieldBit__Block_Transactions
		ka.state = maState_expectValue
		ka.f = 1
	case "Receipts":
		if ka.s&fieldBit__Block_Receipts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Receipts}
		}
		ka.s += fieldBit__Block_Receipts
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Block", Key: &_String{k}}
	}
	return nil
}
func (_Block__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Block) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Block) Representation() ipld.Node {
	return (*_Block__Repr)(n)
}

type _Block__Repr _Block

var (
	fieldName__Block_Header_serial       = _String{"Header"}
	fieldName__Block_Transactions_serial = _String{"Transactions"}
	fieldName__Block_Receipts_serial     = _String{"Receipts"}
)
var _ ipld.Node = &_Block__Repr{}

func (_Block__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Block__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Header":
		return n.Header.Representation(), nil
	case "Transactions":
		return n.Transactions.Representation(), nil
	case "Receipts":
		return n.Receipts.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Block__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Block__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.LookupByIndex(0)
}
func (n _Block__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Block__Repr) MapIterator() ipld.MapIterator {
	return &_Block__ReprMapItr{n, 0}
}

type _Block__ReprMapItr struct {
	n   *_Block__Repr
	idx int
}

func (itr *_Block__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Block_Header_serial
		v = itr.n.Header.Representation()
	case 1:
		k = &fieldName__Block_Transactions_serial
		v = itr.n.Transactions.Representation()
	case 2:
		k = &fieldName__Block_Receipts_serial
		v = itr.n.Receipts.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Block__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_Block__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Block__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_Block__Repr) IsAbsent() bool {
	return false
}
func (_Block__Repr) IsNull() bool {
	return false
}
func (_Block__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsBool()
}
func (_Block__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsInt()
}
func (_Block__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsFloat()
}
func (_Block__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsString()
}
func (_Block__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsBytes()
}
func (_Block__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Block.Repr"}.AsLink()
}
func (_Block__Repr) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}

type _Block__ReprPrototype struct{}

func (_Block__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Block__ReprBuilder
	nb.Reset()
	return &nb
}

type _Block__ReprBuilder struct {
	_Block__ReprAssembler
}

func (nb *_Block__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Block__ReprBuilder) Reset() {
	var w _Block
	var m schema.Maybe
	*nb = _Block__ReprBuilder{_Block__ReprAssembler{w: &w, m: &m}}
}

type _Block__ReprAssembler struct {
	w     *_Block
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_Header       _Link__ReprAssembler
	ca_Transactions _Link__ReprAssembler
	ca_Receipts     _Link__ReprAssembler
}

func (na *_Block__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Header.reset()
	na.ca_Transactions.reset()
	na.ca_Receipts.reset()
}
func (na *_Block__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Block{}
	}
	return na, nil
}
func (_Block__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.BeginList(0)
}
func (na *_Block__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Block.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Block__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignBool(false)
}
func (_Block__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignInt(0)
}
func (_Block__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignFloat(0)
}
func (_Block__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignString("")
}
func (_Block__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignBytes(nil)
}
func (_Block__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Block.Repr"}.AssignLink(nil)
}
func (na *_Block__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Block); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Block.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Block__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Block__ReprPrototype{}
}
func (ma *_Block__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Header":
		if ma.s&fieldBit__Block_Header != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ma.s += fieldBit__Block_Header
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header, nil
	case "Transactions":
		if ma.s&fieldBit__Block_Transactions != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Transactions_serial}
		}
		ma.s += fieldBit__Block_Transactions
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Transactions.w = &ma.w.Transactions
		ma.ca_Transactions.m = &ma.cm
		return &ma.ca_Transactions, nil
	case "Receipts":
		if ma.s&fieldBit__Block_Receipts != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Receipts_serial}
		}
		ma.s += fieldBit__Block_Receipts
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Receipts.w = &ma.w.Receipts
		ma.ca_Receipts.m = &ma.cm
		return &ma.ca_Receipts, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Block.Repr", Key: &_String{k}}
}
func (ma *_Block__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Block__ReprKeyAssembler)(ma)
}
func (ma *_Block__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Header.w = &ma.w.Header
		ma.ca_Header.m = &ma.cm
		return &ma.ca_Header
	case 1:
		ma.ca_Transactions.w = &ma.w.Transactions
		ma.ca_Transactions.m = &ma.cm
		return &ma.ca_Transactions
	case 2:
		ma.ca_Receipts.w = &ma.w.Receipts
		ma.ca_Receipts.m = &ma.cm
		return &ma.ca_Receipts
	default:
		panic("unreachable")
	}
}
func (ma *_Block__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Block_sufficient != fieldBits__Block_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Block_Header == 0 {
			err.Missing = append(err.Missing, "Header")
		}
		if ma.s&fieldBit__Block_Transactions == 0 {
			err.Missing = append(err.Missing, "Transactions")
		}
		if ma.s&fieldBit__Block_Receipts == 0 {
			err.Missing = append(err.Missing, "Receipts")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Block__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Block__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Block__ReprKeyAssembler _Block__ReprAssembler

func (_Block__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Block__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Block__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignNull()
}
func (_Block__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Block__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Block__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Block__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Header":
		if ka.s&fieldBit__Block_Header != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Header_serial}
		}
		ka.s += fieldBit__Block_Header
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Transactions":
		if ka.s&fieldBit__Block_Transactions != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Transactions_serial}
		}
		ka.s += fieldBit__Block_Transactions
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Receipts":
		if ka.s&fieldBit__Block_Receipts != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Block_Receipts_serial}
		}
		ka.s += fieldBit__Block_Receipts
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Block.Repr", Key: &_String{k}}
}
func (_Block__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Block__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Block.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Block__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Block__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Bloom) Bytes() []byte {
	return n.x
}
func (_Bloom__Prototype) FromBytes(v []byte) (Bloom, error) {
	n := _Bloom{v}
	return &n, nil
}

type _Bloom__Maybe struct {
	m schema.Maybe
	v _Bloom
}
type MaybeBloom = *_Bloom__Maybe

func (m MaybeBloom) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBloom) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBloom) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBloom) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBloom) Must() Bloom {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Bloom)(&_Bloom{})
var _ schema.TypedNode = (Bloom)(&_Bloom{})

func (Bloom) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bloom) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.LookupByString("")
}
func (Bloom) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.LookupByNode(nil)
}
func (Bloom) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.LookupByIndex(0)
}
func (Bloom) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.LookupBySegment(seg)
}
func (Bloom) MapIterator() ipld.MapIterator {
	return nil
}
func (Bloom) ListIterator() ipld.ListIterator {
	return nil
}
func (Bloom) Length() int64 {
	return -1
}
func (Bloom) IsAbsent() bool {
	return false
}
func (Bloom) IsNull() bool {
	return false
}
func (Bloom) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.AsBool()
}
func (Bloom) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.AsInt()
}
func (Bloom) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.AsFloat()
}
func (Bloom) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.AsString()
}
func (n Bloom) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bloom) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Bloom"}.AsLink()
}
func (Bloom) Prototype() ipld.NodePrototype {
	return _Bloom__Prototype{}
}

type _Bloom__Prototype struct{}

func (_Bloom__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bloom__Builder
	nb.Reset()
	return &nb
}

type _Bloom__Builder struct {
	_Bloom__Assembler
}

func (nb *_Bloom__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bloom__Builder) Reset() {
	var w _Bloom
	var m schema.Maybe
	*nb = _Bloom__Builder{_Bloom__Assembler{w: &w, m: &m}}
}

type _Bloom__Assembler struct {
	w *_Bloom
	m *schema.Maybe
}

func (na *_Bloom__Assembler) reset() {}
func (_Bloom__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.BeginMap(0)
}
func (_Bloom__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.BeginList(0)
}
func (na *_Bloom__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bloom__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignBool(false)
}
func (_Bloom__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignInt(0)
}
func (_Bloom__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignFloat(0)
}
func (_Bloom__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignString("")
}
func (na *_Bloom__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bloom__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bloom"}.AssignLink(nil)
}
func (na *_Bloom__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bloom); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bloom__Assembler) Prototype() ipld.NodePrototype {
	return _Bloom__Prototype{}
}
func (Bloom) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bloom) Representation() ipld.Node {
	return (*_Bloom__Repr)(n)
}

type _Bloom__Repr = _Bloom

var _ ipld.Node = &_Bloom__Repr{}

type _Bloom__ReprPrototype = _Bloom__Prototype
type _Bloom__ReprAssembler = _Bloom__Assembler

func (n Bool) Bool() bool {
	return n.x
}
func (_Bool__Prototype) FromBool(v bool) (Bool, error) {
	n := _Bool{v}
	return &n, nil
}

type _Bool__Maybe struct {
	m schema.Maybe
	v _Bool
}
type MaybeBool = *_Bool__Maybe

func (m MaybeBool) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBool) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBool) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBool) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBool) Must() Bool {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Bool)(&_Bool{})
var _ schema.TypedNode = (Bool)(&_Bool{})

func (Bool) Kind() ipld.Kind {
	return ipld.Kind_Bool
}
func (Bool) LookupByString(string) (ipld.Node, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.LookupByString("")
}
func (Bool) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.LookupByNode(nil)
}
func (Bool) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.LookupByIndex(0)
}
func (Bool) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.LookupBySegment(seg)
}
func (Bool) MapIterator() ipld.MapIterator {
	return nil
}
func (Bool) ListIterator() ipld.ListIterator {
	return nil
}
func (Bool) Length() int64 {
	return -1
}
func (Bool) IsAbsent() bool {
	return false
}
func (Bool) IsNull() bool {
	return false
}
func (n Bool) AsBool() (bool, error) {
	return n.x, nil
}
func (Bool) AsInt() (int64, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.AsInt()
}
func (Bool) AsFloat() (float64, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.AsFloat()
}
func (Bool) AsString() (string, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.AsString()
}
func (Bool) AsBytes() ([]byte, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.AsBytes()
}
func (Bool) AsLink() (ipld.Link, error) {
	return mixins.Bool{TypeName: "dageth.Bool"}.AsLink()
}
func (Bool) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}

type _Bool__Prototype struct{}

func (_Bool__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bool__Builder
	nb.Reset()
	return &nb
}

type _Bool__Builder struct {
	_Bool__Assembler
}

func (nb *_Bool__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bool__Builder) Reset() {
	var w _Bool
	var m schema.Maybe
	*nb = _Bool__Builder{_Bool__Assembler{w: &w, m: &m}}
}

type _Bool__Assembler struct {
	w *_Bool
	m *schema.Maybe
}

func (na *_Bool__Assembler) reset() {}
func (_Bool__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.BeginMap(0)
}
func (_Bool__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.BeginList(0)
}
func (na *_Bool__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (na *_Bool__Assembler) AssignBool(v bool) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bool__Assembler) AssignInt(int64) error {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignInt(0)
}
func (_Bool__Assembler) AssignFloat(float64) error {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignFloat(0)
}
func (_Bool__Assembler) AssignString(string) error {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignString("")
}
func (_Bool__Assembler) AssignBytes([]byte) error {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignBytes(nil)
}
func (_Bool__Assembler) AssignLink(ipld.Link) error {
	return mixins.BoolAssembler{TypeName: "dageth.Bool"}.AssignLink(nil)
}
func (na *_Bool__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bool); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBool(); err != nil {
		return err
	} else {
		return na.AssignBool(v2)
	}
}
func (_Bool__Assembler) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}
func (Bool) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bool) Representation() ipld.Node {
	return (*_Bool__Repr)(n)
}

type _Bool__Repr = _Bool

var _ ipld.Node = &_Bool__Repr{}

type _Bool__ReprPrototype = _Bool__Prototype
type _Bool__ReprAssembler = _Bool__Assembler

func (n ByteCode) Bytes() []byte {
	return n.x
}
func (_ByteCode__Prototype) FromBytes(v []byte) (ByteCode, error) {
	n := _ByteCode{v}
	return &n, nil
}

type _ByteCode__Maybe struct {
	m schema.Maybe
	v _ByteCode
}
type MaybeByteCode = *_ByteCode__Maybe

func (m MaybeByteCode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeByteCode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeByteCode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeByteCode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeByteCode) Must() ByteCode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (ByteCode)(&_ByteCode{})
var _ schema.TypedNode = (ByteCode)(&_ByteCode{})

func (ByteCode) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (ByteCode) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.LookupByString("")
}
func (ByteCode) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.LookupByNode(nil)
}
func (ByteCode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.LookupByIndex(0)
}
func (ByteCode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.LookupBySegment(seg)
}
func (ByteCode) MapIterator() ipld.MapIterator {
	return nil
}
func (ByteCode) ListIterator() ipld.ListIterator {
	return nil
}
func (ByteCode) Length() int64 {
	return -1
}
func (ByteCode) IsAbsent() bool {
	return false
}
func (ByteCode) IsNull() bool {
	return false
}
func (ByteCode) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.AsBool()
}
func (ByteCode) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.AsInt()
}
func (ByteCode) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.AsFloat()
}
func (ByteCode) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.AsString()
}
func (n ByteCode) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (ByteCode) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.ByteCode"}.AsLink()
}
func (ByteCode) Prototype() ipld.NodePrototype {
	return _ByteCode__Prototype{}
}

type _ByteCode__Prototype struct{}

func (_ByteCode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _ByteCode__Builder
	nb.Reset()
	return &nb
}

type _ByteCode__Builder struct {
	_ByteCode__Assembler
}

func (nb *_ByteCode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_ByteCode__Builder) Reset() {
	var w _ByteCode
	var m schema.Maybe
	*nb = _ByteCode__Builder{_ByteCode__Assembler{w: &w, m: &m}}
}

type _ByteCode__Assembler struct {
	w *_ByteCode
	m *schema.Maybe
}

func (na *_ByteCode__Assembler) reset() {}
func (_ByteCode__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.BeginMap(0)
}
func (_ByteCode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.BeginList(0)
}
func (na *_ByteCode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_ByteCode__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignBool(false)
}
func (_ByteCode__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignInt(0)
}
func (_ByteCode__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignFloat(0)
}
func (_ByteCode__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignString("")
}
func (na *_ByteCode__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_ByteCode__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.ByteCode"}.AssignLink(nil)
}
func (na *_ByteCode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_ByteCode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_ByteCode__Assembler) Prototype() ipld.NodePrototype {
	return _ByteCode__Prototype{}
}
func (ByteCode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n ByteCode) Representation() ipld.Node {
	return (*_ByteCode__Repr)(n)
}

type _ByteCode__Repr = _ByteCode

var _ ipld.Node = &_ByteCode__Repr{}

type _ByteCode__ReprPrototype = _ByteCode__Prototype
type _ByteCode__ReprAssembler = _ByteCode__Assembler

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}

type _Bytes__Maybe struct {
	m schema.Maybe
	v _Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})

func (Bytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int64 {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}

type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}

type _Bytes__Builder struct {
	_Bytes__Assembler
}

func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}

type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}

type _Bytes__Repr = _Bytes

var _ ipld.Node = &_Bytes__Repr{}

type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler

func (n _Child) AsInterface() _Child__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _Child__Maybe struct {
	m schema.Maybe
	v Child
}
type MaybeChild = *_Child__Maybe

func (m MaybeChild) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeChild) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeChild) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeChild) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeChild) Must() Child {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__Child_Link     = _String{"Link"}
	memberName__Child_TrieNode = _String{"TrieNode"}
)
var _ ipld.Node = (Child)(&_Child{})
var _ schema.TypedNode = (Child)(&_Child{})

func (Child) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Child) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Link":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "TrieNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Child) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Child) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Child"}.LookupByIndex(0)
}
func (n Child) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Child) MapIterator() ipld.MapIterator {
	return &_Child__MapItr{n, false}
}

type _Child__MapItr struct {
	n    Child
	done bool
}

func (itr *_Child__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Child_Link, &itr.n.x1
	case 2:
		k, v = &memberName__Child_TrieNode, &itr.n.x2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Child__MapItr) Done() bool {
	return itr.done
}

func (Child) ListIterator() ipld.ListIterator {
	return nil
}
func (Child) Length() int64 {
	return 1
}
func (Child) IsAbsent() bool {
	return false
}
func (Child) IsNull() bool {
	return false
}
func (Child) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsBool()
}
func (Child) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsInt()
}
func (Child) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsFloat()
}
func (Child) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsString()
}
func (Child) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsBytes()
}
func (Child) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Child"}.AsLink()
}
func (Child) Prototype() ipld.NodePrototype {
	return _Child__Prototype{}
}

type _Child__Prototype struct{}

func (_Child__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Child__Builder
	nb.Reset()
	return &nb
}

type _Child__Builder struct {
	_Child__Assembler
}

func (nb *_Child__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Child__Builder) Reset() {
	var w _Child
	var m schema.Maybe
	*nb = _Child__Builder{_Child__Assembler{w: &w, m: &m}}
}

type _Child__Assembler struct {
	w     *_Child
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _Link__Assembler

	ca2 *_TrieNode__Assembler
	ca  uint
}

func (na *_Child__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Child__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Child{}
	}
	return na, nil
}
func (_Child__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.BeginList(0)
}
func (na *_Child__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Child__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignBool(false)
}
func (_Child__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignInt(0)
}
func (_Child__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignFloat(0)
}
func (_Child__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignString("")
}
func (_Child__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignBytes(nil)
}
func (_Child__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Child"}.AssignLink(nil)
}
func (na *_Child__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Child); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Child", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Child__Assembler) Prototype() ipld.NodePrototype {
	return _Child__Prototype{}
}
func (ma *_Child__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Child__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.Child", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Link":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "TrieNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return ma.ca2, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Child", Key: &_String{k}}
}
func (ma *_Child__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Child__KeyAssembler)(ma)
}
func (ma *_Child__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 1:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 2:
		if ma.ca2 == nil {
			ma.ca2 = new(_TrieNode__Assembler)
		}
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return ma.ca2
	default:
		panic("unreachable")
	}
}
func (ma *_Child__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Child", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Child__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Child__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "Link":
		return _Link__Prototype{}
	case "TrieNode":
		return _TrieNode__Prototype{}
	default:
		return nil
	}
}

type _Child__KeyAssembler _Child__Assembler

func (_Child__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.BeginMap(0)
}
func (_Child__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.BeginList(0)
}
func (na *_Child__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignNull()
}
func (_Child__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignBool(false)
}
func (_Child__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignInt(0)
}
func (_Child__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Child__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Child", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Link":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "TrieNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Child", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Child__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignBytes(nil)
}
func (_Child__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Child.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Child__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Child__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Child) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Child) Representation() ipld.Node {
	return (*_Child__Repr)(n)
}

type _Child__Repr _Child

var _ ipld.Node = &_Child__Repr{}

func (n *_Child__Repr) Kind() ipld.Kind {
	switch n.tag {
	case 1:
		return ipld.Kind_Link
	case 2:
		return ipld.Kind_Map
	default:
		panic("unreachable")
	}
}
func (n *_Child__Repr) LookupByString(key string) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupByString(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "LookupByString", AppropriateKind: ipld.KindSet_JustMap, ActualKind: n.Kind()}
	}
}
func (n *_Child__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupByNode(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "LookupByNode", AppropriateKind: ipld.KindSet_Recursive, ActualKind: n.Kind()}
	}
}
func (n *_Child__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "LookupByIndex", AppropriateKind: ipld.KindSet_JustList, ActualKind: n.Kind()}
}
func (n *_Child__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	switch n.tag {
	case 2:
		return n.x2.Representation().LookupBySegment(seg)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "LookupBySegment", AppropriateKind: ipld.KindSet_Recursive, ActualKind: n.Kind()}
	}
}
func (n *_Child__Repr) MapIterator() ipld.MapIterator {
	switch n.tag {
	case 2:
		return n.x2.Representation().MapIterator()
	default:
		return nil
	}
}
func (n *_Child__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (n *_Child__Repr) Length() int64 {
	switch n.tag {
	case 2:
		return n.x2.Representation().Length()
	default:
		return -1
	}
}
func (n *_Child__Repr) IsAbsent() bool {
	return false
}
func (n *_Child__Repr) IsNull() bool {
	return false
}
func (n *_Child__Repr) AsBool() (bool, error) {
	return false, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsBool", AppropriateKind: ipld.KindSet_JustBool, ActualKind: n.Kind()}
}
func (n *_Child__Repr) AsInt() (int64, error) {
	return 0, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsInt", AppropriateKind: ipld.KindSet_JustInt, ActualKind: n.Kind()}
}
func (n *_Child__Repr) AsFloat() (float64, error) {
	return 0, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsFloat", AppropriateKind: ipld.KindSet_JustFloat, ActualKind: n.Kind()}
}
func (n *_Child__Repr) AsString() (string, error) {
	return "", ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsString", AppropriateKind: ipld.KindSet_JustString, ActualKind: n.Kind()}
}
func (n *_Child__Repr) AsBytes() ([]byte, error) {
	return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsBytes", AppropriateKind: ipld.KindSet_JustBytes, ActualKind: n.Kind()}
}
func (n *_Child__Repr) AsLink() (ipld.Link, error) {
	switch n.tag {
	case 1:
		return n.x1.Representation().AsLink()
	default:
		return nil, ipld.ErrWrongKind{TypeName: "dageth.Child.Repr", MethodName: "AsLink", AppropriateKind: ipld.KindSet_JustLink, ActualKind: n.Kind()}
	}
}
func (_Child__Repr) Prototype() ipld.NodePrototype {
	return _Child__ReprPrototype{}
}

type _Child__ReprPrototype struct{}

func (_Child__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Child__ReprBuilder
	nb.Reset()
	return &nb
}

type _Child__ReprBuilder struct {
	_Child__ReprAssembler
}

func (nb *_Child__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Child__ReprBuilder) Reset() {
	var w _Child
	var m schema.Maybe
	*nb = _Child__ReprBuilder{_Child__ReprAssembler{w: &w, m: &m}}
}

type _Child__ReprAssembler struct {
	w   *_Child
	m   *schema.Maybe
	ca1 _Link__ReprAssembler
	ca2 *_TrieNode__ReprAssembler
	ca  uint
}

func (na *_Child__ReprAssembler) reset() {
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	case 2:
		na.ca2.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
}
func (na *_Child__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Child{}
	}
	na.ca = 2
	na.w.tag = 2
	na.ca2.w = &na.w.x2
	na.ca2.m = na.m
	return na.ca2.BeginMap(sizeHint)
}
func (na *_Child__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return nil, schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "BeginList called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignNull() error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignNull called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignBool(v bool) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignBool called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignInt called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignFloat(v float64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignFloat called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignString called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return schema.ErrNotUnionStructure{TypeName: "dageth.Child.Repr", Detail: "AssignBytes called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Child__ReprAssembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Child{}
	}
	na.ca = 1
	na.w.tag = 1
	na.ca1.w = &na.w.x1
	na.ca1.m = na.m
	return na.ca1.AssignLink(v)
}
func (na *_Child__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Child); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	switch v.Kind() {
	case ipld.Kind_Bool:
		v2, _ := v.AsBool()
		return na.AssignBool(v2)
	case ipld.Kind_Int:
		v2, _ := v.AsInt()
		return na.AssignInt(v2)
	case ipld.Kind_Float:
		v2, _ := v.AsFloat()
		return na.AssignFloat(v2)
	case ipld.Kind_String:
		v2, _ := v.AsString()
		return na.AssignString(v2)
	case ipld.Kind_Bytes:
		v2, _ := v.AsBytes()
		return na.AssignBytes(v2)
	case ipld.Kind_Map:
		na, err := na.BeginMap(v.Length())
		if err != nil {
			return err
		}
		itr := v.MapIterator()
		for !itr.Done() {
			k, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleKey().AssignNode(k); err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.Kind_List:
		na, err := na.BeginList(v.Length())
		if err != nil {
			return err
		}
		itr := v.ListIterator()
		for !itr.Done() {
			_, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.Kind_Link:
		v2, _ := v.AsLink()
		return na.AssignLink(v2)
	default:
		panic("unreachable")
	}
}
func (na *_Child__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Child__ReprPrototype{}
}

func (n _Frame) FieldOp() OpCode {
	return &n.Op
}
func (n _Frame) FieldFrom() Address {
	return &n.From
}
func (n _Frame) FieldTo() Address {
	return &n.To
}
func (n _Frame) FieldInput() Bytes {
	return &n.Input
}
func (n _Frame) FieldOutput() Bytes {
	return &n.Output
}
func (n _Frame) FieldGas() Uint {
	return &n.Gas
}
func (n _Frame) FieldCost() Uint {
	return &n.Cost
}
func (n _Frame) FieldValue() BigInt {
	return &n.Value
}

type _Frame__Maybe struct {
	m schema.Maybe
	v Frame
}
type MaybeFrame = *_Frame__Maybe

func (m MaybeFrame) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFrame) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFrame) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFrame) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeFrame) Must() Frame {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Frame_Op     = _String{"Op"}
	fieldName__Frame_From   = _String{"From"}
	fieldName__Frame_To     = _String{"To"}
	fieldName__Frame_Input  = _String{"Input"}
	fieldName__Frame_Output = _String{"Output"}
	fieldName__Frame_Gas    = _String{"Gas"}
	fieldName__Frame_Cost   = _String{"Cost"}
	fieldName__Frame_Value  = _String{"Value"}
)
var _ ipld.Node = (Frame)(&_Frame{})
var _ schema.TypedNode = (Frame)(&_Frame{})

func (Frame) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Frame) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Op":
		return &n.Op, nil
	case "From":
		return &n.From, nil
	case "To":
		return &n.To, nil
	case "Input":
		return &n.Input, nil
	case "Output":
		return &n.Output, nil
	case "Gas":
		return &n.Gas, nil
	case "Cost":
		return &n.Cost, nil
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Frame) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Frame) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.LookupByIndex(0)
}
func (n Frame) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Frame) MapIterator() ipld.MapIterator {
	return &_Frame__MapItr{n, 0}
}

type _Frame__MapItr struct {
	n   Frame
	idx int
}

func (itr *_Frame__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Frame_Op
		v = &itr.n.Op
	case 1:
		k = &fieldName__Frame_From
		v = &itr.n.From
	case 2:
		k = &fieldName__Frame_To
		v = &itr.n.To
	case 3:
		k = &fieldName__Frame_Input
		v = &itr.n.Input
	case 4:
		k = &fieldName__Frame_Output
		v = &itr.n.Output
	case 5:
		k = &fieldName__Frame_Gas
		v = &itr.n.Gas
	case 6:
		k = &fieldName__Frame_Cost
		v = &itr.n.Cost
	case 7:
		k = &fieldName__Frame_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Frame__MapItr) Done() bool {
	return itr.idx >= 8
}

func (Frame) ListIterator() ipld.ListIterator {
	return nil
}
func (Frame) Length() int64 {
	return 8
}
func (Frame) IsAbsent() bool {
	return false
}
func (Frame) IsNull() bool {
	return false
}
func (Frame) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsBool()
}
func (Frame) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsInt()
}
func (Frame) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsFloat()
}
func (Frame) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsString()
}
func (Frame) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsBytes()
}
func (Frame) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Frame"}.AsLink()
}
func (Frame) Prototype() ipld.NodePrototype {
	return _Frame__Prototype{}
}

type _Frame__Prototype struct{}

func (_Frame__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Frame__Builder
	nb.Reset()
	return &nb
}

type _Frame__Builder struct {
	_Frame__Assembler
}

func (nb *_Frame__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Frame__Builder) Reset() {
	var w _Frame
	var m schema.Maybe
	*nb = _Frame__Builder{_Frame__Assembler{w: &w, m: &m}}
}

type _Frame__Assembler struct {
	w     *_Frame
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Op     _OpCode__Assembler
	ca_From   _Address__Assembler
	ca_To     _Address__Assembler
	ca_Input  _Bytes__Assembler
	ca_Output _Bytes__Assembler
	ca_Gas    _Uint__Assembler
	ca_Cost   _Uint__Assembler
	ca_Value  _BigInt__Assembler
}

func (na *_Frame__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Op.reset()
	na.ca_From.reset()
	na.ca_To.reset()
	na.ca_Input.reset()
	na.ca_Output.reset()
	na.ca_Gas.reset()
	na.ca_Cost.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__Frame_Op          = 1 << 0
	fieldBit__Frame_From        = 1 << 1
	fieldBit__Frame_To          = 1 << 2
	fieldBit__Frame_Input       = 1 << 3
	fieldBit__Frame_Output      = 1 << 4
	fieldBit__Frame_Gas         = 1 << 5
	fieldBit__Frame_Cost        = 1 << 6
	fieldBit__Frame_Value       = 1 << 7
	fieldBits__Frame_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7
)

func (na *_Frame__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Frame{}
	}
	return na, nil
}
func (_Frame__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.BeginList(0)
}
func (na *_Frame__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Frame__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignBool(false)
}
func (_Frame__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignInt(0)
}
func (_Frame__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignFloat(0)
}
func (_Frame__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignString("")
}
func (_Frame__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignBytes(nil)
}
func (_Frame__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame"}.AssignLink(nil)
}
func (na *_Frame__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Frame); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Frame", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Frame__Assembler) Prototype() ipld.NodePrototype {
	return _Frame__Prototype{}
}
func (ma *_Frame__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Op.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_From.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_To.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Input.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Output.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Gas.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Cost.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Frame__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Op":
		if ma.s&fieldBit__Frame_Op != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Op}
		}
		ma.s += fieldBit__Frame_Op
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Op.w = &ma.w.Op
		ma.ca_Op.m = &ma.cm
		return &ma.ca_Op, nil
	case "From":
		if ma.s&fieldBit__Frame_From != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_From}
		}
		ma.s += fieldBit__Frame_From
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_From.w = &ma.w.From
		ma.ca_From.m = &ma.cm
		return &ma.ca_From, nil
	case "To":
		if ma.s&fieldBit__Frame_To != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_To}
		}
		ma.s += fieldBit__Frame_To
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_To.w = &ma.w.To
		ma.ca_To.m = &ma.cm
		return &ma.ca_To, nil
	case "Input":
		if ma.s&fieldBit__Frame_Input != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Input}
		}
		ma.s += fieldBit__Frame_Input
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Input.w = &ma.w.Input
		ma.ca_Input.m = &ma.cm
		return &ma.ca_Input, nil
	case "Output":
		if ma.s&fieldBit__Frame_Output != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Output}
		}
		ma.s += fieldBit__Frame_Output
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Output.w = &ma.w.Output
		ma.ca_Output.m = &ma.cm
		return &ma.ca_Output, nil
	case "Gas":
		if ma.s&fieldBit__Frame_Gas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Gas}
		}
		ma.s += fieldBit__Frame_Gas
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas, nil
	case "Cost":
		if ma.s&fieldBit__Frame_Cost != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Cost}
		}
		ma.s += fieldBit__Frame_Cost
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Cost.w = &ma.w.Cost
		ma.ca_Cost.m = &ma.cm
		return &ma.ca_Cost, nil
	case "Value":
		if ma.s&fieldBit__Frame_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Value}
		}
		ma.s += fieldBit__Frame_Value
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Frame", Key: &_String{k}}
}
func (ma *_Frame__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Frame__KeyAssembler)(ma)
}
func (ma *_Frame__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Op.w = &ma.w.Op
		ma.ca_Op.m = &ma.cm
		return &ma.ca_Op
	case 1:
		ma.ca_From.w = &ma.w.From
		ma.ca_From.m = &ma.cm
		return &ma.ca_From
	case 2:
		ma.ca_To.w = &ma.w.To
		ma.ca_To.m = &ma.cm
		return &ma.ca_To
	case 3:
		ma.ca_Input.w = &ma.w.Input
		ma.ca_Input.m = &ma.cm
		return &ma.ca_Input
	case 4:
		ma.ca_Output.w = &ma.w.Output
		ma.ca_Output.m = &ma.cm
		return &ma.ca_Output
	case 5:
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas
	case 6:
		ma.ca_Cost.w = &ma.w.Cost
		ma.ca_Cost.m = &ma.cm
		return &ma.ca_Cost
	case 7:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_Frame__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Frame_sufficient != fieldBits__Frame_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Frame_Op == 0 {
			err.Missing = append(err.Missing, "Op")
		}
		if ma.s&fieldBit__Frame_From == 0 {
			err.Missing = append(err.Missing, "From")
		}
		if ma.s&fieldBit__Frame_To == 0 {
			err.Missing = append(err.Missing, "To")
		}
		if ma.s&fieldBit__Frame_Input == 0 {
			err.Missing = append(err.Missing, "Input")
		}
		if ma.s&fieldBit__Frame_Output == 0 {
			err.Missing = append(err.Missing, "Output")
		}
		if ma.s&fieldBit__Frame_Gas == 0 {
			err.Missing = append(err.Missing, "Gas")
		}
		if ma.s&fieldBit__Frame_Cost == 0 {
			err.Missing = append(err.Missing, "Cost")
		}
		if ma.s&fieldBit__Frame_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Frame__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Frame__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Frame__KeyAssembler _Frame__Assembler

func (_Frame__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.BeginMap(0)
}
func (_Frame__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.BeginList(0)
}
func (na *_Frame__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignNull()
}
func (_Frame__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignBool(false)
}
func (_Frame__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignInt(0)
}
func (_Frame__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Frame__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Op":
		if ka.s&fieldBit__Frame_Op != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Op}
		}
		ka.s += fieldBit__Frame_Op
		ka.state = maState_expectValue
		ka.f = 0
	case "From":
		if ka.s&fieldBit__Frame_From != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_From}
		}
		ka.s += fieldBit__Frame_From
		ka.state = maState_expectValue
		ka.f = 1
	case "To":
		if ka.s&fieldBit__Frame_To != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_To}
		}
		ka.s += fieldBit__Frame_To
		ka.state = maState_expectValue
		ka.f = 2
	case "Input":
		if ka.s&fieldBit__Frame_Input != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Input}
		}
		ka.s += fieldBit__Frame_Input
		ka.state = maState_expectValue
		ka.f = 3
	case "Output":
		if ka.s&fieldBit__Frame_Output != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Output}
		}
		ka.s += fieldBit__Frame_Output
		ka.state = maState_expectValue
		ka.f = 4
	case "Gas":
		if ka.s&fieldBit__Frame_Gas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Gas}
		}
		ka.s += fieldBit__Frame_Gas
		ka.state = maState_expectValue
		ka.f = 5
	case "Cost":
		if ka.s&fieldBit__Frame_Cost != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Cost}
		}
		ka.s += fieldBit__Frame_Cost
		ka.state = maState_expectValue
		ka.f = 6
	case "Value":
		if ka.s&fieldBit__Frame_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Value}
		}
		ka.s += fieldBit__Frame_Value
		ka.state = maState_expectValue
		ka.f = 7
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Frame", Key: &_String{k}}
	}
	return nil
}
func (_Frame__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignBytes(nil)
}
func (_Frame__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Frame__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Frame__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Frame) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Frame) Representation() ipld.Node {
	return (*_Frame__Repr)(n)
}

type _Frame__Repr _Frame

var (
	fieldName__Frame_Op_serial     = _String{"Op"}
	fieldName__Frame_From_serial   = _String{"From"}
	fieldName__Frame_To_serial     = _String{"To"}
	fieldName__Frame_Input_serial  = _String{"Input"}
	fieldName__Frame_Output_serial = _String{"Output"}
	fieldName__Frame_Gas_serial    = _String{"Gas"}
	fieldName__Frame_Cost_serial   = _String{"Cost"}
	fieldName__Frame_Value_serial  = _String{"Value"}
)
var _ ipld.Node = &_Frame__Repr{}

func (_Frame__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Frame__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Op":
		return n.Op.Representation(), nil
	case "From":
		return n.From.Representation(), nil
	case "To":
		return n.To.Representation(), nil
	case "Input":
		return n.Input.Representation(), nil
	case "Output":
		return n.Output.Representation(), nil
	case "Gas":
		return n.Gas.Representation(), nil
	case "Cost":
		return n.Cost.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Frame__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Frame__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.LookupByIndex(0)
}
func (n _Frame__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Frame__Repr) MapIterator() ipld.MapIterator {
	return &_Frame__ReprMapItr{n, 0}
}

type _Frame__ReprMapItr struct {
	n   *_Frame__Repr
	idx int
}

func (itr *_Frame__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Frame_Op_serial
		v = itr.n.Op.Representation()
	case 1:
		k = &fieldName__Frame_From_serial
		v = itr.n.From.Representation()
	case 2:
		k = &fieldName__Frame_To_serial
		v = itr.n.To.Representation()
	case 3:
		k = &fieldName__Frame_Input_serial
		v = itr.n.Input.Representation()
	case 4:
		k = &fieldName__Frame_Output_serial
		v = itr.n.Output.Representation()
	case 5:
		k = &fieldName__Frame_Gas_serial
		v = itr.n.Gas.Representation()
	case 6:
		k = &fieldName__Frame_Cost_serial
		v = itr.n.Cost.Representation()
	case 7:
		k = &fieldName__Frame_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Frame__ReprMapItr) Done() bool {
	return itr.idx >= 8
}
func (_Frame__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Frame__Repr) Length() int64 {
	l := 8
	return int64(l)
}
func (_Frame__Repr) IsAbsent() bool {
	return false
}
func (_Frame__Repr) IsNull() bool {
	return false
}
func (_Frame__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsBool()
}
func (_Frame__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsInt()
}
func (_Frame__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsFloat()
}
func (_Frame__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsString()
}
func (_Frame__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsBytes()
}
func (_Frame__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Frame.Repr"}.AsLink()
}
func (_Frame__Repr) Prototype() ipld.NodePrototype {
	return _Frame__ReprPrototype{}
}

type _Frame__ReprPrototype struct{}

func (_Frame__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Frame__ReprBuilder
	nb.Reset()
	return &nb
}

type _Frame__ReprBuilder struct {
	_Frame__ReprAssembler
}

func (nb *_Frame__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Frame__ReprBuilder) Reset() {
	var w _Frame
	var m schema.Maybe
	*nb = _Frame__ReprBuilder{_Frame__ReprAssembler{w: &w, m: &m}}
}

type _Frame__ReprAssembler struct {
	w     *_Frame
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Op     _OpCode__ReprAssembler
	ca_From   _Address__ReprAssembler
	ca_To     _Address__ReprAssembler
	ca_Input  _Bytes__ReprAssembler
	ca_Output _Bytes__ReprAssembler
	ca_Gas    _Uint__ReprAssembler
	ca_Cost   _Uint__ReprAssembler
	ca_Value  _BigInt__ReprAssembler
}

func (na *_Frame__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Op.reset()
	na.ca_From.reset()
	na.ca_To.reset()
	na.ca_Input.reset()
	na.ca_Output.reset()
	na.ca_Gas.reset()
	na.ca_Cost.reset()
	na.ca_Value.reset()
}
func (na *_Frame__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Frame{}
	}
	return na, nil
}
func (_Frame__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.BeginList(0)
}
func (na *_Frame__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Frame.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Frame__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignBool(false)
}
func (_Frame__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignInt(0)
}
func (_Frame__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignFloat(0)
}
func (_Frame__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignString("")
}
func (_Frame__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignBytes(nil)
}
func (_Frame__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Frame.Repr"}.AssignLink(nil)
}
func (na *_Frame__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Frame); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Frame.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Frame__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Frame__ReprPrototype{}
}
func (ma *_Frame__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Frame__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Op":
		if ma.s&fieldBit__Frame_Op != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Op_serial}
		}
		ma.s += fieldBit__Frame_Op
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Op.w = &ma.w.Op
		ma.ca_Op.m = &ma.cm
		return &ma.ca_Op, nil
	case "From":
		if ma.s&fieldBit__Frame_From != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_From_serial}
		}
		ma.s += fieldBit__Frame_From
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_From.w = &ma.w.From
		ma.ca_From.m = &ma.cm
		return &ma.ca_From, nil
	case "To":
		if ma.s&fieldBit__Frame_To != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_To_serial}
		}
		ma.s += fieldBit__Frame_To
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_To.w = &ma.w.To
		ma.ca_To.m = &ma.cm
		return &ma.ca_To, nil
	case "Input":
		if ma.s&fieldBit__Frame_Input != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Input_serial}
		}
		ma.s += fieldBit__Frame_Input
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Input.w = &ma.w.Input
		ma.ca_Input.m = &ma.cm
		return &ma.ca_Input, nil
	case "Output":
		if ma.s&fieldBit__Frame_Output != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Output_serial}
		}
		ma.s += fieldBit__Frame_Output
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Output.w = &ma.w.Output
		ma.ca_Output.m = &ma.cm
		return &ma.ca_Output, nil
	case "Gas":
		if ma.s&fieldBit__Frame_Gas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Gas_serial}
		}
		ma.s += fieldBit__Frame_Gas
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas, nil
	case "Cost":
		if ma.s&fieldBit__Frame_Cost != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Cost_serial}
		}
		ma.s += fieldBit__Frame_Cost
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Cost.w = &ma.w.Cost
		ma.ca_Cost.m = &ma.cm
		return &ma.ca_Cost, nil
	case "Value":
		if ma.s&fieldBit__Frame_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Value_serial}
		}
		ma.s += fieldBit__Frame_Value
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Frame.Repr", Key: &_String{k}}
}
func (ma *_Frame__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Frame__ReprKeyAssembler)(ma)
}
func (ma *_Frame__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Op.w = &ma.w.Op
		ma.ca_Op.m = &ma.cm
		return &ma.ca_Op
	case 1:
		ma.ca_From.w = &ma.w.From
		ma.ca_From.m = &ma.cm
		return &ma.ca_From
	case 2:
		ma.ca_To.w = &ma.w.To
		ma.ca_To.m = &ma.cm
		return &ma.ca_To
	case 3:
		ma.ca_Input.w = &ma.w.Input
		ma.ca_Input.m = &ma.cm
		return &ma.ca_Input
	case 4:
		ma.ca_Output.w = &ma.w.Output
		ma.ca_Output.m = &ma.cm
		return &ma.ca_Output
	case 5:
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas
	case 6:
		ma.ca_Cost.w = &ma.w.Cost
		ma.ca_Cost.m = &ma.cm
		return &ma.ca_Cost
	case 7:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_Frame__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Frame_sufficient != fieldBits__Frame_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Frame_Op == 0 {
			err.Missing = append(err.Missing, "Op")
		}
		if ma.s&fieldBit__Frame_From == 0 {
			err.Missing = append(err.Missing, "From")
		}
		if ma.s&fieldBit__Frame_To == 0 {
			err.Missing = append(err.Missing, "To")
		}
		if ma.s&fieldBit__Frame_Input == 0 {
			err.Missing = append(err.Missing, "Input")
		}
		if ma.s&fieldBit__Frame_Output == 0 {
			err.Missing = append(err.Missing, "Output")
		}
		if ma.s&fieldBit__Frame_Gas == 0 {
			err.Missing = append(err.Missing, "Gas")
		}
		if ma.s&fieldBit__Frame_Cost == 0 {
			err.Missing = append(err.Missing, "Cost")
		}
		if ma.s&fieldBit__Frame_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Frame__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Frame__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Frame__ReprKeyAssembler _Frame__ReprAssembler

func (_Frame__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Frame__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Frame__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignNull()
}
func (_Frame__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Frame__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Frame__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Frame__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Op":
		if ka.s&fieldBit__Frame_Op != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Op_serial}
		}
		ka.s += fieldBit__Frame_Op
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "From":
		if ka.s&fieldBit__Frame_From != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_From_serial}
		}
		ka.s += fieldBit__Frame_From
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "To":
		if ka.s&fieldBit__Frame_To != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_To_serial}
		}
		ka.s += fieldBit__Frame_To
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Input":
		if ka.s&fieldBit__Frame_Input != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Input_serial}
		}
		ka.s += fieldBit__Frame_Input
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Output":
		if ka.s&fieldBit__Frame_Output != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Output_serial}
		}
		ka.s += fieldBit__Frame_Output
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Gas":
		if ka.s&fieldBit__Frame_Gas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Gas_serial}
		}
		ka.s += fieldBit__Frame_Gas
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Cost":
		if ka.s&fieldBit__Frame_Cost != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Cost_serial}
		}
		ka.s += fieldBit__Frame_Cost
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Value":
		if ka.s&fieldBit__Frame_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Frame_Value_serial}
		}
		ka.s += fieldBit__Frame_Value
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Frame.Repr", Key: &_String{k}}
}
func (_Frame__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Frame__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Frame.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Frame__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Frame__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_FrameList) Lookup(idx int64) Frame {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_FrameList) LookupMaybe(idx int64) MaybeFrame {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Frame__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _FrameList__valueAbsent = _Frame__Maybe{m: schema.Maybe_Absent}

func (n FrameList) Iterator() *FrameList__Itr {
	return &FrameList__Itr{n, 0}
}

type FrameList__Itr struct {
	n   FrameList
	idx int
}

func (itr *FrameList__Itr) Next() (idx int64, v Frame) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *FrameList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _FrameList__Maybe struct {
	m schema.Maybe
	v _FrameList
}
type MaybeFrameList = *_FrameList__Maybe

func (m MaybeFrameList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFrameList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFrameList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFrameList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeFrameList) Must() FrameList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (FrameList)(&_FrameList{})
var _ schema.TypedNode = (FrameList)(&_FrameList{})

func (FrameList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (FrameList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.LookupByString("")
}
func (n FrameList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n FrameList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n FrameList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.FrameList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (FrameList) MapIterator() ipld.MapIterator {
	return nil
}
func (n FrameList) ListIterator() ipld.ListIterator {
	return &_FrameList__ListItr{n, 0}
}

type _FrameList__ListItr struct {
	n   FrameList
	idx int
}

func (itr *_FrameList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_FrameList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n FrameList) Length() int64 {
	return int64(len(n.x))
}
func (FrameList) IsAbsent() bool {
	return false
}
func (FrameList) IsNull() bool {
	return false
}
func (FrameList) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsBool()
}
func (FrameList) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsInt()
}
func (FrameList) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsFloat()
}
func (FrameList) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsString()
}
func (FrameList) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsBytes()
}
func (FrameList) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.FrameList"}.AsLink()
}
func (FrameList) Prototype() ipld.NodePrototype {
	return _FrameList__Prototype{}
}

type _FrameList__Prototype struct{}

func (_FrameList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _FrameList__Builder
	nb.Reset()
	return &nb
}

type _FrameList__Builder struct {
	_FrameList__Assembler
}

func (nb *_FrameList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_FrameList__Builder) Reset() {
	var w _FrameList
	var m schema.Maybe
	*nb = _FrameList__Builder{_FrameList__Assembler{w: &w, m: &m}}
}

type _FrameList__Assembler struct {
	w     *_FrameList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Frame__Assembler
}

func (na *_FrameList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_FrameList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.BeginMap(0)
}
func (na *_FrameList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Frame, 0, sizeHint)
	}
	return na, nil
}
func (na *_FrameList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_FrameList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignBool(false)
}
func (_FrameList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignInt(0)
}
func (_FrameList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignFloat(0)
}
func (_FrameList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignString("")
}
func (_FrameList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignBytes(nil)
}
func (_FrameList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList"}.AssignLink(nil)
}
func (na *_FrameList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_FrameList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.FrameList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_FrameList__Assembler) Prototype() ipld.NodePrototype {
	return _FrameList__Prototype{}
}
func (la *_FrameList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_FrameList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Frame{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_FrameList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_FrameList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Frame__Prototype{}
}
func (FrameList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n FrameList) Representation() ipld.Node {
	return (*_FrameList__Repr)(n)
}

type _FrameList__Repr _FrameList

var _ ipld.Node = &_FrameList__Repr{}

func (_FrameList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_FrameList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.LookupByString("")
}
func (nr *_FrameList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (FrameList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Frame).Representation(), nil
}
func (nr *_FrameList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (FrameList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Frame).Representation(), nil
}
func (n _FrameList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.FrameList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_FrameList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_FrameList__Repr) ListIterator() ipld.ListIterator {
	return &_FrameList__ReprListItr{(FrameList)(nr), 0}
}

type _FrameList__ReprListItr _FrameList__ListItr

func (itr *_FrameList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_FrameList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Frame).Representation(), nil
}
func (itr *_FrameList__ReprListItr) Done() bool {
	return (*_FrameList__ListItr)(itr).Done()
}

func (rn *_FrameList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_FrameList__Repr) IsAbsent() bool {
	return false
}
func (_FrameList__Repr) IsNull() bool {
	return false
}
func (_FrameList__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsBool()
}
func (_FrameList__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsInt()
}
func (_FrameList__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsFloat()
}
func (_FrameList__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsString()
}
func (_FrameList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsBytes()
}
func (_FrameList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.FrameList.Repr"}.AsLink()
}
func (_FrameList__Repr) Prototype() ipld.NodePrototype {
	return _FrameList__ReprPrototype{}
}

type _FrameList__ReprPrototype struct{}

func (_FrameList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _FrameList__ReprBuilder
	nb.Reset()
	return &nb
}

type _FrameList__ReprBuilder struct {
	_FrameList__ReprAssembler
}

func (nb *_FrameList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_FrameList__ReprBuilder) Reset() {
	var w _FrameList
	var m schema.Maybe
	*nb = _FrameList__ReprBuilder{_FrameList__ReprAssembler{w: &w, m: &m}}
}

type _FrameList__ReprAssembler struct {
	w     *_FrameList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Frame__ReprAssembler
}

func (na *_FrameList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_FrameList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.BeginMap(0)
}
func (na *_FrameList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Frame, 0, sizeHint)
	}
	return na, nil
}
func (na *_FrameList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_FrameList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignBool(false)
}
func (_FrameList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignInt(0)
}
func (_FrameList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignFloat(0)
}
func (_FrameList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignString("")
}
func (_FrameList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignBytes(nil)
}
func (_FrameList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.FrameList.Repr"}.AssignLink(nil)
}
func (na *_FrameList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_FrameList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.FrameList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_FrameList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _FrameList__ReprPrototype{}
}
func (la *_FrameList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_FrameList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Frame{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_FrameList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_FrameList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Frame__ReprPrototype{}
}

func (n Hash) Bytes() []byte {
	return n.x
}
func (_Hash__Prototype) FromBytes(v []byte) (Hash, error) {
	n := _Hash{v}
	return &n, nil
}

type _Hash__Maybe struct {
	m schema.Maybe
	v _Hash
}
type MaybeHash = *_Hash__Maybe

func (m MaybeHash) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHash) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHash) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHash) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHash) Must() Hash {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Hash)(&_Hash{})
var _ schema.TypedNode = (Hash)(&_Hash{})

func (Hash) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Hash) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.LookupByString("")
}
func (Hash) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.LookupByNode(nil)
}
func (Hash) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.LookupByIndex(0)
}
func (Hash) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.LookupBySegment(seg)
}
func (Hash) MapIterator() ipld.MapIterator {
	return nil
}
func (Hash) ListIterator() ipld.ListIterator {
	return nil
}
func (Hash) Length() int64 {
	return -1
}
func (Hash) IsAbsent() bool {
	return false
}
func (Hash) IsNull() bool {
	return false
}
func (Hash) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.AsBool()
}
func (Hash) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.AsInt()
}
func (Hash) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.AsFloat()
}
func (Hash) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.AsString()
}
func (n Hash) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Hash) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Hash"}.AsLink()
}
func (Hash) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}

type _Hash__Prototype struct{}

func (_Hash__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Hash__Builder
	nb.Reset()
	return &nb
}

type _Hash__Builder struct {
	_Hash__Assembler
}

func (nb *_Hash__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Hash__Builder) Reset() {
	var w _Hash
	var m schema.Maybe
	*nb = _Hash__Builder{_Hash__Assembler{w: &w, m: &m}}
}

type _Hash__Assembler struct {
	w *_Hash
	m *schema.Maybe
}

func (na *_Hash__Assembler) reset() {}
func (_Hash__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.BeginMap(0)
}
func (_Hash__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.BeginList(0)
}
func (na *_Hash__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Hash__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignBool(false)
}
func (_Hash__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignInt(0)
}
func (_Hash__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignFloat(0)
}
func (_Hash__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignString("")
}
func (na *_Hash__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Hash__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Hash"}.AssignLink(nil)
}
func (na *_Hash__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Hash); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Hash__Assembler) Prototype() ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Hash) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Hash) Representation() ipld.Node {
	return (*_Hash__Repr)(n)
}

type _Hash__Repr = _Hash

var _ ipld.Node = &_Hash__Repr{}

type _Hash__ReprPrototype = _Hash__Prototype
type _Hash__ReprAssembler = _Hash__Assembler

func (n _Header) FieldParentCID() Link {
	return &n.ParentCID
}
func (n _Header) FieldUnclesCID() Link {
	return &n.UnclesCID
}
func (n _Header) FieldCoinbase() Address {
	return &n.Coinbase
}
func (n _Header) FieldStateRootCID() Link {
	return &n.StateRootCID
}
func (n _Header) FieldTxRootCID() Link {
	return &n.TxRootCID
}
func (n _Header) FieldRctRootCID() Link {
	return &n.RctRootCID
}
func (n _Header) FieldBloom() Bloom {
	return &n.Bloom
}
func (n _Header) FieldDifficulty() BigInt {
	return &n.Difficulty
}
func (n _Header) FieldNumber() BigInt {
	return &n.Number
}
func (n _Header) FieldGasLimit() Uint {
	return &n.GasLimit
}
func (n _Header) FieldGasUsed() Uint {
	return &n.GasUsed
}
func (n _Header) FieldTime() Time {
	return &n.Time
}
func (n _Header) FieldExtra() Bytes {
	return &n.Extra
}
func (n _Header) FieldMixDigest() Hash {
	return &n.MixDigest
}
func (n _Header) FieldNonce() Uint {
	return &n.Nonce
}
func (n _Header) FieldBaseFee() MaybeBigInt {
	return &n.BaseFee
}

type _Header__Maybe struct {
	m schema.Maybe
	v Header
}
type MaybeHeader = *_Header__Maybe

func (m MaybeHeader) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeHeader) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeHeader) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeHeader) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeHeader) Must() Header {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Header_ParentCID    = _String{"ParentCID"}
	fieldName__Header_UnclesCID    = _String{"UnclesCID"}
	fieldName__Header_Coinbase     = _String{"Coinbase"}
	fieldName__Header_StateRootCID = _String{"StateRootCID"}
	fieldName__Header_TxRootCID    = _String{"TxRootCID"}
	fieldName__Header_RctRootCID   = _String{"RctRootCID"}
	fieldName__Header_Bloom        = _String{"Bloom"}
	fieldName__Header_Difficulty   = _String{"Difficulty"}
	fieldName__Header_Number       = _String{"Number"}
	fieldName__Header_GasLimit     = _String{"GasLimit"}
	fieldName__Header_GasUsed      = _String{"GasUsed"}
	fieldName__Header_Time         = _String{"Time"}
	fieldName__Header_Extra        = _String{"Extra"}
	fieldName__Header_MixDigest    = _String{"MixDigest"}
	fieldName__Header_Nonce        = _String{"Nonce"}
	fieldName__Header_BaseFee      = _String{"BaseFee"}
)
var _ ipld.Node = (Header)(&_Header{})
var _ schema.TypedNode = (Header)(&_Header{})

func (Header) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Header) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ParentCID":
		return &n.ParentCID, nil
	case "UnclesCID":
		return &n.UnclesCID, nil
	case "Coinbase":
		return &n.Coinbase, nil
	case "StateRootCID":
		return &n.StateRootCID, nil
	case "TxRootCID":
		return &n.TxRootCID, nil
	case "RctRootCID":
		return &n.RctRootCID, nil
	case "Bloom":
		return &n.Bloom, nil
	case "Difficulty":
		return &n.Difficulty, nil
	case "Number":
		return &n.Number, nil
	case "GasLimit":
		return &n.GasLimit, nil
	case "GasUsed":
		return &n.GasUsed, nil
	case "Time":
		return &n.Time, nil
	case "Extra":
		return &n.Extra, nil
	case "MixDigest":
		return &n.MixDigest, nil
	case "Nonce":
		return &n.Nonce, nil
	case "BaseFee":
		if n.BaseFee.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.BaseFee.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Header) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Header) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Header"}.LookupByIndex(0)
}
func (n Header) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Header) MapIterator() ipld.MapIterator {
	return &_Header__MapItr{n, 0}
}

type _Header__MapItr struct {
	n   Header
	idx int
}

func (itr *_Header__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 16 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_ParentCID
		v = &itr.n.ParentCID
	case 1:
		k = &fieldName__Header_UnclesCID
		v = &itr.n.UnclesCID
	case 2:
		k = &fieldName__Header_Coinbase
		v = &itr.n.Coinbase
	case 3:
		k = &fieldName__Header_StateRootCID
		v = &itr.n.StateRootCID
	case 4:
		k = &fieldName__Header_TxRootCID
		v = &itr.n.TxRootCID
	case 5:
		k = &fieldName__Header_RctRootCID
		v = &itr.n.RctRootCID
	case 6:
		k = &fieldName__Header_Bloom
		v = &itr.n.Bloom
	case 7:
		k = &fieldName__Header_Difficulty
		v = &itr.n.Difficulty
	case 8:
		k = &fieldName__Header_Number
		v = &itr.n.Number
	case 9:
		k = &fieldName__Header_GasLimit
		v = &itr.n.GasLimit
	case 10:
		k = &fieldName__Header_GasUsed
		v = &itr.n.GasUsed
	case 11:
		k = &fieldName__Header_Time
		v = &itr.n.Time
	case 12:
		k = &fieldName__Header_Extra
		v = &itr.n.Extra
	case 13:
		k = &fieldName__Header_MixDigest
		v = &itr.n.MixDigest
	case 14:
		k = &fieldName__Header_Nonce
		v = &itr.n.Nonce
	case 15:
		k = &fieldName__Header_BaseFee
		if itr.n.BaseFee.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.BaseFee.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__MapItr) Done() bool {
	return itr.idx >= 16
}

func (Header) ListIterator() ipld.ListIterator {
	return nil
}
func (Header) Length() int64 {
	return 16
}
func (Header) IsAbsent() bool {
	return false
}
func (Header) IsNull() bool {
	return false
}
func (Header) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsBool()
}
func (Header) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsInt()
}
func (Header) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsFloat()
}
func (Header) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsString()
}
func (Header) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsBytes()
}
func (Header) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Header"}.AsLink()
}
func (Header) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}

type _Header__Prototype struct{}

func (_Header__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__Builder
	nb.Reset()
	return &nb
}

type _Header__Builder struct {
	_Header__Assembler
}

func (nb *_Header__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__Builder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__Builder{_Header__Assembler{w: &w, m: &m}}
}

type _Header__Assembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ParentCID    _Link__Assembler
	ca_UnclesCID    _Link__Assembler
	ca_Coinbase     _Address__Assembler
	ca_StateRootCID _Link__Assembler
	ca_TxRootCID    _Link__Assembler
	ca_RctRootCID   _Link__Assembler
	ca_Bloom        _Bloom__Assembler
	ca_Difficulty   _BigInt__Assembler
	ca_Number       _BigInt__Assembler
	ca_GasLimit     _Uint__Assembler
	ca_GasUsed      _Uint__Assembler
	ca_Time         _Time__Assembler
	ca_Extra        _Bytes__Assembler
	ca_MixDigest    _Hash__Assembler
	ca_Nonce        _Uint__Assembler
	ca_BaseFee      _BigInt__Assembler
}

func (na *_Header__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ParentCID.reset()
	na.ca_UnclesCID.reset()
	na.ca_Coinbase.reset()
	na.ca_StateRootCID.reset()
	na.ca_TxRootCID.reset()
	na.ca_RctRootCID.reset()
	na.ca_Bloom.reset()
	na.ca_Difficulty.reset()
	na.ca_Number.reset()
	na.ca_GasLimit.reset()
	na.ca_GasUsed.reset()
	na.ca_Time.reset()
	na.ca_Extra.reset()
	na.ca_MixDigest.reset()
	na.ca_Nonce.reset()
	na.ca_BaseFee.reset()
}

var (
	fieldBit__Header_ParentCID    = 1 << 0
	fieldBit__Header_UnclesCID    = 1 << 1
	fieldBit__Header_Coinbase     = 1 << 2
	fieldBit__Header_StateRootCID = 1 << 3
	fieldBit__Header_TxRootCID    = 1 << 4
	fieldBit__Header_RctRootCID   = 1 << 5
	fieldBit__Header_Bloom        = 1 << 6
	fieldBit__Header_Difficulty   = 1 << 7
	fieldBit__Header_Number       = 1 << 8
	fieldBit__Header_GasLimit     = 1 << 9
	fieldBit__Header_GasUsed      = 1 << 10
	fieldBit__Header_Time         = 1 << 11
	fieldBit__Header_Extra        = 1 << 12
	fieldBit__Header_MixDigest    = 1 << 13
	fieldBit__Header_Nonce        = 1 << 14
	fieldBit__Header_BaseFee      = 1 << 15
	fieldBits__Header_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13 + 1<<14 + 1<<15
)

func (na *_Header__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.BeginList(0)
}
func (na *_Header__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignBool(false)
}
func (_Header__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignInt(0)
}
func (_Header__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignFloat(0)
}
func (_Header__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignString("")
}
func (_Header__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignBytes(nil)
}
func (_Header__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Header"}.AssignLink(nil)
}
func (na *_Header__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Header", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__Assembler) Prototype() ipld.NodePrototype {
	return _Header__Prototype{}
}
func (ma *_Header__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ParentCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_UnclesCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Coinbase.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StateRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TxRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_RctRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bloom.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Difficulty.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Number.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasLimit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasUsed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Time.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Extra.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MixDigest.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Nonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.BaseFee.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ParentCID":
		if ma.s&fieldBit__Header_ParentCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID}
		}
		ma.s += fieldBit__Header_ParentCID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID, nil
	case "UnclesCID":
		if ma.s&fieldBit__Header_UnclesCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID}
		}
		ma.s += fieldBit__Header_UnclesCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID, nil
	case "Coinbase":
		if ma.s&fieldBit__Header_Coinbase != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase}
		}
		ma.s += fieldBit__Header_Coinbase
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase, nil
	case "StateRootCID":
		if ma.s&fieldBit__Header_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID}
		}
		ma.s += fieldBit__Header_StateRootCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "TxRootCID":
		if ma.s&fieldBit__Header_TxRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID}
		}
		ma.s += fieldBit__Header_TxRootCID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID, nil
	case "RctRootCID":
		if ma.s&fieldBit__Header_RctRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID}
		}
		ma.s += fieldBit__Header_RctRootCID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID, nil
	case "Bloom":
		if ma.s&fieldBit__Header_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom}
		}
		ma.s += fieldBit__Header_Bloom
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Difficulty":
		if ma.s&fieldBit__Header_Difficulty != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty}
		}
		ma.s += fieldBit__Header_Difficulty
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty, nil
	case "Number":
		if ma.s&fieldBit__Header_Number != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number}
		}
		ma.s += fieldBit__Header_Number
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number, nil
	case "GasLimit":
		if ma.s&fieldBit__Header_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit}
		}
		ma.s += fieldBit__Header_GasLimit
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "GasUsed":
		if ma.s&fieldBit__Header_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed}
		}
		ma.s += fieldBit__Header_GasUsed
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "Extra":
		if ma.s&fieldBit__Header_Extra != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra}
		}
		ma.s += fieldBit__Header_Extra
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra, nil
	case "MixDigest":
		if ma.s&fieldBit__Header_MixDigest != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest}
		}
		ma.s += fieldBit__Header_MixDigest
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest, nil
	case "Nonce":
		if ma.s&fieldBit__Header_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce}
		}
		ma.s += fieldBit__Header_Nonce
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "BaseFee":
		if ma.s&fieldBit__Header_BaseFee != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_BaseFee}
		}
		ma.s += fieldBit__Header_BaseFee
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_BaseFee.w = &ma.w.BaseFee.v
		ma.ca_BaseFee.m = &ma.w.BaseFee.m
		ma.w.BaseFee.m = allowNull
		return &ma.ca_BaseFee, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Header", Key: &_String{k}}
}
func (ma *_Header__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__KeyAssembler)(ma)
}
func (ma *_Header__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID
	case 1:
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID
	case 2:
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase
	case 3:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 4:
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID
	case 5:
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID
	case 6:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 7:
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty
	case 8:
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number
	case 9:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 10:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	case 11:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 12:
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra
	case 13:
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest
	case 14:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 15:
		ma.ca_BaseFee.w = &ma.w.BaseFee.v
		ma.ca_BaseFee.m = &ma.w.BaseFee.m
		ma.w.BaseFee.m = allowNull
		return &ma.ca_BaseFee
	default:
		panic("unreachable")
	}
}
func (ma *_Header__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_ParentCID == 0 {
			err.Missing = append(err.Missing, "ParentCID")
		}
		if ma.s&fieldBit__Header_UnclesCID == 0 {
			err.Missing = append(err.Missing, "UnclesCID")
		}
		if ma.s&fieldBit__Header_Coinbase == 0 {
			err.Missing = append(err.Missing, "Coinbase")
		}
		if ma.s&fieldBit__Header_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__Header_TxRootCID == 0 {
			err.Missing = append(err.Missing, "TxRootCID")
		}
		if ma.s&fieldBit__Header_RctRootCID == 0 {
			err.Missing = append(err.Missing, "RctRootCID")
		}
		if ma.s&fieldBit__Header_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Header_Difficulty == 0 {
			err.Missing = append(err.Missing, "Difficulty")
		}
		if ma.s&fieldBit__Header_Number == 0 {
			err.Missing = append(err.Missing, "Number")
		}
		if ma.s&fieldBit__Header_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Header_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_Extra == 0 {
			err.Missing = append(err.Missing, "Extra")
		}
		if ma.s&fieldBit__Header_MixDigest == 0 {
			err.Missing = append(err.Missing, "MixDigest")
		}
		if ma.s&fieldBit__Header_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Header__KeyAssembler _Header__Assembler

func (_Header__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.BeginMap(0)
}
func (_Header__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.BeginList(0)
}
func (na *_Header__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignNull()
}
func (_Header__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignBool(false)
}
func (_Header__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignInt(0)
}
func (_Header__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ParentCID":
		if ka.s&fieldBit__Header_ParentCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID}
		}
		ka.s += fieldBit__Header_ParentCID
		ka.state = maState_expectValue
		ka.f = 0
	case "UnclesCID":
		if ka.s&fieldBit__Header_UnclesCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID}
		}
		ka.s += fieldBit__Header_UnclesCID
		ka.state = maState_expectValue
		ka.f = 1
	case "Coinbase":
		if ka.s&fieldBit__Header_Coinbase != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase}
		}
		ka.s += fieldBit__Header_Coinbase
		ka.state = maState_expectValue
		ka.f = 2
	case "StateRootCID":
		if ka.s&fieldBit__Header_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID}
		}
		ka.s += fieldBit__Header_StateRootCID
		ka.state = maState_expectValue
		ka.f = 3
	case "TxRootCID":
		if ka.s&fieldBit__Header_TxRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID}
		}
		ka.s += fieldBit__Header_TxRootCID
		ka.state = maState_expectValue
		ka.f = 4
	case "RctRootCID":
		if ka.s&fieldBit__Header_RctRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID}
		}
		ka.s += fieldBit__Header_RctRootCID
		ka.state = maState_expectValue
		ka.f = 5
	case "Bloom":
		if ka.s&fieldBit__Header_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom}
		}
		ka.s += fieldBit__Header_Bloom
		ka.state = maState_expectValue
		ka.f = 6
	case "Difficulty":
		if ka.s&fieldBit__Header_Difficulty != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty}
		}
		ka.s += fieldBit__Header_Difficulty
		ka.state = maState_expectValue
		ka.f = 7
	case "Number":
		if ka.s&fieldBit__Header_Number != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number}
		}
		ka.s += fieldBit__Header_Number
		ka.state = maState_expectValue
		ka.f = 8
	case "GasLimit":
		if ka.s&fieldBit__Header_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit}
		}
		ka.s += fieldBit__Header_GasLimit
		ka.state = maState_expectValue
		ka.f = 9
	case "GasUsed":
		if ka.s&fieldBit__Header_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed}
		}
		ka.s += fieldBit__Header_GasUsed
		ka.state = maState_expectValue
		ka.f = 10
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 11
	case "Extra":
		if ka.s&fieldBit__Header_Extra != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra}
		}
		ka.s += fieldBit__Header_Extra
		ka.state = maState_expectValue
		ka.f = 12
	case "MixDigest":
		if ka.s&fieldBit__Header_MixDigest != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest}
		}
		ka.s += fieldBit__Header_MixDigest
		ka.state = maState_expectValue
		ka.f = 13
	case "Nonce":
		if ka.s&fieldBit__Header_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce}
		}
		ka.s += fieldBit__Header_Nonce
		ka.state = maState_expectValue
		ka.f = 14
	case "BaseFee":
		if ka.s&fieldBit__Header_BaseFee != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_BaseFee}
		}
		ka.s += fieldBit__Header_BaseFee
		ka.state = maState_expectValue
		ka.f = 15
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Header", Key: &_String{k}}
	}
	return nil
}
func (_Header__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Header) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Header) Representation() ipld.Node {
	return (*_Header__Repr)(n)
}

type _Header__Repr _Header

var (
	fieldName__Header_ParentCID_serial    = _String{"ParentCID"}
	fieldName__Header_UnclesCID_serial    = _String{"UnclesCID"}
	fieldName__Header_Coinbase_serial     = _String{"Coinbase"}
	fieldName__Header_StateRootCID_serial = _String{"StateRootCID"}
	fieldName__Header_TxRootCID_serial    = _String{"TxRootCID"}
	fieldName__Header_RctRootCID_serial   = _String{"RctRootCID"}
	fieldName__Header_Bloom_serial        = _String{"Bloom"}
	fieldName__Header_Difficulty_serial   = _String{"Difficulty"}
	fieldName__Header_Number_serial       = _String{"Number"}
	fieldName__Header_GasLimit_serial     = _String{"GasLimit"}
	fieldName__Header_GasUsed_serial      = _String{"GasUsed"}
	fieldName__Header_Time_serial         = _String{"Time"}
	fieldName__Header_Extra_serial        = _String{"Extra"}
	fieldName__Header_MixDigest_serial    = _String{"MixDigest"}
	fieldName__Header_Nonce_serial        = _String{"Nonce"}
	fieldName__Header_BaseFee_serial      = _String{"BaseFee"}
)
var _ ipld.Node = &_Header__Repr{}

func (_Header__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Header__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "ParentCID":
		return n.ParentCID.Representation(), nil
	case "UnclesCID":
		return n.UnclesCID.Representation(), nil
	case "Coinbase":
		return n.Coinbase.Representation(), nil
	case "StateRootCID":
		return n.StateRootCID.Representation(), nil
	case "TxRootCID":
		return n.TxRootCID.Representation(), nil
	case "RctRootCID":
		return n.RctRootCID.Representation(), nil
	case "Bloom":
		return n.Bloom.Representation(), nil
	case "Difficulty":
		return n.Difficulty.Representation(), nil
	case "Number":
		return n.Number.Representation(), nil
	case "GasLimit":
		return n.GasLimit.Representation(), nil
	case "GasUsed":
		return n.GasUsed.Representation(), nil
	case "Time":
		return n.Time.Representation(), nil
	case "Extra":
		return n.Extra.Representation(), nil
	case "MixDigest":
		return n.MixDigest.Representation(), nil
	case "Nonce":
		return n.Nonce.Representation(), nil
	case "BaseFee":
		if n.BaseFee.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.BaseFee.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Header__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Header__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.LookupByIndex(0)
}
func (n _Header__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Header__Repr) MapIterator() ipld.MapIterator {
	return &_Header__ReprMapItr{n, 0}
}

type _Header__ReprMapItr struct {
	n   *_Header__Repr
	idx int
}

func (itr *_Header__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 16 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Header_ParentCID_serial
		v = itr.n.ParentCID.Representation()
	case 1:
		k = &fieldName__Header_UnclesCID_serial
		v = itr.n.UnclesCID.Representation()
	case 2:
		k = &fieldName__Header_Coinbase_serial
		v = itr.n.Coinbase.Representation()
	case 3:
		k = &fieldName__Header_StateRootCID_serial
		v = itr.n.StateRootCID.Representation()
	case 4:
		k = &fieldName__Header_TxRootCID_serial
		v = itr.n.TxRootCID.Representation()
	case 5:
		k = &fieldName__Header_RctRootCID_serial
		v = itr.n.RctRootCID.Representation()
	case 6:
		k = &fieldName__Header_Bloom_serial
		v = itr.n.Bloom.Representation()
	case 7:
		k = &fieldName__Header_Difficulty_serial
		v = itr.n.Difficulty.Representation()
	case 8:
		k = &fieldName__Header_Number_serial
		v = itr.n.Number.Representation()
	case 9:
		k = &fieldName__Header_GasLimit_serial
		v = itr.n.GasLimit.Representation()
	case 10:
		k = &fieldName__Header_GasUsed_serial
		v = itr.n.GasUsed.Representation()
	case 11:
		k = &fieldName__Header_Time_serial
		v = itr.n.Time.Representation()
	case 12:
		k = &fieldName__Header_Extra_serial
		v = itr.n.Extra.Representation()
	case 13:
		k = &fieldName__Header_MixDigest_serial
		v = itr.n.MixDigest.Representation()
	case 14:
		k = &fieldName__Header_Nonce_serial
		v = itr.n.Nonce.Representation()
	case 15:
		k = &fieldName__Header_BaseFee_serial
		if itr.n.BaseFee.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.BaseFee.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Header__ReprMapItr) Done() bool {
	return itr.idx >= 16
}
func (_Header__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Header__Repr) Length() int64 {
	l := 16
	return int64(l)
}
func (_Header__Repr) IsAbsent() bool {
	return false
}
func (_Header__Repr) IsNull() bool {
	return false
}
func (_Header__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsBool()
}
func (_Header__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsInt()
}
func (_Header__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsFloat()
}
func (_Header__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsString()
}
func (_Header__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsBytes()
}
func (_Header__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Header.Repr"}.AsLink()
}
func (_Header__Repr) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}

type _Header__ReprPrototype struct{}

func (_Header__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Header__ReprBuilder
	nb.Reset()
	return &nb
}

type _Header__ReprBuilder struct {
	_Header__ReprAssembler
}

func (nb *_Header__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Header__ReprBuilder) Reset() {
	var w _Header
	var m schema.Maybe
	*nb = _Header__ReprBuilder{_Header__ReprAssembler{w: &w, m: &m}}
}

type _Header__ReprAssembler struct {
	w     *_Header
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_ParentCID    _Link__ReprAssembler
	ca_UnclesCID    _Link__ReprAssembler
	ca_Coinbase     _Address__ReprAssembler
	ca_StateRootCID _Link__ReprAssembler
	ca_TxRootCID    _Link__ReprAssembler
	ca_RctRootCID   _Link__ReprAssembler
	ca_Bloom        _Bloom__ReprAssembler
	ca_Difficulty   _BigInt__ReprAssembler
	ca_Number       _BigInt__ReprAssembler
	ca_GasLimit     _Uint__ReprAssembler
	ca_GasUsed      _Uint__ReprAssembler
	ca_Time         _Time__ReprAssembler
	ca_Extra        _Bytes__ReprAssembler
	ca_MixDigest    _Hash__ReprAssembler
	ca_Nonce        _Uint__ReprAssembler
	ca_BaseFee      _BigInt__ReprAssembler
}

func (na *_Header__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_ParentCID.reset()
	na.ca_UnclesCID.reset()
	na.ca_Coinbase.reset()
	na.ca_StateRootCID.reset()
	na.ca_TxRootCID.reset()
	na.ca_RctRootCID.reset()
	na.ca_Bloom.reset()
	na.ca_Difficulty.reset()
	na.ca_Number.reset()
	na.ca_GasLimit.reset()
	na.ca_GasUsed.reset()
	na.ca_Time.reset()
	na.ca_Extra.reset()
	na.ca_MixDigest.reset()
	na.ca_Nonce.reset()
	na.ca_BaseFee.reset()
}
func (na *_Header__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Header{}
	}
	return na, nil
}
func (_Header__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.BeginList(0)
}
func (na *_Header__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Header.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Header__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignBool(false)
}
func (_Header__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignInt(0)
}
func (_Header__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignFloat(0)
}
func (_Header__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignString("")
}
func (_Header__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignBytes(nil)
}
func (_Header__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Header.Repr"}.AssignLink(nil)
}
func (na *_Header__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Header); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Header.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Header__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Header__ReprPrototype{}
}
func (ma *_Header__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.BaseFee.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "ParentCID":
		if ma.s&fieldBit__Header_ParentCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID_serial}
		}
		ma.s += fieldBit__Header_ParentCID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID, nil
	case "UnclesCID":
		if ma.s&fieldBit__Header_UnclesCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID_serial}
		}
		ma.s += fieldBit__Header_UnclesCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID, nil
	case "Coinbase":
		if ma.s&fieldBit__Header_Coinbase != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase_serial}
		}
		ma.s += fieldBit__Header_Coinbase
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase, nil
	case "StateRootCID":
		if ma.s&fieldBit__Header_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID_serial}
		}
		ma.s += fieldBit__Header_StateRootCID
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "TxRootCID":
		if ma.s&fieldBit__Header_TxRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID_serial}
		}
		ma.s += fieldBit__Header_TxRootCID
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID, nil
	case "RctRootCID":
		if ma.s&fieldBit__Header_RctRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID_serial}
		}
		ma.s += fieldBit__Header_RctRootCID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID, nil
	case "Bloom":
		if ma.s&fieldBit__Header_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom_serial}
		}
		ma.s += fieldBit__Header_Bloom
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Difficulty":
		if ma.s&fieldBit__Header_Difficulty != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty_serial}
		}
		ma.s += fieldBit__Header_Difficulty
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty, nil
	case "Number":
		if ma.s&fieldBit__Header_Number != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number_serial}
		}
		ma.s += fieldBit__Header_Number
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number, nil
	case "GasLimit":
		if ma.s&fieldBit__Header_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit_serial}
		}
		ma.s += fieldBit__Header_GasLimit
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "GasUsed":
		if ma.s&fieldBit__Header_GasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed_serial}
		}
		ma.s += fieldBit__Header_GasUsed
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed, nil
	case "Time":
		if ma.s&fieldBit__Header_Time != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ma.s += fieldBit__Header_Time
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time, nil
	case "Extra":
		if ma.s&fieldBit__Header_Extra != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra_serial}
		}
		ma.s += fieldBit__Header_Extra
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra, nil
	case "MixDigest":
		if ma.s&fieldBit__Header_MixDigest != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest_serial}
		}
		ma.s += fieldBit__Header_MixDigest
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest, nil
	case "Nonce":
		if ma.s&fieldBit__Header_Nonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce_serial}
		}
		ma.s += fieldBit__Header_Nonce
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce, nil
	case "BaseFee":
		if ma.s&fieldBit__Header_BaseFee != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Header_BaseFee_serial}
		}
		ma.s += fieldBit__Header_BaseFee
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_BaseFee.w = &ma.w.BaseFee.v
		ma.ca_BaseFee.m = &ma.w.BaseFee.m
		ma.w.BaseFee.m = allowNull
		return &ma.ca_BaseFee, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Header.Repr", Key: &_String{k}}
}
func (ma *_Header__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Header__ReprKeyAssembler)(ma)
}
func (ma *_Header__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_ParentCID.w = &ma.w.ParentCID
		ma.ca_ParentCID.m = &ma.cm
		return &ma.ca_ParentCID
	case 1:
		ma.ca_UnclesCID.w = &ma.w.UnclesCID
		ma.ca_UnclesCID.m = &ma.cm
		return &ma.ca_UnclesCID
	case 2:
		ma.ca_Coinbase.w = &ma.w.Coinbase
		ma.ca_Coinbase.m = &ma.cm
		return &ma.ca_Coinbase
	case 3:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 4:
		ma.ca_TxRootCID.w = &ma.w.TxRootCID
		ma.ca_TxRootCID.m = &ma.cm
		return &ma.ca_TxRootCID
	case 5:
		ma.ca_RctRootCID.w = &ma.w.RctRootCID
		ma.ca_RctRootCID.m = &ma.cm
		return &ma.ca_RctRootCID
	case 6:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 7:
		ma.ca_Difficulty.w = &ma.w.Difficulty
		ma.ca_Difficulty.m = &ma.cm
		return &ma.ca_Difficulty
	case 8:
		ma.ca_Number.w = &ma.w.Number
		ma.ca_Number.m = &ma.cm
		return &ma.ca_Number
	case 9:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 10:
		ma.ca_GasUsed.w = &ma.w.GasUsed
		ma.ca_GasUsed.m = &ma.cm
		return &ma.ca_GasUsed
	case 11:
		ma.ca_Time.w = &ma.w.Time
		ma.ca_Time.m = &ma.cm
		return &ma.ca_Time
	case 12:
		ma.ca_Extra.w = &ma.w.Extra
		ma.ca_Extra.m = &ma.cm
		return &ma.ca_Extra
	case 13:
		ma.ca_MixDigest.w = &ma.w.MixDigest
		ma.ca_MixDigest.m = &ma.cm
		return &ma.ca_MixDigest
	case 14:
		ma.ca_Nonce.w = &ma.w.Nonce
		ma.ca_Nonce.m = &ma.cm
		return &ma.ca_Nonce
	case 15:
		ma.ca_BaseFee.w = &ma.w.BaseFee.v
		ma.ca_BaseFee.m = &ma.w.BaseFee.m
		ma.w.BaseFee.m = allowNull
		return &ma.ca_BaseFee
	default:
		panic("unreachable")
	}
}
func (ma *_Header__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Header_sufficient != fieldBits__Header_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Header_ParentCID == 0 {
			err.Missing = append(err.Missing, "ParentCID")
		}
		if ma.s&fieldBit__Header_UnclesCID == 0 {
			err.Missing = append(err.Missing, "UnclesCID")
		}
		if ma.s&fieldBit__Header_Coinbase == 0 {
			err.Missing = append(err.Missing, "Coinbase")
		}
		if ma.s&fieldBit__Header_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__Header_TxRootCID == 0 {
			err.Missing = append(err.Missing, "TxRootCID")
		}
		if ma.s&fieldBit__Header_RctRootCID == 0 {
			err.Missing = append(err.Missing, "RctRootCID")
		}
		if ma.s&fieldBit__Header_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Header_Difficulty == 0 {
			err.Missing = append(err.Missing, "Difficulty")
		}
		if ma.s&fieldBit__Header_Number == 0 {
			err.Missing = append(err.Missing, "Number")
		}
		if ma.s&fieldBit__Header_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Header_GasUsed == 0 {
			err.Missing = append(err.Missing, "GasUsed")
		}
		if ma.s&fieldBit__Header_Time == 0 {
			err.Missing = append(err.Missing, "Time")
		}
		if ma.s&fieldBit__Header_Extra == 0 {
			err.Missing = append(err.Missing, "Extra")
		}
		if ma.s&fieldBit__Header_MixDigest == 0 {
			err.Missing = append(err.Missing, "MixDigest")
		}
		if ma.s&fieldBit__Header_Nonce == 0 {
			err.Missing = append(err.Missing, "Nonce")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Header__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Header__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Header__ReprKeyAssembler _Header__ReprAssembler

func (_Header__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Header__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Header__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignNull()
}
func (_Header__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Header__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Header__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Header__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "ParentCID":
		if ka.s&fieldBit__Header_ParentCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_ParentCID_serial}
		}
		ka.s += fieldBit__Header_ParentCID
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "UnclesCID":
		if ka.s&fieldBit__Header_UnclesCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_UnclesCID_serial}
		}
		ka.s += fieldBit__Header_UnclesCID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Coinbase":
		if ka.s&fieldBit__Header_Coinbase != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Coinbase_serial}
		}
		ka.s += fieldBit__Header_Coinbase
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "StateRootCID":
		if ka.s&fieldBit__Header_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_StateRootCID_serial}
		}
		ka.s += fieldBit__Header_StateRootCID
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "TxRootCID":
		if ka.s&fieldBit__Header_TxRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_TxRootCID_serial}
		}
		ka.s += fieldBit__Header_TxRootCID
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "RctRootCID":
		if ka.s&fieldBit__Header_RctRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_RctRootCID_serial}
		}
		ka.s += fieldBit__Header_RctRootCID
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Bloom":
		if ka.s&fieldBit__Header_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Bloom_serial}
		}
		ka.s += fieldBit__Header_Bloom
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Difficulty":
		if ka.s&fieldBit__Header_Difficulty != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Difficulty_serial}
		}
		ka.s += fieldBit__Header_Difficulty
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "Number":
		if ka.s&fieldBit__Header_Number != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Number_serial}
		}
		ka.s += fieldBit__Header_Number
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "GasLimit":
		if ka.s&fieldBit__Header_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasLimit_serial}
		}
		ka.s += fieldBit__Header_GasLimit
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "GasUsed":
		if ka.s&fieldBit__Header_GasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_GasUsed_serial}
		}
		ka.s += fieldBit__Header_GasUsed
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "Time":
		if ka.s&fieldBit__Header_Time != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Time_serial}
		}
		ka.s += fieldBit__Header_Time
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "Extra":
		if ka.s&fieldBit__Header_Extra != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Extra_serial}
		}
		ka.s += fieldBit__Header_Extra
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "MixDigest":
		if ka.s&fieldBit__Header_MixDigest != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_MixDigest_serial}
		}
		ka.s += fieldBit__Header_MixDigest
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	case "Nonce":
		if ka.s&fieldBit__Header_Nonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_Nonce_serial}
		}
		ka.s += fieldBit__Header_Nonce
		ka.state = maState_expectValue
		ka.f = 14
		return nil
	case "BaseFee":
		if ka.s&fieldBit__Header_BaseFee != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Header_BaseFee_serial}
		}
		ka.s += fieldBit__Header_BaseFee
		ka.state = maState_expectValue
		ka.f = 15
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Header.Repr", Key: &_String{k}}
}
func (_Header__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Header__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Header.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Header__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Header__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Link) Link() ipld.Link {
	return n.x
}
func (_Link__Prototype) FromLink(v ipld.Link) (Link, error) {
	n := _Link{v}
	return &n, nil
}

type _Link__Maybe struct {
	m schema.Maybe
	v _Link
}
type MaybeLink = *_Link__Maybe

func (m MaybeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLink) Must() Link {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Link)(&_Link{})
var _ schema.TypedNode = (Link)(&_Link{})

func (Link) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{TypeName: "dageth.Link"}.LookupByString("")
}
func (Link) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{TypeName: "dageth.Link"}.LookupByNode(nil)
}
func (Link) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{TypeName: "dageth.Link"}.LookupByIndex(0)
}
func (Link) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{TypeName: "dageth.Link"}.LookupBySegment(seg)
}
func (Link) MapIterator() ipld.MapIterator {
	return nil
}
func (Link) ListIterator() ipld.ListIterator {
	return nil
}
func (Link) Length() int64 {
	return -1
}
func (Link) IsAbsent() bool {
	return false
}
func (Link) IsNull() bool {
	return false
}
func (Link) AsBool() (bool, error) {
	return mixins.Link{TypeName: "dageth.Link"}.AsBool()
}
func (Link) AsInt() (int64, error) {
	return mixins.Link{TypeName: "dageth.Link"}.AsInt()
}
func (Link) AsFloat() (float64, error) {
	return mixins.Link{TypeName: "dageth.Link"}.AsFloat()
}
func (Link) AsString() (string, error) {
	return mixins.Link{TypeName: "dageth.Link"}.AsString()
}
func (Link) AsBytes() ([]byte, error) {
	return mixins.Link{TypeName: "dageth.Link"}.AsBytes()
}
func (n Link) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}

type _Link__Prototype struct{}

func (_Link__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link__Builder
	nb.Reset()
	return &nb
}

type _Link__Builder struct {
	_Link__Assembler
}

func (nb *_Link__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link__Builder) Reset() {
	var w _Link
	var m schema.Maybe
	*nb = _Link__Builder{_Link__Assembler{w: &w, m: &m}}
}

type _Link__Assembler struct {
	w *_Link
	m *schema.Maybe
}

func (na *_Link__Assembler) reset() {}
func (_Link__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.BeginMap(0)
}
func (_Link__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.BeginList(0)
}
func (na *_Link__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignBool(false)
}
func (_Link__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignInt(0)
}
func (_Link__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignFloat(0)
}
func (_Link__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignString("")
}
func (_Link__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{TypeName: "dageth.Link"}.AssignBytes(nil)
}
func (na *_Link__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link__Assembler) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
func (Link) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Link) Representation() ipld.Node {
	return (*_Link__Repr)(n)
}

type _Link__Repr = _Link

var _ ipld.Node = &_Link__Repr{}

type _Link__ReprPrototype = _Link__Prototype
type _Link__ReprAssembler = _Link__Assembler

func (n _Log) FieldAddress() Address {
	return &n.Address
}
func (n _Log) FieldTopics() Topics {
	return &n.Topics
}
func (n _Log) FieldData() Bytes {
	return &n.Data
}

type _Log__Maybe struct {
	m schema.Maybe
	v Log
}
type MaybeLog = *_Log__Maybe

func (m MaybeLog) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLog) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLog) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLog) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLog) Must() Log {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Log_Address = _String{"Address"}
	fieldName__Log_Topics  = _String{"Topics"}
	fieldName__Log_Data    = _String{"Data"}
)
var _ ipld.Node = (Log)(&_Log{})
var _ schema.TypedNode = (Log)(&_Log{})

func (Log) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Log) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return &n.Address, nil
	case "Topics":
		return &n.Topics, nil
	case "Data":
		return &n.Data, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Log) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Log) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Log"}.LookupByIndex(0)
}
func (n Log) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Log) MapIterator() ipld.MapIterator {
	return &_Log__MapItr{n, 0}
}

type _Log__MapItr struct {
	n   Log
	idx int
}

func (itr *_Log__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Log_Address
		v = &itr.n.Address
	case 1:
		k = &fieldName__Log_Topics
		v = &itr.n.Topics
	case 2:
		k = &fieldName__Log_Data
		v = &itr.n.Data
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Log__MapItr) Done() bool {
	return itr.idx >= 3
}

func (Log) ListIterator() ipld.ListIterator {
	return nil
}
func (Log) Length() int64 {
	return 3
}
func (Log) IsAbsent() bool {
	return false
}
func (Log) IsNull() bool {
	return false
}
func (Log) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsBool()
}
func (Log) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsInt()
}
func (Log) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsFloat()
}
func (Log) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsString()
}
func (Log) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsBytes()
}
func (Log) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Log"}.AsLink()
}
func (Log) Prototype() ipld.NodePrototype {
	return _Log__Prototype{}
}

type _Log__Prototype struct{}

func (_Log__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Log__Builder
	nb.Reset()
	return &nb
}

type _Log__Builder struct {
	_Log__Assembler
}

func (nb *_Log__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Log__Builder) Reset() {
	var w _Log
	var m schema.Maybe
	*nb = _Log__Builder{_Log__Assembler{w: &w, m: &m}}
}

type _Log__Assembler struct {
	w     *_Log
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Address _Address__Assembler
	ca_Topics  _Topics__Assembler
	ca_Data    _Bytes__Assembler
}

func (na *_Log__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_Topics.reset()
	na.ca_Data.reset()
}

var (
	fieldBit__Log_Address     = 1 << 0
	fieldBit__Log_Topics      = 1 << 1
	fieldBit__Log_Data        = 1 << 2
	fieldBits__Log_sufficient = 0 + 1<<0 + 1<<1 + 1<<2
)

func (na *_Log__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Log{}
	}
	return na, nil
}
func (_Log__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.BeginList(0)
}
func (na *_Log__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Log__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignBool(false)
}
func (_Log__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignInt(0)
}
func (_Log__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignFloat(0)
}
func (_Log__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignString("")
}
func (_Log__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignBytes(nil)
}
func (_Log__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Log"}.AssignLink(nil)
}
func (na *_Log__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Log); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Log", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Log__Assembler) Prototype() ipld.NodePrototype {
	return _Log__Prototype{}
}
func (ma *_Log__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Address.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Topics.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Log__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Log_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address}
		}
		ma.s += fieldBit__Log_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "Topics":
		if ma.s&fieldBit__Log_Topics != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics}
		}
		ma.s += fieldBit__Log_Topics
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics, nil
	case "Data":
		if ma.s&fieldBit__Log_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data}
		}
		ma.s += fieldBit__Log_Data
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Log", Key: &_String{k}}
}
func (ma *_Log__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Log__KeyAssembler)(ma)
}
func (ma *_Log__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics
	case 2:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	default:
		panic("unreachable")
	}
}
func (ma *_Log__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Log_sufficient != fieldBits__Log_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Log_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Log_Topics == 0 {
			err.Missing = append(err.Missing, "Topics")
		}
		if ma.s&fieldBit__Log_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Log__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Log__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Log__KeyAssembler _Log__Assembler

func (_Log__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.BeginMap(0)
}
func (_Log__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.BeginList(0)
}
func (na *_Log__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignNull()
}
func (_Log__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignBool(false)
}
func (_Log__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignInt(0)
}
func (_Log__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Log__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Log_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address}
		}
		ka.s += fieldBit__Log_Address
		ka.state = maState_expectValue
		ka.f = 0
	case "Topics":
		if ka.s&fieldBit__Log_Topics != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics}
		}
		ka.s += fieldBit__Log_Topics
		ka.state = maState_expectValue
		ka.f = 1
	case "Data":
		if ka.s&fieldBit__Log_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data}
		}
		ka.s += fieldBit__Log_Data
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Log", Key: &_String{k}}
	}
	return nil
}
func (_Log__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignBytes(nil)
}
func (_Log__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Log__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Log__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Log) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Log) Representation() ipld.Node {
	return (*_Log__Repr)(n)
}

type _Log__Repr _Log

var (
	fieldName__Log_Address_serial = _String{"Address"}
	fieldName__Log_Topics_serial  = _String{"Topics"}
	fieldName__Log_Data_serial    = _String{"Data"}
)
var _ ipld.Node = &_Log__Repr{}

func (_Log__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Log__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Address":
		return n.Address.Representation(), nil
	case "Topics":
		return n.Topics.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Log__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Log__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.LookupByIndex(0)
}
func (n _Log__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Log__Repr) MapIterator() ipld.MapIterator {
	return &_Log__ReprMapItr{n, 0}
}

type _Log__ReprMapItr struct {
	n   *_Log__Repr
	idx int
}

func (itr *_Log__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Log_Address_serial
		v = itr.n.Address.Representation()
	case 1:
		k = &fieldName__Log_Topics_serial
		v = itr.n.Topics.Representation()
	case 2:
		k = &fieldName__Log_Data_serial
		v = itr.n.Data.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Log__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_Log__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Log__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_Log__Repr) IsAbsent() bool {
	return false
}
func (_Log__Repr) IsNull() bool {
	return false
}
func (_Log__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsBool()
}
func (_Log__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsInt()
}
func (_Log__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsFloat()
}
func (_Log__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsString()
}
func (_Log__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsBytes()
}
func (_Log__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Log.Repr"}.AsLink()
}
func (_Log__Repr) Prototype() ipld.NodePrototype {
	return _Log__ReprPrototype{}
}

type _Log__ReprPrototype struct{}

func (_Log__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Log__ReprBuilder
	nb.Reset()
	return &nb
}

type _Log__ReprBuilder struct {
	_Log__ReprAssembler
}

func (nb *_Log__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Log__ReprBuilder) Reset() {
	var w _Log
	var m schema.Maybe
	*nb = _Log__ReprBuilder{_Log__ReprAssembler{w: &w, m: &m}}
}

type _Log__ReprAssembler struct {
	w     *_Log
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm         schema.Maybe
	ca_Address _Address__ReprAssembler
	ca_Topics  _Topics__ReprAssembler
	ca_Data    _Bytes__ReprAssembler
}

func (na *_Log__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Address.reset()
	na.ca_Topics.reset()
	na.ca_Data.reset()
}
func (na *_Log__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Log{}
	}
	return na, nil
}
func (_Log__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.BeginList(0)
}
func (na *_Log__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Log.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Log__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignBool(false)
}
func (_Log__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignInt(0)
}
func (_Log__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignFloat(0)
}
func (_Log__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignString("")
}
func (_Log__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignBytes(nil)
}
func (_Log__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Log.Repr"}.AssignLink(nil)
}
func (na *_Log__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Log); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Log.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Log__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Log__ReprPrototype{}
}
func (ma *_Log__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Log__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Address":
		if ma.s&fieldBit__Log_Address != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address_serial}
		}
		ma.s += fieldBit__Log_Address
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address, nil
	case "Topics":
		if ma.s&fieldBit__Log_Topics != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics_serial}
		}
		ma.s += fieldBit__Log_Topics
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics, nil
	case "Data":
		if ma.s&fieldBit__Log_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data_serial}
		}
		ma.s += fieldBit__Log_Data
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Log.Repr", Key: &_String{k}}
}
func (ma *_Log__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Log__ReprKeyAssembler)(ma)
}
func (ma *_Log__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Address.w = &ma.w.Address
		ma.ca_Address.m = &ma.cm
		return &ma.ca_Address
	case 1:
		ma.ca_Topics.w = &ma.w.Topics
		ma.ca_Topics.m = &ma.cm
		return &ma.ca_Topics
	case 2:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	default:
		panic("unreachable")
	}
}
func (ma *_Log__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Log_sufficient != fieldBits__Log_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Log_Address == 0 {
			err.Missing = append(err.Missing, "Address")
		}
		if ma.s&fieldBit__Log_Topics == 0 {
			err.Missing = append(err.Missing, "Topics")
		}
		if ma.s&fieldBit__Log_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Log__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Log__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Log__ReprKeyAssembler _Log__ReprAssembler

func (_Log__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Log__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Log__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignNull()
}
func (_Log__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Log__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Log__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Log__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Address":
		if ka.s&fieldBit__Log_Address != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Address_serial}
		}
		ka.s += fieldBit__Log_Address
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Topics":
		if ka.s&fieldBit__Log_Topics != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Topics_serial}
		}
		ka.s += fieldBit__Log_Topics
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Data":
		if ka.s&fieldBit__Log_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Log_Data_serial}
		}
		ka.s += fieldBit__Log_Data
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Log.Repr", Key: &_String{k}}
}
func (_Log__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Log__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Log.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Log__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Log__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Logs) Lookup(idx int64) Log {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Logs) LookupMaybe(idx int64) MaybeLog {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Log__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Logs__valueAbsent = _Log__Maybe{m: schema.Maybe_Absent}

func (n Logs) Iterator() *Logs__Itr {
	return &Logs__Itr{n, 0}
}

type Logs__Itr struct {
	n   Logs
	idx int
}

func (itr *Logs__Itr) Next() (idx int64, v Log) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Logs__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Logs__Maybe struct {
	m schema.Maybe
	v _Logs
}
type MaybeLogs = *_Logs__Maybe

func (m MaybeLogs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLogs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLogs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLogs) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeLogs) Must() Logs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Logs)(&_Logs{})
var _ schema.TypedNode = (Logs)(&_Logs{})

func (Logs) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Logs) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Logs"}.LookupByString("")
}
func (n Logs) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Logs) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Logs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Logs", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Logs) MapIterator() ipld.MapIterator {
	return nil
}
func (n Logs) ListIterator() ipld.ListIterator {
	return &_Logs__ListItr{n, 0}
}

type _Logs__ListItr struct {
	n   Logs
	idx int
}

func (itr *_Logs__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Logs__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Logs) Length() int64 {
	return int64(len(n.x))
}
func (Logs) IsAbsent() bool {
	return false
}
func (Logs) IsNull() bool {
	return false
}
func (Logs) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsBool()
}
func (Logs) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsInt()
}
func (Logs) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsFloat()
}
func (Logs) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsString()
}
func (Logs) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsBytes()
}
func (Logs) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Logs"}.AsLink()
}
func (Logs) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}

type _Logs__Prototype struct{}

func (_Logs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__Builder
	nb.Reset()
	return &nb
}

type _Logs__Builder struct {
	_Logs__Assembler
}

func (nb *_Logs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__Builder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__Builder{_Logs__Assembler{w: &w, m: &m}}
}

type _Logs__Assembler struct {
	w     *_Logs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Log__Assembler
}

func (na *_Logs__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Logs__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.BeginMap(0)
}
func (na *_Logs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Log, 0, sizeHint)
	}
	return na, nil
}
func (na *_Logs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignBool(false)
}
func (_Logs__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignInt(0)
}
func (_Logs__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignFloat(0)
}
func (_Logs__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignString("")
}
func (_Logs__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignBytes(nil)
}
func (_Logs__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs"}.AssignLink(nil)
}
func (na *_Logs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Logs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__Assembler) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}
func (la *_Logs__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Logs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Log{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Logs__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Logs__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Log__Prototype{}
}
func (Logs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Logs) Representation() ipld.Node {
	return (*_Logs__Repr)(n)
}

type _Logs__Repr _Logs

var _ ipld.Node = &_Logs__Repr{}

func (_Logs__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Logs__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.LookupByString("")
}
func (nr *_Logs__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Logs)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Log).Representation(), nil
}
func (nr *_Logs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Logs)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Log).Representation(), nil
}
func (n _Logs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Logs.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Logs__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Logs__Repr) ListIterator() ipld.ListIterator {
	return &_Logs__ReprListItr{(Logs)(nr), 0}
}

type _Logs__ReprListItr _Logs__ListItr

func (itr *_Logs__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Logs__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Log).Representation(), nil
}
func (itr *_Logs__ReprListItr) Done() bool {
	return (*_Logs__ListItr)(itr).Done()
}

func (rn *_Logs__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Logs__Repr) IsAbsent() bool {
	return false
}
func (_Logs__Repr) IsNull() bool {
	return false
}
func (_Logs__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsBool()
}
func (_Logs__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsInt()
}
func (_Logs__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsFloat()
}
func (_Logs__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsString()
}
func (_Logs__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsBytes()
}
func (_Logs__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Logs.Repr"}.AsLink()
}
func (_Logs__Repr) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}

type _Logs__ReprPrototype struct{}

func (_Logs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__ReprBuilder
	nb.Reset()
	return &nb
}

type _Logs__ReprBuilder struct {
	_Logs__ReprAssembler
}

func (nb *_Logs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__ReprBuilder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__ReprBuilder{_Logs__ReprAssembler{w: &w, m: &m}}
}

type _Logs__ReprAssembler struct {
	w     *_Logs
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Log__ReprAssembler
}

func (na *_Logs__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Logs__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.BeginMap(0)
}
func (na *_Logs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Log, 0, sizeHint)
	}
	return na, nil
}
func (na *_Logs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Logs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignBool(false)
}
func (_Logs__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignInt(0)
}
func (_Logs__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignFloat(0)
}
func (_Logs__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignString("")
}
func (_Logs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignBytes(nil)
}
func (_Logs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Logs.Repr"}.AssignLink(nil)
}
func (na *_Logs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Logs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}
func (la *_Logs__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Logs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Log{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Logs__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Logs__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Log__ReprPrototype{}
}

func (n OpCode) Bytes() []byte {
	return n.x
}
func (_OpCode__Prototype) FromBytes(v []byte) (OpCode, error) {
	n := _OpCode{v}
	return &n, nil
}

type _OpCode__Maybe struct {
	m schema.Maybe
	v _OpCode
}
type MaybeOpCode = *_OpCode__Maybe

func (m MaybeOpCode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeOpCode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeOpCode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeOpCode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeOpCode) Must() OpCode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (OpCode)(&_OpCode{})
var _ schema.TypedNode = (OpCode)(&_OpCode{})

func (OpCode) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (OpCode) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.LookupByString("")
}
func (OpCode) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.LookupByNode(nil)
}
func (OpCode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.LookupByIndex(0)
}
func (OpCode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.LookupBySegment(seg)
}
func (OpCode) MapIterator() ipld.MapIterator {
	return nil
}
func (OpCode) ListIterator() ipld.ListIterator {
	return nil
}
func (OpCode) Length() int64 {
	return -1
}
func (OpCode) IsAbsent() bool {
	return false
}
func (OpCode) IsNull() bool {
	return false
}
func (OpCode) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.AsBool()
}
func (OpCode) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.AsInt()
}
func (OpCode) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.AsFloat()
}
func (OpCode) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.AsString()
}
func (n OpCode) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (OpCode) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.OpCode"}.AsLink()
}
func (OpCode) Prototype() ipld.NodePrototype {
	return _OpCode__Prototype{}
}

type _OpCode__Prototype struct{}

func (_OpCode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _OpCode__Builder
	nb.Reset()
	return &nb
}

type _OpCode__Builder struct {
	_OpCode__Assembler
}

func (nb *_OpCode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_OpCode__Builder) Reset() {
	var w _OpCode
	var m schema.Maybe
	*nb = _OpCode__Builder{_OpCode__Assembler{w: &w, m: &m}}
}

type _OpCode__Assembler struct {
	w *_OpCode
	m *schema.Maybe
}

func (na *_OpCode__Assembler) reset() {}
func (_OpCode__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.BeginMap(0)
}
func (_OpCode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.BeginList(0)
}
func (na *_OpCode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_OpCode__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignBool(false)
}
func (_OpCode__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignInt(0)
}
func (_OpCode__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignFloat(0)
}
func (_OpCode__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignString("")
}
func (na *_OpCode__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_OpCode__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.OpCode"}.AssignLink(nil)
}
func (na *_OpCode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_OpCode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_OpCode__Assembler) Prototype() ipld.NodePrototype {
	return _OpCode__Prototype{}
}
func (OpCode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n OpCode) Representation() ipld.Node {
	return (*_OpCode__Repr)(n)
}

type _OpCode__Repr = _OpCode

var _ ipld.Node = &_OpCode__Repr{}

type _OpCode__ReprPrototype = _OpCode__Prototype
type _OpCode__ReprAssembler = _OpCode__Assembler

func (n _Receipt) FieldTxType() TxType {
	return &n.TxType
}
func (n _Receipt) FieldPostState() MaybeBytes {
	return &n.PostState
}
func (n _Receipt) FieldStatus() MaybeUint {
	return &n.Status
}
func (n _Receipt) FieldCumulativeGasUsed() Uint {
	return &n.CumulativeGasUsed
}
func (n _Receipt) FieldBloom() Bloom {
	return &n.Bloom
}
func (n _Receipt) FieldLogs() Logs {
	return &n.Logs
}
func (n _Receipt) FieldLogRootCID() Link {
	return &n.LogRootCID
}

type _Receipt__Maybe struct {
	m schema.Maybe
	v Receipt
}
type MaybeReceipt = *_Receipt__Maybe

func (m MaybeReceipt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeReceipt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeReceipt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeReceipt) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeReceipt) Must() Receipt {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Receipt_TxType            = _String{"TxType"}
	fieldName__Receipt_PostState         = _String{"PostState"}
	fieldName__Receipt_Status            = _String{"Status"}
	fieldName__Receipt_CumulativeGasUsed = _String{"CumulativeGasUsed"}
	fieldName__Receipt_Bloom             = _String{"Bloom"}
	fieldName__Receipt_Logs              = _String{"Logs"}
	fieldName__Receipt_LogRootCID        = _String{"LogRootCID"}
)
var _ ipld.Node = (Receipt)(&_Receipt{})
var _ schema.TypedNode = (Receipt)(&_Receipt{})

func (Receipt) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Receipt) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxType":
		return &n.TxType, nil
	case "PostState":
		if n.PostState.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.PostState.v, nil
	case "Status":
		if n.Status.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.Status.v, nil
	case "CumulativeGasUsed":
		return &n.CumulativeGasUsed, nil
	case "Bloom":
		return &n.Bloom, nil
	case "Logs":
		return &n.Logs, nil
	case "LogRootCID":
		return &n.LogRootCID, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Receipt) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Receipt) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.LookupByIndex(0)
}
func (n Receipt) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Receipt) MapIterator() ipld.MapIterator {
	return &_Receipt__MapItr{n, 0}
}

type _Receipt__MapItr struct {
	n   Receipt
	idx int
}

func (itr *_Receipt__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Receipt_TxType
		v = &itr.n.TxType
	case 1:
		k = &fieldName__Receipt_PostState
		if itr.n.PostState.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.PostState.v
	case 2:
		k = &fieldName__Receipt_Status
		if itr.n.Status.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.Status.v
	case 3:
		k = &fieldName__Receipt_CumulativeGasUsed
		v = &itr.n.CumulativeGasUsed
	case 4:
		k = &fieldName__Receipt_Bloom
		v = &itr.n.Bloom
	case 5:
		k = &fieldName__Receipt_Logs
		v = &itr.n.Logs
	case 6:
		k = &fieldName__Receipt_LogRootCID
		v = &itr.n.LogRootCID
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Receipt__MapItr) Done() bool {
	return itr.idx >= 7
}

func (Receipt) ListIterator() ipld.ListIterator {
	return nil
}
func (Receipt) Length() int64 {
	return 7
}
func (Receipt) IsAbsent() bool {
	return false
}
func (Receipt) IsNull() bool {
	return false
}
func (Receipt) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsBool()
}
func (Receipt) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsInt()
}
func (Receipt) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsFloat()
}
func (Receipt) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsString()
}
func (Receipt) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsBytes()
}
func (Receipt) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Receipt"}.AsLink()
}
func (Receipt) Prototype() ipld.NodePrototype {
	return _Receipt__Prototype{}
}

type _Receipt__Prototype struct{}

func (_Receipt__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipt__Builder
	nb.Reset()
	return &nb
}

type _Receipt__Builder struct {
	_Receipt__Assembler
}

func (nb *_Receipt__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipt__Builder) Reset() {
	var w _Receipt
	var m schema.Maybe
	*nb = _Receipt__Builder{_Receipt__Assembler{w: &w, m: &m}}
}

type _Receipt__Assembler struct {
	w     *_Receipt
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                   schema.Maybe
	ca_TxType            _TxType__Assembler
	ca_PostState         _Bytes__Assembler
	ca_Status            _Uint__Assembler
	ca_CumulativeGasUsed _Uint__Assembler
	ca_Bloom             _Bloom__Assembler
	ca_Logs              _Logs__Assembler
	ca_LogRootCID        _Link__Assembler
}

func (na *_Receipt__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxType.reset()
	na.ca_PostState.reset()
	na.ca_Status.reset()
	na.ca_CumulativeGasUsed.reset()
	na.ca_Bloom.reset()
	na.ca_Logs.reset()
	na.ca_LogRootCID.reset()
}

var (
	fieldBit__Receipt_TxType            = 1 << 0
	fieldBit__Receipt_PostState         = 1 << 1
	fieldBit__Receipt_Status            = 1 << 2
	fieldBit__Receipt_CumulativeGasUsed = 1 << 3
	fieldBit__Receipt_Bloom             = 1 << 4
	fieldBit__Receipt_Logs              = 1 << 5
	fieldBit__Receipt_LogRootCID        = 1 << 6
	fieldBits__Receipt_sufficient       = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6
)

func (na *_Receipt__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Receipt{}
	}
	return na, nil
}
func (_Receipt__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.BeginList(0)
}
func (na *_Receipt__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipt__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignBool(false)
}
func (_Receipt__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignInt(0)
}
func (_Receipt__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignFloat(0)
}
func (_Receipt__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignString("")
}
func (_Receipt__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignBytes(nil)
}
func (_Receipt__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt"}.AssignLink(nil)
}
func (na *_Receipt__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipt", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipt__Assembler) Prototype() ipld.NodePrototype {
	return _Receipt__Prototype{}
}
func (ma *_Receipt__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TxType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.PostState.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Status.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CumulativeGasUsed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Bloom.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Logs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_LogRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxType":
		if ma.s&fieldBit__Receipt_TxType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_TxType}
		}
		ma.s += fieldBit__Receipt_TxType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType, nil
	case "PostState":
		if ma.s&fieldBit__Receipt_PostState != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostState}
		}
		ma.s += fieldBit__Receipt_PostState
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PostState.w = &ma.w.PostState.v
		ma.ca_PostState.m = &ma.w.PostState.m
		ma.w.PostState.m = allowNull
		return &ma.ca_PostState, nil
	case "Status":
		if ma.s&fieldBit__Receipt_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Status}
		}
		ma.s += fieldBit__Receipt_Status
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Status.w = &ma.w.Status.v
		ma.ca_Status.m = &ma.w.Status.m
		ma.w.Status.m = allowNull
		return &ma.ca_Status, nil
	case "CumulativeGasUsed":
		if ma.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed}
		}
		ma.s += fieldBit__Receipt_CumulativeGasUsed
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed, nil
	case "Bloom":
		if ma.s&fieldBit__Receipt_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom}
		}
		ma.s += fieldBit__Receipt_Bloom
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Logs":
		if ma.s&fieldBit__Receipt_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs}
		}
		ma.s += fieldBit__Receipt_Logs
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	case "LogRootCID":
		if ma.s&fieldBit__Receipt_LogRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_LogRootCID}
		}
		ma.s += fieldBit__Receipt_LogRootCID
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_LogRootCID.w = &ma.w.LogRootCID
		ma.ca_LogRootCID.m = &ma.cm
		return &ma.ca_LogRootCID, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Receipt", Key: &_String{k}}
}
func (ma *_Receipt__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Receipt__KeyAssembler)(ma)
}
func (ma *_Receipt__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType
	case 1:
		ma.ca_PostState.w = &ma.w.PostState.v
		ma.ca_PostState.m = &ma.w.PostState.m
		ma.w.PostState.m = allowNull
		return &ma.ca_PostState
	case 2:
		ma.ca_Status.w = &ma.w.Status.v
		ma.ca_Status.m = &ma.w.Status.m
		ma.w.Status.m = allowNull
		return &ma.ca_Status
	case 3:
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed
	case 4:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 5:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	case 6:
		ma.ca_LogRootCID.w = &ma.w.LogRootCID
		ma.ca_LogRootCID.m = &ma.cm
		return &ma.ca_LogRootCID
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Receipt_sufficient != fieldBits__Receipt_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Receipt_TxType == 0 {
			err.Missing = append(err.Missing, "TxType")
		}
		if ma.s&fieldBit__Receipt_CumulativeGasUsed == 0 {
			err.Missing = append(err.Missing, "CumulativeGasUsed")
		}
		if ma.s&fieldBit__Receipt_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Receipt_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		if ma.s&fieldBit__Receipt_LogRootCID == 0 {
			err.Missing = append(err.Missing, "LogRootCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Receipt__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Receipt__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Receipt__KeyAssembler _Receipt__Assembler

func (_Receipt__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.BeginMap(0)
}
func (_Receipt__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.BeginList(0)
}
func (na *_Receipt__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignNull()
}
func (_Receipt__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignBool(false)
}
func (_Receipt__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignInt(0)
}
func (_Receipt__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Receipt__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxType":
		if ka.s&fieldBit__Receipt_TxType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_TxType}
		}
		ka.s += fieldBit__Receipt_TxType
		ka.state = maState_expectValue
		ka.f = 0
	case "PostState":
		if ka.s&fieldBit__Receipt_PostState != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostState}
		}
		ka.s += fieldBit__Receipt_PostState
		ka.state = maState_expectValue
		ka.f = 1
	case "Status":
		if ka.s&fieldBit__Receipt_Status != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Status}
		}
		ka.s += fieldBit__Receipt_Status
		ka.state = maState_expectValue
		ka.f = 2
	case "CumulativeGasUsed":
		if ka.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed}
		}
		ka.s += fieldBit__Receipt_CumulativeGasUsed
		ka.state = maState_expectValue
		ka.f = 3
	case "Bloom":
		if ka.s&fieldBit__Receipt_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom}
		}
		ka.s += fieldBit__Receipt_Bloom
		ka.state = maState_expectValue
		ka.f = 4
	case "Logs":
		if ka.s&fieldBit__Receipt_Logs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs}
		}
		ka.s += fieldBit__Receipt_Logs
		ka.state = maState_expectValue
		ka.f = 5
	case "LogRootCID":
		if ka.s&fieldBit__Receipt_LogRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_LogRootCID}
		}
		ka.s += fieldBit__Receipt_LogRootCID
		ka.state = maState_expectValue
		ka.f = 6
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Receipt", Key: &_String{k}}
	}
	return nil
}
func (_Receipt__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignBytes(nil)
}
func (_Receipt__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Receipt__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Receipt__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Receipt) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Receipt) Representation() ipld.Node {
	return (*_Receipt__Repr)(n)
}

type _Receipt__Repr _Receipt

var (
	fieldName__Receipt_TxType_serial            = _String{"TxType"}
	fieldName__Receipt_PostState_serial         = _String{"PostState"}
	fieldName__Receipt_Status_serial            = _String{"Status"}
	fieldName__Receipt_CumulativeGasUsed_serial = _String{"CumulativeGasUsed"}
	fieldName__Receipt_Bloom_serial             = _String{"Bloom"}
	fieldName__Receipt_Logs_serial              = _String{"Logs"}
	fieldName__Receipt_LogRootCID_serial        = _String{"LogRootCID"}
)
var _ ipld.Node = &_Receipt__Repr{}

func (_Receipt__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Receipt__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxType":
		return n.TxType.Representation(), nil
	case "PostState":
		if n.PostState.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.PostState.v.Representation(), nil
	case "Status":
		if n.Status.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Status.v.Representation(), nil
	case "CumulativeGasUsed":
		return n.CumulativeGasUsed.Representation(), nil
	case "Bloom":
		return n.Bloom.Representation(), nil
	case "Logs":
		return n.Logs.Representation(), nil
	case "LogRootCID":
		return n.LogRootCID.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Receipt__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Receipt__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.LookupByIndex(0)
}
func (n _Receipt__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Receipt__Repr) MapIterator() ipld.MapIterator {
	return &_Receipt__ReprMapItr{n, 0}
}

type _Receipt__ReprMapItr struct {
	n   *_Receipt__Repr
	idx int
}

func (itr *_Receipt__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 7 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Receipt_TxType_serial
		v = itr.n.TxType.Representation()
	case 1:
		k = &fieldName__Receipt_PostState_serial
		if itr.n.PostState.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.PostState.v.Representation()
	case 2:
		k = &fieldName__Receipt_Status_serial
		if itr.n.Status.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Status.v.Representation()
	case 3:
		k = &fieldName__Receipt_CumulativeGasUsed_serial
		v = itr.n.CumulativeGasUsed.Representation()
	case 4:
		k = &fieldName__Receipt_Bloom_serial
		v = itr.n.Bloom.Representation()
	case 5:
		k = &fieldName__Receipt_Logs_serial
		v = itr.n.Logs.Representation()
	case 6:
		k = &fieldName__Receipt_LogRootCID_serial
		v = itr.n.LogRootCID.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Receipt__ReprMapItr) Done() bool {
	return itr.idx >= 7
}
func (_Receipt__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Receipt__Repr) Length() int64 {
	l := 7
	return int64(l)
}
func (_Receipt__Repr) IsAbsent() bool {
	return false
}
func (_Receipt__Repr) IsNull() bool {
	return false
}
func (_Receipt__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsBool()
}
func (_Receipt__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsInt()
}
func (_Receipt__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsFloat()
}
func (_Receipt__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsString()
}
func (_Receipt__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsBytes()
}
func (_Receipt__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Receipt.Repr"}.AsLink()
}
func (_Receipt__Repr) Prototype() ipld.NodePrototype {
	return _Receipt__ReprPrototype{}
}

type _Receipt__ReprPrototype struct{}

func (_Receipt__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipt__ReprBuilder
	nb.Reset()
	return &nb
}

type _Receipt__ReprBuilder struct {
	_Receipt__ReprAssembler
}

func (nb *_Receipt__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipt__ReprBuilder) Reset() {
	var w _Receipt
	var m schema.Maybe
	*nb = _Receipt__ReprBuilder{_Receipt__ReprAssembler{w: &w, m: &m}}
}

type _Receipt__ReprAssembler struct {
	w     *_Receipt
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm                   schema.Maybe
	ca_TxType            _TxType__ReprAssembler
	ca_PostState         _Bytes__ReprAssembler
	ca_Status            _Uint__ReprAssembler
	ca_CumulativeGasUsed _Uint__ReprAssembler
	ca_Bloom             _Bloom__ReprAssembler
	ca_Logs              _Logs__ReprAssembler
	ca_LogRootCID        _Link__ReprAssembler
}

func (na *_Receipt__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxType.reset()
	na.ca_PostState.reset()
	na.ca_Status.reset()
	na.ca_CumulativeGasUsed.reset()
	na.ca_Bloom.reset()
	na.ca_Logs.reset()
	na.ca_LogRootCID.reset()
}
func (na *_Receipt__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Receipt{}
	}
	return na, nil
}
func (_Receipt__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.BeginList(0)
}
func (na *_Receipt__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipt__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignBool(false)
}
func (_Receipt__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignInt(0)
}
func (_Receipt__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignFloat(0)
}
func (_Receipt__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignString("")
}
func (_Receipt__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignBytes(nil)
}
func (_Receipt__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Receipt.Repr"}.AssignLink(nil)
}
func (na *_Receipt__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipt); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipt.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipt__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Receipt__ReprPrototype{}
}
func (ma *_Receipt__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.PostState.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Status.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxType":
		if ma.s&fieldBit__Receipt_TxType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_TxType_serial}
		}
		ma.s += fieldBit__Receipt_TxType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType, nil
	case "PostState":
		if ma.s&fieldBit__Receipt_PostState != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostState_serial}
		}
		ma.s += fieldBit__Receipt_PostState
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PostState.w = &ma.w.PostState.v
		ma.ca_PostState.m = &ma.w.PostState.m
		ma.w.PostState.m = allowNull
		return &ma.ca_PostState, nil
	case "Status":
		if ma.s&fieldBit__Receipt_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Status_serial}
		}
		ma.s += fieldBit__Receipt_Status
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Status.w = &ma.w.Status.v
		ma.ca_Status.m = &ma.w.Status.m
		ma.w.Status.m = allowNull
		return &ma.ca_Status, nil
	case "CumulativeGasUsed":
		if ma.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed_serial}
		}
		ma.s += fieldBit__Receipt_CumulativeGasUsed
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed, nil
	case "Bloom":
		if ma.s&fieldBit__Receipt_Bloom != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom_serial}
		}
		ma.s += fieldBit__Receipt_Bloom
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom, nil
	case "Logs":
		if ma.s&fieldBit__Receipt_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs_serial}
		}
		ma.s += fieldBit__Receipt_Logs
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	case "LogRootCID":
		if ma.s&fieldBit__Receipt_LogRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_LogRootCID_serial}
		}
		ma.s += fieldBit__Receipt_LogRootCID
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_LogRootCID.w = &ma.w.LogRootCID
		ma.ca_LogRootCID.m = &ma.cm
		return &ma.ca_LogRootCID, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Receipt.Repr", Key: &_String{k}}
}
func (ma *_Receipt__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Receipt__ReprKeyAssembler)(ma)
}
func (ma *_Receipt__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType
	case 1:
		ma.ca_PostState.w = &ma.w.PostState.v
		ma.ca_PostState.m = &ma.w.PostState.m
		ma.w.PostState.m = allowNull
		return &ma.ca_PostState
	case 2:
		ma.ca_Status.w = &ma.w.Status.v
		ma.ca_Status.m = &ma.w.Status.m
		ma.w.Status.m = allowNull
		return &ma.ca_Status
	case 3:
		ma.ca_CumulativeGasUsed.w = &ma.w.CumulativeGasUsed
		ma.ca_CumulativeGasUsed.m = &ma.cm
		return &ma.ca_CumulativeGasUsed
	case 4:
		ma.ca_Bloom.w = &ma.w.Bloom
		ma.ca_Bloom.m = &ma.cm
		return &ma.ca_Bloom
	case 5:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	case 6:
		ma.ca_LogRootCID.w = &ma.w.LogRootCID
		ma.ca_LogRootCID.m = &ma.cm
		return &ma.ca_LogRootCID
	default:
		panic("unreachable")
	}
}
func (ma *_Receipt__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Receipt_sufficient != fieldBits__Receipt_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Receipt_TxType == 0 {
			err.Missing = append(err.Missing, "TxType")
		}
		if ma.s&fieldBit__Receipt_CumulativeGasUsed == 0 {
			err.Missing = append(err.Missing, "CumulativeGasUsed")
		}
		if ma.s&fieldBit__Receipt_Bloom == 0 {
			err.Missing = append(err.Missing, "Bloom")
		}
		if ma.s&fieldBit__Receipt_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		if ma.s&fieldBit__Receipt_LogRootCID == 0 {
			err.Missing = append(err.Missing, "LogRootCID")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Receipt__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Receipt__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Receipt__ReprKeyAssembler _Receipt__ReprAssembler

func (_Receipt__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Receipt__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Receipt__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignNull()
}
func (_Receipt__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Receipt__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Receipt__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Receipt__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxType":
		if ka.s&fieldBit__Receipt_TxType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_TxType_serial}
		}
		ka.s += fieldBit__Receipt_TxType
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "PostState":
		if ka.s&fieldBit__Receipt_PostState != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_PostState_serial}
		}
		ka.s += fieldBit__Receipt_PostState
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Status":
		if ka.s&fieldBit__Receipt_Status != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Status_serial}
		}
		ka.s += fieldBit__Receipt_Status
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "CumulativeGasUsed":
		if ka.s&fieldBit__Receipt_CumulativeGasUsed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_CumulativeGasUsed_serial}
		}
		ka.s += fieldBit__Receipt_CumulativeGasUsed
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Bloom":
		if ka.s&fieldBit__Receipt_Bloom != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Bloom_serial}
		}
		ka.s += fieldBit__Receipt_Bloom
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Logs":
		if ka.s&fieldBit__Receipt_Logs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_Logs_serial}
		}
		ka.s += fieldBit__Receipt_Logs
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "LogRootCID":
		if ka.s&fieldBit__Receipt_LogRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Receipt_LogRootCID_serial}
		}
		ka.s += fieldBit__Receipt_LogRootCID
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Receipt.Repr", Key: &_String{k}}
}
func (_Receipt__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Receipt__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Receipt.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Receipt__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Receipt__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Receipts) Lookup(idx int64) Receipt {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Receipts) LookupMaybe(idx int64) MaybeReceipt {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Receipt__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Receipts__valueAbsent = _Receipt__Maybe{m: schema.Maybe_Absent}

func (n Receipts) Iterator() *Receipts__Itr {
	return &Receipts__Itr{n, 0}
}

type Receipts__Itr struct {
	n   Receipts
	idx int
}

func (itr *Receipts__Itr) Next() (idx int64, v Receipt) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Receipts__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Receipts__Maybe struct {
	m schema.Maybe
	v _Receipts
}
type MaybeReceipts = *_Receipts__Maybe

func (m MaybeReceipts) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeReceipts) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeReceipts) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeReceipts) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeReceipts) Must() Receipts {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Receipts)(&_Receipts{})
var _ schema.TypedNode = (Receipts)(&_Receipts{})

func (Receipts) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Receipts) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.LookupByString("")
}
func (n Receipts) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Receipts) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Receipts) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Receipts", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Receipts) MapIterator() ipld.MapIterator {
	return nil
}
func (n Receipts) ListIterator() ipld.ListIterator {
	return &_Receipts__ListItr{n, 0}
}

type _Receipts__ListItr struct {
	n   Receipts
	idx int
}

func (itr *_Receipts__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Receipts__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Receipts) Length() int64 {
	return int64(len(n.x))
}
func (Receipts) IsAbsent() bool {
	return false
}
func (Receipts) IsNull() bool {
	return false
}
func (Receipts) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsBool()
}
func (Receipts) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsInt()
}
func (Receipts) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsFloat()
}
func (Receipts) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsString()
}
func (Receipts) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsBytes()
}
func (Receipts) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Receipts"}.AsLink()
}
func (Receipts) Prototype() ipld.NodePrototype {
	return _Receipts__Prototype{}
}

type _Receipts__Prototype struct{}

func (_Receipts__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipts__Builder
	nb.Reset()
	return &nb
}

type _Receipts__Builder struct {
	_Receipts__Assembler
}

func (nb *_Receipts__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipts__Builder) Reset() {
	var w _Receipts
	var m schema.Maybe
	*nb = _Receipts__Builder{_Receipts__Assembler{w: &w, m: &m}}
}

type _Receipts__Assembler struct {
	w     *_Receipts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Receipt__Assembler
}

func (na *_Receipts__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Receipts__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.BeginMap(0)
}
func (na *_Receipts__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Receipt, 0, sizeHint)
	}
	return na, nil
}
func (na *_Receipts__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipts__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignBool(false)
}
func (_Receipts__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignInt(0)
}
func (_Receipts__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignFloat(0)
}
func (_Receipts__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignString("")
}
func (_Receipts__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignBytes(nil)
}
func (_Receipts__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts"}.AssignLink(nil)
}
func (na *_Receipts__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipts", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipts__Assembler) Prototype() ipld.NodePrototype {
	return _Receipts__Prototype{}
}
func (la *_Receipts__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Receipts__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Receipt{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Receipts__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Receipts__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Receipt__Prototype{}
}
func (Receipts) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Receipts) Representation() ipld.Node {
	return (*_Receipts__Repr)(n)
}

type _Receipts__Repr _Receipts

var _ ipld.Node = &_Receipts__Repr{}

func (_Receipts__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Receipts__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.LookupByString("")
}
func (nr *_Receipts__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Receipts)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Receipt).Representation(), nil
}
func (nr *_Receipts__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Receipts)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Receipt).Representation(), nil
}
func (n _Receipts__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Receipts.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Receipts__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Receipts__Repr) ListIterator() ipld.ListIterator {
	return &_Receipts__ReprListItr{(Receipts)(nr), 0}
}

type _Receipts__ReprListItr _Receipts__ListItr

func (itr *_Receipts__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Receipts__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Receipt).Representation(), nil
}
func (itr *_Receipts__ReprListItr) Done() bool {
	return (*_Receipts__ListItr)(itr).Done()
}

func (rn *_Receipts__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Receipts__Repr) IsAbsent() bool {
	return false
}
func (_Receipts__Repr) IsNull() bool {
	return false
}
func (_Receipts__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsBool()
}
func (_Receipts__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsInt()
}
func (_Receipts__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsFloat()
}
func (_Receipts__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsString()
}
func (_Receipts__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsBytes()
}
func (_Receipts__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Receipts.Repr"}.AsLink()
}
func (_Receipts__Repr) Prototype() ipld.NodePrototype {
	return _Receipts__ReprPrototype{}
}

type _Receipts__ReprPrototype struct{}

func (_Receipts__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Receipts__ReprBuilder
	nb.Reset()
	return &nb
}

type _Receipts__ReprBuilder struct {
	_Receipts__ReprAssembler
}

func (nb *_Receipts__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Receipts__ReprBuilder) Reset() {
	var w _Receipts
	var m schema.Maybe
	*nb = _Receipts__ReprBuilder{_Receipts__ReprAssembler{w: &w, m: &m}}
}

type _Receipts__ReprAssembler struct {
	w     *_Receipts
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Receipt__ReprAssembler
}

func (na *_Receipts__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Receipts__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.BeginMap(0)
}
func (na *_Receipts__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Receipt, 0, sizeHint)
	}
	return na, nil
}
func (na *_Receipts__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Receipts__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignBool(false)
}
func (_Receipts__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignInt(0)
}
func (_Receipts__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignFloat(0)
}
func (_Receipts__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignString("")
}
func (_Receipts__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignBytes(nil)
}
func (_Receipts__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Receipts.Repr"}.AssignLink(nil)
}
func (na *_Receipts__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Receipts); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Receipts.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Receipts__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Receipts__ReprPrototype{}
}
func (la *_Receipts__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Receipts__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Receipt{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Receipts__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Receipts__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Receipt__ReprPrototype{}
}

func (n *_StorageKeys) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_StorageKeys) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: *v,
	}
}

var _StorageKeys__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n StorageKeys) Iterator() *StorageKeys__Itr {
	return &StorageKeys__Itr{n, 0}
}

type StorageKeys__Itr struct {
	n   StorageKeys
	idx int
}

func (itr *StorageKeys__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *StorageKeys__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _StorageKeys__Maybe struct {
	m schema.Maybe
	v _StorageKeys
}
type MaybeStorageKeys = *_StorageKeys__Maybe

func (m MaybeStorageKeys) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStorageKeys) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStorageKeys) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStorageKeys) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeStorageKeys) Must() StorageKeys {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (StorageKeys)(&_StorageKeys{})
var _ schema.TypedNode = (StorageKeys)(&_StorageKeys{})

func (StorageKeys) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (StorageKeys) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.LookupByString("")
}
func (n StorageKeys) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n StorageKeys) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n StorageKeys) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.StorageKeys", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (StorageKeys) MapIterator() ipld.MapIterator {
	return nil
}
func (n StorageKeys) ListIterator() ipld.ListIterator {
	return &_StorageKeys__ListItr{n, 0}
}

type _StorageKeys__ListItr struct {
	n   StorageKeys
	idx int
}

func (itr *_StorageKeys__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_StorageKeys__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n StorageKeys) Length() int64 {
	return int64(len(n.x))
}
func (StorageKeys) IsAbsent() bool {
	return false
}
func (StorageKeys) IsNull() bool {
	return false
}
func (StorageKeys) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsBool()
}
func (StorageKeys) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsInt()
}
func (StorageKeys) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsFloat()
}
func (StorageKeys) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsString()
}
func (StorageKeys) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsBytes()
}
func (StorageKeys) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.StorageKeys"}.AsLink()
}
func (StorageKeys) Prototype() ipld.NodePrototype {
	return _StorageKeys__Prototype{}
}

type _StorageKeys__Prototype struct{}

func (_StorageKeys__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageKeys__Builder
	nb.Reset()
	return &nb
}

type _StorageKeys__Builder struct {
	_StorageKeys__Assembler
}

func (nb *_StorageKeys__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageKeys__Builder) Reset() {
	var w _StorageKeys
	var m schema.Maybe
	*nb = _StorageKeys__Builder{_StorageKeys__Assembler{w: &w, m: &m}}
}

type _StorageKeys__Assembler struct {
	w     *_StorageKeys
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_StorageKeys__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_StorageKeys__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.BeginMap(0)
}
func (na *_StorageKeys__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_StorageKeys__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageKeys__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignBool(false)
}
func (_StorageKeys__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignInt(0)
}
func (_StorageKeys__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignFloat(0)
}
func (_StorageKeys__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignString("")
}
func (_StorageKeys__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignBytes(nil)
}
func (_StorageKeys__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys"}.AssignLink(nil)
}
func (na *_StorageKeys__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageKeys); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.StorageKeys", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageKeys__Assembler) Prototype() ipld.NodePrototype {
	return _StorageKeys__Prototype{}
}
func (la *_StorageKeys__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_StorageKeys__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_StorageKeys__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_StorageKeys__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (StorageKeys) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StorageKeys) Representation() ipld.Node {
	return (*_StorageKeys__Repr)(n)
}

type _StorageKeys__Repr _StorageKeys

var _ ipld.Node = &_StorageKeys__Repr{}

func (_StorageKeys__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_StorageKeys__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.LookupByString("")
}
func (nr *_StorageKeys__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (StorageKeys)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_StorageKeys__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (StorageKeys)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _StorageKeys__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.StorageKeys.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_StorageKeys__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_StorageKeys__Repr) ListIterator() ipld.ListIterator {
	return &_StorageKeys__ReprListItr{(StorageKeys)(nr), 0}
}

type _StorageKeys__ReprListItr _StorageKeys__ListItr

func (itr *_StorageKeys__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_StorageKeys__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_StorageKeys__ReprListItr) Done() bool {
	return (*_StorageKeys__ListItr)(itr).Done()
}

func (rn *_StorageKeys__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_StorageKeys__Repr) IsAbsent() bool {
	return false
}
func (_StorageKeys__Repr) IsNull() bool {
	return false
}
func (_StorageKeys__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsBool()
}
func (_StorageKeys__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsInt()
}
func (_StorageKeys__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsFloat()
}
func (_StorageKeys__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsString()
}
func (_StorageKeys__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsBytes()
}
func (_StorageKeys__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.StorageKeys.Repr"}.AsLink()
}
func (_StorageKeys__Repr) Prototype() ipld.NodePrototype {
	return _StorageKeys__ReprPrototype{}
}

type _StorageKeys__ReprPrototype struct{}

func (_StorageKeys__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageKeys__ReprBuilder
	nb.Reset()
	return &nb
}

type _StorageKeys__ReprBuilder struct {
	_StorageKeys__ReprAssembler
}

func (nb *_StorageKeys__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageKeys__ReprBuilder) Reset() {
	var w _StorageKeys
	var m schema.Maybe
	*nb = _StorageKeys__ReprBuilder{_StorageKeys__ReprAssembler{w: &w, m: &m}}
}

type _StorageKeys__ReprAssembler struct {
	w     *_StorageKeys
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_StorageKeys__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_StorageKeys__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.BeginMap(0)
}
func (na *_StorageKeys__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_StorageKeys__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageKeys__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignBool(false)
}
func (_StorageKeys__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignInt(0)
}
func (_StorageKeys__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignFloat(0)
}
func (_StorageKeys__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignString("")
}
func (_StorageKeys__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignBytes(nil)
}
func (_StorageKeys__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.StorageKeys.Repr"}.AssignLink(nil)
}
func (na *_StorageKeys__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageKeys); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.StorageKeys.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageKeys__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StorageKeys__ReprPrototype{}
}
func (la *_StorageKeys__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_StorageKeys__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_StorageKeys__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_StorageKeys__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}

type _String__Maybe struct {
	m schema.Maybe
	v _String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})

func (String) Kind() ipld.Kind {
	return ipld.Kind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{TypeName: "dageth.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{TypeName: "dageth.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.String{TypeName: "dageth.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{TypeName: "dageth.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int64 {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{TypeName: "dageth.String"}.AsBool()
}
func (String) AsInt() (int64, error) {
	return mixins.String{TypeName: "dageth.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{TypeName: "dageth.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{TypeName: "dageth.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{TypeName: "dageth.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}

type _String__Builder struct {
	_String__Assembler
}

func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}

type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{TypeName: "dageth.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}

type _String__Repr = _String

var _ ipld.Node = &_String__Repr{}

type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler

func (n Time) Bytes() []byte {
	return n.x
}
func (_Time__Prototype) FromBytes(v []byte) (Time, error) {
	n := _Time{v}
	return &n, nil
}

type _Time__Maybe struct {
	m schema.Maybe
	v _Time
}
type MaybeTime = *_Time__Maybe

func (m MaybeTime) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTime) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTime) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTime) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTime) Must() Time {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Time)(&_Time{})
var _ schema.TypedNode = (Time)(&_Time{})

func (Time) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Time) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.LookupByString("")
}
func (Time) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.LookupByNode(nil)
}
func (Time) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.LookupByIndex(0)
}
func (Time) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.LookupBySegment(seg)
}
func (Time) MapIterator() ipld.MapIterator {
	return nil
}
func (Time) ListIterator() ipld.ListIterator {
	return nil
}
func (Time) Length() int64 {
	return -1
}
func (Time) IsAbsent() bool {
	return false
}
func (Time) IsNull() bool {
	return false
}
func (Time) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.AsBool()
}
func (Time) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.AsInt()
}
func (Time) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.AsFloat()
}
func (Time) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.AsString()
}
func (n Time) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Time) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Time"}.AsLink()
}
func (Time) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}

type _Time__Prototype struct{}

func (_Time__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__Builder
	nb.Reset()
	return &nb
}

type _Time__Builder struct {
	_Time__Assembler
}

func (nb *_Time__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__Builder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__Builder{_Time__Assembler{w: &w, m: &m}}
}

type _Time__Assembler struct {
	w *_Time
	m *schema.Maybe
}

func (na *_Time__Assembler) reset() {}
func (_Time__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.BeginMap(0)
}
func (_Time__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.BeginList(0)
}
func (na *_Time__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Time__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignBool(false)
}
func (_Time__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignInt(0)
}
func (_Time__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignFloat(0)
}
func (_Time__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignString("")
}
func (na *_Time__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Time__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Time"}.AssignLink(nil)
}
func (na *_Time__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Time__Assembler) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
func (Time) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Time) Representation() ipld.Node {
	return (*_Time__Repr)(n)
}

type _Time__Repr = _Time

var _ ipld.Node = &_Time__Repr{}

type _Time__ReprPrototype = _Time__Prototype
type _Time__ReprAssembler = _Time__Assembler

func (n *_Topics) Lookup(idx int64) Hash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Topics) LookupMaybe(idx int64) MaybeHash {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Hash__Maybe{
		m: schema.Maybe_Value,
		v: *v,
	}
}

var _Topics__valueAbsent = _Hash__Maybe{m: schema.Maybe_Absent}

func (n Topics) Iterator() *Topics__Itr {
	return &Topics__Itr{n, 0}
}

type Topics__Itr struct {
	n   Topics
	idx int
}

func (itr *Topics__Itr) Next() (idx int64, v Hash) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Topics__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Topics__Maybe struct {
	m schema.Maybe
	v _Topics
}
type MaybeTopics = *_Topics__Maybe

func (m MaybeTopics) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTopics) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTopics) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTopics) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTopics) Must() Topics {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Topics)(&_Topics{})
var _ schema.TypedNode = (Topics)(&_Topics{})

func (Topics) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Topics) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Topics"}.LookupByString("")
}
func (n Topics) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Topics) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Topics) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Topics", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Topics) MapIterator() ipld.MapIterator {
	return nil
}
func (n Topics) ListIterator() ipld.ListIterator {
	return &_Topics__ListItr{n, 0}
}

type _Topics__ListItr struct {
	n   Topics
	idx int
}

func (itr *_Topics__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Topics__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Topics) Length() int64 {
	return int64(len(n.x))
}
func (Topics) IsAbsent() bool {
	return false
}
func (Topics) IsNull() bool {
	return false
}
func (Topics) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsBool()
}
func (Topics) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsInt()
}
func (Topics) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsFloat()
}
func (Topics) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsString()
}
func (Topics) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsBytes()
}
func (Topics) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Topics"}.AsLink()
}
func (Topics) Prototype() ipld.NodePrototype {
	return _Topics__Prototype{}
}

type _Topics__Prototype struct{}

func (_Topics__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Topics__Builder
	nb.Reset()
	return &nb
}

type _Topics__Builder struct {
	_Topics__Assembler
}

func (nb *_Topics__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Topics__Builder) Reset() {
	var w _Topics
	var m schema.Maybe
	*nb = _Topics__Builder{_Topics__Assembler{w: &w, m: &m}}
}

type _Topics__Assembler struct {
	w     *_Topics
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__Assembler
}

func (na *_Topics__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Topics__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.BeginMap(0)
}
func (na *_Topics__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Topics__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Topics__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignBool(false)
}
func (_Topics__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignInt(0)
}
func (_Topics__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignFloat(0)
}
func (_Topics__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignString("")
}
func (_Topics__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignBytes(nil)
}
func (_Topics__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics"}.AssignLink(nil)
}
func (na *_Topics__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Topics); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Topics", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Topics__Assembler) Prototype() ipld.NodePrototype {
	return _Topics__Prototype{}
}
func (la *_Topics__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Topics__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Topics__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Topics__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__Prototype{}
}
func (Topics) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Topics) Representation() ipld.Node {
	return (*_Topics__Repr)(n)
}

type _Topics__Repr _Topics

var _ ipld.Node = &_Topics__Repr{}

func (_Topics__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Topics__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.LookupByString("")
}
func (nr *_Topics__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Topics)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (nr *_Topics__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Topics)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Hash).Representation(), nil
}
func (n _Topics__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Topics.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Topics__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Topics__Repr) ListIterator() ipld.ListIterator {
	return &_Topics__ReprListItr{(Topics)(nr), 0}
}

type _Topics__ReprListItr _Topics__ListItr

func (itr *_Topics__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Topics__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Hash).Representation(), nil
}
func (itr *_Topics__ReprListItr) Done() bool {
	return (*_Topics__ListItr)(itr).Done()
}

func (rn *_Topics__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Topics__Repr) IsAbsent() bool {
	return false
}
func (_Topics__Repr) IsNull() bool {
	return false
}
func (_Topics__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsBool()
}
func (_Topics__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsInt()
}
func (_Topics__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsFloat()
}
func (_Topics__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsString()
}
func (_Topics__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsBytes()
}
func (_Topics__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Topics.Repr"}.AsLink()
}
func (_Topics__Repr) Prototype() ipld.NodePrototype {
	return _Topics__ReprPrototype{}
}

type _Topics__ReprPrototype struct{}

func (_Topics__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Topics__ReprBuilder
	nb.Reset()
	return &nb
}

type _Topics__ReprBuilder struct {
	_Topics__ReprAssembler
}

func (nb *_Topics__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Topics__ReprBuilder) Reset() {
	var w _Topics
	var m schema.Maybe
	*nb = _Topics__ReprBuilder{_Topics__ReprAssembler{w: &w, m: &m}}
}

type _Topics__ReprAssembler struct {
	w     *_Topics
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Hash__ReprAssembler
}

func (na *_Topics__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Topics__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.BeginMap(0)
}
func (na *_Topics__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Hash, 0, sizeHint)
	}
	return na, nil
}
func (na *_Topics__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Topics.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Topics__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignBool(false)
}
func (_Topics__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignInt(0)
}
func (_Topics__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignFloat(0)
}
func (_Topics__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignString("")
}
func (_Topics__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignBytes(nil)
}
func (_Topics__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Topics.Repr"}.AssignLink(nil)
}
func (na *_Topics__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Topics); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Topics.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Topics__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Topics__ReprPrototype{}
}
func (la *_Topics__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Topics__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Hash{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Topics__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Topics__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Hash__ReprPrototype{}
}

func (n _Transaction) FieldTxType() TxType {
	return &n.TxType
}
func (n _Transaction) FieldChainID() MaybeBigInt {
	return &n.ChainID
}
func (n _Transaction) FieldAccountNonce() Uint {
	return &n.AccountNonce
}
func (n _Transaction) FieldGasPrice() MaybeBigInt {
	return &n.GasPrice
}
func (n _Transaction) FieldGasTipCap() MaybeBigInt {
	return &n.GasTipCap
}
func (n _Transaction) FieldGasFeeCap() MaybeBigInt {
	return &n.GasFeeCap
}
func (n _Transaction) FieldGasLimit() Uint {
	return &n.GasLimit
}
func (n _Transaction) FieldRecipient() MaybeAddress {
	return &n.Recipient
}
func (n _Transaction) FieldAmount() BigInt {
	return &n.Amount
}
func (n _Transaction) FieldData() Bytes {
	return &n.Data
}
func (n _Transaction) FieldAccessList() MaybeAccessList {
	return &n.AccessList
}
func (n _Transaction) FieldV() BigInt {
	return &n.V
}
func (n _Transaction) FieldR() BigInt {
	return &n.R
}
func (n _Transaction) FieldS() BigInt {
	return &n.S
}

type _Transaction__Maybe struct {
	m schema.Maybe
	v Transaction
}
type MaybeTransaction = *_Transaction__Maybe

func (m MaybeTransaction) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTransaction) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTransaction) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTransaction) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTransaction) Must() Transaction {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__Transaction_TxType       = _String{"TxType"}
	fieldName__Transaction_ChainID      = _String{"ChainID"}
	fieldName__Transaction_AccountNonce = _String{"AccountNonce"}
	fieldName__Transaction_GasPrice     = _String{"GasPrice"}
	fieldName__Transaction_GasTipCap    = _String{"GasTipCap"}
	fieldName__Transaction_GasFeeCap    = _String{"GasFeeCap"}
	fieldName__Transaction_GasLimit     = _String{"GasLimit"}
	fieldName__Transaction_Recipient    = _String{"Recipient"}
	fieldName__Transaction_Amount       = _String{"Amount"}
	fieldName__Transaction_Data         = _String{"Data"}
	fieldName__Transaction_AccessList   = _String{"AccessList"}
	fieldName__Transaction_V            = _String{"V"}
	fieldName__Transaction_R            = _String{"R"}
	fieldName__Transaction_S            = _String{"S"}
)
var _ ipld.Node = (Transaction)(&_Transaction{})
var _ schema.TypedNode = (Transaction)(&_Transaction{})

func (Transaction) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Transaction) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxType":
		return &n.TxType, nil
	case "ChainID":
		if n.ChainID.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.ChainID.v, nil
	case "AccountNonce":
		return &n.AccountNonce, nil
	case "GasPrice":
		if n.GasPrice.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.GasPrice.v, nil
	case "GasTipCap":
		if n.GasTipCap.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.GasTipCap.v, nil
	case "GasFeeCap":
		if n.GasFeeCap.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.GasFeeCap.v, nil
	case "GasLimit":
		return &n.GasLimit, nil
	case "Recipient":
		if n.Recipient.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.Recipient.v, nil
	case "Amount":
		return &n.Amount, nil
	case "Data":
		return &n.Data, nil
	case "AccessList":
		if n.AccessList.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return &n.AccessList.v, nil
	case "V":
		return &n.V, nil
	case "R":
		return &n.R, nil
	case "S":
		return &n.S, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Transaction) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Transaction) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.LookupByIndex(0)
}
func (n Transaction) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Transaction) MapIterator() ipld.MapIterator {
	return &_Transaction__MapItr{n, 0}
}

type _Transaction__MapItr struct {
	n   Transaction
	idx int
}

func (itr *_Transaction__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Transaction_TxType
		v = &itr.n.TxType
	case 1:
		k = &fieldName__Transaction_ChainID
		if itr.n.ChainID.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.ChainID.v
	case 2:
		k = &fieldName__Transaction_AccountNonce
		v = &itr.n.AccountNonce
	case 3:
		k = &fieldName__Transaction_GasPrice
		if itr.n.GasPrice.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.GasPrice.v
	case 4:
		k = &fieldName__Transaction_GasTipCap
		if itr.n.GasTipCap.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.GasTipCap.v
	case 5:
		k = &fieldName__Transaction_GasFeeCap
		if itr.n.GasFeeCap.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.GasFeeCap.v
	case 6:
		k = &fieldName__Transaction_GasLimit
		v = &itr.n.GasLimit
	case 7:
		k = &fieldName__Transaction_Recipient
		if itr.n.Recipient.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.Recipient.v
	case 8:
		k = &fieldName__Transaction_Amount
		v = &itr.n.Amount
	case 9:
		k = &fieldName__Transaction_Data
		v = &itr.n.Data
	case 10:
		k = &fieldName__Transaction_AccessList
		if itr.n.AccessList.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = &itr.n.AccessList.v
	case 11:
		k = &fieldName__Transaction_V
		v = &itr.n.V
	case 12:
		k = &fieldName__Transaction_R
		v = &itr.n.R
	case 13:
		k = &fieldName__Transaction_S
		v = &itr.n.S
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Transaction__MapItr) Done() bool {
	return itr.idx >= 14
}

func (Transaction) ListIterator() ipld.ListIterator {
	return nil
}
func (Transaction) Length() int64 {
	return 14
}
func (Transaction) IsAbsent() bool {
	return false
}
func (Transaction) IsNull() bool {
	return false
}
func (Transaction) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsBool()
}
func (Transaction) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsInt()
}
func (Transaction) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsFloat()
}
func (Transaction) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsString()
}
func (Transaction) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsBytes()
}
func (Transaction) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Transaction"}.AsLink()
}
func (Transaction) Prototype() ipld.NodePrototype {
	return _Transaction__Prototype{}
}

type _Transaction__Prototype struct{}

func (_Transaction__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transaction__Builder
	nb.Reset()
	return &nb
}

type _Transaction__Builder struct {
	_Transaction__Assembler
}

func (nb *_Transaction__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transaction__Builder) Reset() {
	var w _Transaction
	var m schema.Maybe
	*nb = _Transaction__Builder{_Transaction__Assembler{w: &w, m: &m}}
}

type _Transaction__Assembler struct {
	w     *_Transaction
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_TxType       _TxType__Assembler
	ca_ChainID      _BigInt__Assembler
	ca_AccountNonce _Uint__Assembler
	ca_GasPrice     _BigInt__Assembler
	ca_GasTipCap    _BigInt__Assembler
	ca_GasFeeCap    _BigInt__Assembler
	ca_GasLimit     _Uint__Assembler
	ca_Recipient    _Address__Assembler
	ca_Amount       _BigInt__Assembler
	ca_Data         _Bytes__Assembler
	ca_AccessList   _AccessList__Assembler
	ca_V            _BigInt__Assembler
	ca_R            _BigInt__Assembler
	ca_S            _BigInt__Assembler
}

func (na *_Transaction__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxType.reset()
	na.ca_ChainID.reset()
	na.ca_AccountNonce.reset()
	na.ca_GasPrice.reset()
	na.ca_GasTipCap.reset()
	na.ca_GasFeeCap.reset()
	na.ca_GasLimit.reset()
	na.ca_Recipient.reset()
	na.ca_Amount.reset()
	na.ca_Data.reset()
	na.ca_AccessList.reset()
	na.ca_V.reset()
	na.ca_R.reset()
	na.ca_S.reset()
}

var (
	fieldBit__Transaction_TxType       = 1 << 0
	fieldBit__Transaction_ChainID      = 1 << 1
	fieldBit__Transaction_AccountNonce = 1 << 2
	fieldBit__Transaction_GasPrice     = 1 << 3
	fieldBit__Transaction_GasTipCap    = 1 << 4
	fieldBit__Transaction_GasFeeCap    = 1 << 5
	fieldBit__Transaction_GasLimit     = 1 << 6
	fieldBit__Transaction_Recipient    = 1 << 7
	fieldBit__Transaction_Amount       = 1 << 8
	fieldBit__Transaction_Data         = 1 << 9
	fieldBit__Transaction_AccessList   = 1 << 10
	fieldBit__Transaction_V            = 1 << 11
	fieldBit__Transaction_R            = 1 << 12
	fieldBit__Transaction_S            = 1 << 13
	fieldBits__Transaction_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13
)

func (na *_Transaction__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Transaction{}
	}
	return na, nil
}
func (_Transaction__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.BeginList(0)
}
func (na *_Transaction__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transaction__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignBool(false)
}
func (_Transaction__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignInt(0)
}
func (_Transaction__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignFloat(0)
}
func (_Transaction__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignString("")
}
func (_Transaction__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignBytes(nil)
}
func (_Transaction__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction"}.AssignLink(nil)
}
func (na *_Transaction__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transaction); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Transaction", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transaction__Assembler) Prototype() ipld.NodePrototype {
	return _Transaction__Prototype{}
}
func (ma *_Transaction__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TxType.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ChainID.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_AccountNonce.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.GasPrice.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.GasTipCap.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.GasFeeCap.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_GasLimit.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Recipient.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Amount.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Data.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.AccessList.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_V.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_R.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_S.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxType":
		if ma.s&fieldBit__Transaction_TxType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_TxType}
		}
		ma.s += fieldBit__Transaction_TxType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType, nil
	case "ChainID":
		if ma.s&fieldBit__Transaction_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID}
		}
		ma.s += fieldBit__Transaction_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID, nil
	case "AccountNonce":
		if ma.s&fieldBit__Transaction_AccountNonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce}
		}
		ma.s += fieldBit__Transaction_AccountNonce
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce, nil
	case "GasPrice":
		if ma.s&fieldBit__Transaction_GasPrice != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice}
		}
		ma.s += fieldBit__Transaction_GasPrice
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasPrice.w = &ma.w.GasPrice.v
		ma.ca_GasPrice.m = &ma.w.GasPrice.m
		ma.w.GasPrice.m = allowNull
		return &ma.ca_GasPrice, nil
	case "GasTipCap":
		if ma.s&fieldBit__Transaction_GasTipCap != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasTipCap}
		}
		ma.s += fieldBit__Transaction_GasTipCap
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_GasTipCap.w = &ma.w.GasTipCap.v
		ma.ca_GasTipCap.m = &ma.w.GasTipCap.m
		ma.w.GasTipCap.m = allowNull
		return &ma.ca_GasTipCap, nil
	case "GasFeeCap":
		if ma.s&fieldBit__Transaction_GasFeeCap != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasFeeCap}
		}
		ma.s += fieldBit__Transaction_GasFeeCap
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_GasFeeCap.w = &ma.w.GasFeeCap.v
		ma.ca_GasFeeCap.m = &ma.w.GasFeeCap.m
		ma.w.GasFeeCap.m = allowNull
		return &ma.ca_GasFeeCap, nil
	case "GasLimit":
		if ma.s&fieldBit__Transaction_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit}
		}
		ma.s += fieldBit__Transaction_GasLimit
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "Recipient":
		if ma.s&fieldBit__Transaction_Recipient != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient}
		}
		ma.s += fieldBit__Transaction_Recipient
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Recipient.w = &ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient, nil
	case "Amount":
		if ma.s&fieldBit__Transaction_Amount != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount}
		}
		ma.s += fieldBit__Transaction_Amount
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount, nil
	case "Data":
		if ma.s&fieldBit__Transaction_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data}
		}
		ma.s += fieldBit__Transaction_Data
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "AccessList":
		if ma.s&fieldBit__Transaction_AccessList != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList}
		}
		ma.s += fieldBit__Transaction_AccessList
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AccessList.w = &ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList, nil
	case "V":
		if ma.s&fieldBit__Transaction_V != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V}
		}
		ma.s += fieldBit__Transaction_V
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V, nil
	case "R":
		if ma.s&fieldBit__Transaction_R != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R}
		}
		ma.s += fieldBit__Transaction_R
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R, nil
	case "S":
		if ma.s&fieldBit__Transaction_S != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S}
		}
		ma.s += fieldBit__Transaction_S
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Transaction", Key: &_String{k}}
}
func (ma *_Transaction__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Transaction__KeyAssembler)(ma)
}
func (ma *_Transaction__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID
	case 2:
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce
	case 3:
		ma.ca_GasPrice.w = &ma.w.GasPrice.v
		ma.ca_GasPrice.m = &ma.w.GasPrice.m
		ma.w.GasPrice.m = allowNull
		return &ma.ca_GasPrice
	case 4:
		ma.ca_GasTipCap.w = &ma.w.GasTipCap.v
		ma.ca_GasTipCap.m = &ma.w.GasTipCap.m
		ma.w.GasTipCap.m = allowNull
		return &ma.ca_GasTipCap
	case 5:
		ma.ca_GasFeeCap.w = &ma.w.GasFeeCap.v
		ma.ca_GasFeeCap.m = &ma.w.GasFeeCap.m
		ma.w.GasFeeCap.m = allowNull
		return &ma.ca_GasFeeCap
	case 6:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 7:
		ma.ca_Recipient.w = &ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient
	case 8:
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount
	case 9:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 10:
		ma.ca_AccessList.w = &ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList
	case 11:
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V
	case 12:
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R
	case 13:
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Transaction_sufficient != fieldBits__Transaction_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Transaction_TxType == 0 {
			err.Missing = append(err.Missing, "TxType")
		}
		if ma.s&fieldBit__Transaction_AccountNonce == 0 {
			err.Missing = append(err.Missing, "AccountNonce")
		}
		if ma.s&fieldBit__Transaction_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Transaction_Amount == 0 {
			err.Missing = append(err.Missing, "Amount")
		}
		if ma.s&fieldBit__Transaction_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Transaction_V == 0 {
			err.Missing = append(err.Missing, "V")
		}
		if ma.s&fieldBit__Transaction_R == 0 {
			err.Missing = append(err.Missing, "R")
		}
		if ma.s&fieldBit__Transaction_S == 0 {
			err.Missing = append(err.Missing, "S")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Transaction__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Transaction__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _Transaction__KeyAssembler _Transaction__Assembler

func (_Transaction__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.BeginMap(0)
}
func (_Transaction__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.BeginList(0)
}
func (na *_Transaction__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignNull()
}
func (_Transaction__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignBool(false)
}
func (_Transaction__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignInt(0)
}
func (_Transaction__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Transaction__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxType":
		if ka.s&fieldBit__Transaction_TxType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_TxType}
		}
		ka.s += fieldBit__Transaction_TxType
		ka.state = maState_expectValue
		ka.f = 0
	case "ChainID":
		if ka.s&fieldBit__Transaction_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID}
		}
		ka.s += fieldBit__Transaction_ChainID
		ka.state = maState_expectValue
		ka.f = 1
	case "AccountNonce":
		if ka.s&fieldBit__Transaction_AccountNonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce}
		}
		ka.s += fieldBit__Transaction_AccountNonce
		ka.state = maState_expectValue
		ka.f = 2
	case "GasPrice":
		if ka.s&fieldBit__Transaction_GasPrice != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice}
		}
		ka.s += fieldBit__Transaction_GasPrice
		ka.state = maState_expectValue
		ka.f = 3
	case "GasTipCap":
		if ka.s&fieldBit__Transaction_GasTipCap != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasTipCap}
		}
		ka.s += fieldBit__Transaction_GasTipCap
		ka.state = maState_expectValue
		ka.f = 4
	case "GasFeeCap":
		if ka.s&fieldBit__Transaction_GasFeeCap != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasFeeCap}
		}
		ka.s += fieldBit__Transaction_GasFeeCap
		ka.state = maState_expectValue
		ka.f = 5
	case "GasLimit":
		if ka.s&fieldBit__Transaction_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit}
		}
		ka.s += fieldBit__Transaction_GasLimit
		ka.state = maState_expectValue
		ka.f = 6
	case "Recipient":
		if ka.s&fieldBit__Transaction_Recipient != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient}
		}
		ka.s += fieldBit__Transaction_Recipient
		ka.state = maState_expectValue
		ka.f = 7
	case "Amount":
		if ka.s&fieldBit__Transaction_Amount != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount}
		}
		ka.s += fieldBit__Transaction_Amount
		ka.state = maState_expectValue
		ka.f = 8
	case "Data":
		if ka.s&fieldBit__Transaction_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data}
		}
		ka.s += fieldBit__Transaction_Data
		ka.state = maState_expectValue
		ka.f = 9
	case "AccessList":
		if ka.s&fieldBit__Transaction_AccessList != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList}
		}
		ka.s += fieldBit__Transaction_AccessList
		ka.state = maState_expectValue
		ka.f = 10
	case "V":
		if ka.s&fieldBit__Transaction_V != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V}
		}
		ka.s += fieldBit__Transaction_V
		ka.state = maState_expectValue
		ka.f = 11
	case "R":
		if ka.s&fieldBit__Transaction_R != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R}
		}
		ka.s += fieldBit__Transaction_R
		ka.state = maState_expectValue
		ka.f = 12
	case "S":
		if ka.s&fieldBit__Transaction_S != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S}
		}
		ka.s += fieldBit__Transaction_S
		ka.state = maState_expectValue
		ka.f = 13
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.Transaction", Key: &_String{k}}
	}
	return nil
}
func (_Transaction__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignBytes(nil)
}
func (_Transaction__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Transaction__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Transaction__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Transaction) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Transaction) Representation() ipld.Node {
	return (*_Transaction__Repr)(n)
}

type _Transaction__Repr _Transaction

var (
	fieldName__Transaction_TxType_serial       = _String{"TxType"}
	fieldName__Transaction_ChainID_serial      = _String{"ChainID"}
	fieldName__Transaction_AccountNonce_serial = _String{"AccountNonce"}
	fieldName__Transaction_GasPrice_serial     = _String{"GasPrice"}
	fieldName__Transaction_GasTipCap_serial    = _String{"GasTipCap"}
	fieldName__Transaction_GasFeeCap_serial    = _String{"GasFeeCap"}
	fieldName__Transaction_GasLimit_serial     = _String{"GasLimit"}
	fieldName__Transaction_Recipient_serial    = _String{"Recipient"}
	fieldName__Transaction_Amount_serial       = _String{"Amount"}
	fieldName__Transaction_Data_serial         = _String{"Data"}
	fieldName__Transaction_AccessList_serial   = _String{"AccessList"}
	fieldName__Transaction_V_serial            = _String{"V"}
	fieldName__Transaction_R_serial            = _String{"R"}
	fieldName__Transaction_S_serial            = _String{"S"}
)
var _ ipld.Node = &_Transaction__Repr{}

func (_Transaction__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Transaction__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxType":
		return n.TxType.Representation(), nil
	case "ChainID":
		if n.ChainID.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChainID.v.Representation(), nil
	case "AccountNonce":
		return n.AccountNonce.Representation(), nil
	case "GasPrice":
		if n.GasPrice.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.GasPrice.v.Representation(), nil
	case "GasTipCap":
		if n.GasTipCap.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.GasTipCap.v.Representation(), nil
	case "GasFeeCap":
		if n.GasFeeCap.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.GasFeeCap.v.Representation(), nil
	case "GasLimit":
		return n.GasLimit.Representation(), nil
	case "Recipient":
		if n.Recipient.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Recipient.v.Representation(), nil
	case "Amount":
		return n.Amount.Representation(), nil
	case "Data":
		return n.Data.Representation(), nil
	case "AccessList":
		if n.AccessList.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.AccessList.v.Representation(), nil
	case "V":
		return n.V.Representation(), nil
	case "R":
		return n.R.Representation(), nil
	case "S":
		return n.S.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Transaction__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Transaction__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.LookupByIndex(0)
}
func (n _Transaction__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Transaction__Repr) MapIterator() ipld.MapIterator {
	return &_Transaction__ReprMapItr{n, 0}
}

type _Transaction__ReprMapItr struct {
	n   *_Transaction__Repr
	idx int
}

func (itr *_Transaction__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 14 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Transaction_TxType_serial
		v = itr.n.TxType.Representation()
	case 1:
		k = &fieldName__Transaction_ChainID_serial
		if itr.n.ChainID.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChainID.v.Representation()
	case 2:
		k = &fieldName__Transaction_AccountNonce_serial
		v = itr.n.AccountNonce.Representation()
	case 3:
		k = &fieldName__Transaction_GasPrice_serial
		if itr.n.GasPrice.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.GasPrice.v.Representation()
	case 4:
		k = &fieldName__Transaction_GasTipCap_serial
		if itr.n.GasTipCap.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.GasTipCap.v.Representation()
	case 5:
		k = &fieldName__Transaction_GasFeeCap_serial
		if itr.n.GasFeeCap.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.GasFeeCap.v.Representation()
	case 6:
		k = &fieldName__Transaction_GasLimit_serial
		v = itr.n.GasLimit.Representation()
	case 7:
		k = &fieldName__Transaction_Recipient_serial
		if itr.n.Recipient.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Recipient.v.Representation()
	case 8:
		k = &fieldName__Transaction_Amount_serial
		v = itr.n.Amount.Representation()
	case 9:
		k = &fieldName__Transaction_Data_serial
		v = itr.n.Data.Representation()
	case 10:
		k = &fieldName__Transaction_AccessList_serial
		if itr.n.AccessList.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.AccessList.v.Representation()
	case 11:
		k = &fieldName__Transaction_V_serial
		v = itr.n.V.Representation()
	case 12:
		k = &fieldName__Transaction_R_serial
		v = itr.n.R.Representation()
	case 13:
		k = &fieldName__Transaction_S_serial
		v = itr.n.S.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Transaction__ReprMapItr) Done() bool {
	return itr.idx >= 14
}
func (_Transaction__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Transaction__Repr) Length() int64 {
	l := 14
	return int64(l)
}
func (_Transaction__Repr) IsAbsent() bool {
	return false
}
func (_Transaction__Repr) IsNull() bool {
	return false
}
func (_Transaction__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsBool()
}
func (_Transaction__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsInt()
}
func (_Transaction__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsFloat()
}
func (_Transaction__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsString()
}
func (_Transaction__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsBytes()
}
func (_Transaction__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Transaction.Repr"}.AsLink()
}
func (_Transaction__Repr) Prototype() ipld.NodePrototype {
	return _Transaction__ReprPrototype{}
}

type _Transaction__ReprPrototype struct{}

func (_Transaction__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transaction__ReprBuilder
	nb.Reset()
	return &nb
}

type _Transaction__ReprBuilder struct {
	_Transaction__ReprAssembler
}

func (nb *_Transaction__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transaction__ReprBuilder) Reset() {
	var w _Transaction
	var m schema.Maybe
	*nb = _Transaction__ReprBuilder{_Transaction__ReprAssembler{w: &w, m: &m}}
}

type _Transaction__ReprAssembler struct {
	w     *_Transaction
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_TxType       _TxType__ReprAssembler
	ca_ChainID      _BigInt__ReprAssembler
	ca_AccountNonce _Uint__ReprAssembler
	ca_GasPrice     _BigInt__ReprAssembler
	ca_GasTipCap    _BigInt__ReprAssembler
	ca_GasFeeCap    _BigInt__ReprAssembler
	ca_GasLimit     _Uint__ReprAssembler
	ca_Recipient    _Address__ReprAssembler
	ca_Amount       _BigInt__ReprAssembler
	ca_Data         _Bytes__ReprAssembler
	ca_AccessList   _AccessList__ReprAssembler
	ca_V            _BigInt__ReprAssembler
	ca_R            _BigInt__ReprAssembler
	ca_S            _BigInt__ReprAssembler
}

func (na *_Transaction__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxType.reset()
	na.ca_ChainID.reset()
	na.ca_AccountNonce.reset()
	na.ca_GasPrice.reset()
	na.ca_GasTipCap.reset()
	na.ca_GasFeeCap.reset()
	na.ca_GasLimit.reset()
	na.ca_Recipient.reset()
	na.ca_Amount.reset()
	na.ca_Data.reset()
	na.ca_AccessList.reset()
	na.ca_V.reset()
	na.ca_R.reset()
	na.ca_S.reset()
}
func (na *_Transaction__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Transaction{}
	}
	return na, nil
}
func (_Transaction__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.BeginList(0)
}
func (na *_Transaction__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transaction__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignBool(false)
}
func (_Transaction__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignInt(0)
}
func (_Transaction__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignFloat(0)
}
func (_Transaction__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignString("")
}
func (_Transaction__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignBytes(nil)
}
func (_Transaction__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Transaction.Repr"}.AssignLink(nil)
}
func (na *_Transaction__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transaction); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Transaction.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transaction__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Transaction__ReprPrototype{}
}
func (ma *_Transaction__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ChainID.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.GasPrice.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.GasTipCap.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.GasFeeCap.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Recipient.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.AccessList.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxType":
		if ma.s&fieldBit__Transaction_TxType != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_TxType_serial}
		}
		ma.s += fieldBit__Transaction_TxType
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType, nil
	case "ChainID":
		if ma.s&fieldBit__Transaction_ChainID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID_serial}
		}
		ma.s += fieldBit__Transaction_ChainID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ChainID.w = &ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID, nil
	case "AccountNonce":
		if ma.s&fieldBit__Transaction_AccountNonce != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce_serial}
		}
		ma.s += fieldBit__Transaction_AccountNonce
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce, nil
	case "GasPrice":
		if ma.s&fieldBit__Transaction_GasPrice != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice_serial}
		}
		ma.s += fieldBit__Transaction_GasPrice
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_GasPrice.w = &ma.w.GasPrice.v
		ma.ca_GasPrice.m = &ma.w.GasPrice.m
		ma.w.GasPrice.m = allowNull
		return &ma.ca_GasPrice, nil
	case "GasTipCap":
		if ma.s&fieldBit__Transaction_GasTipCap != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasTipCap_serial}
		}
		ma.s += fieldBit__Transaction_GasTipCap
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_GasTipCap.w = &ma.w.GasTipCap.v
		ma.ca_GasTipCap.m = &ma.w.GasTipCap.m
		ma.w.GasTipCap.m = allowNull
		return &ma.ca_GasTipCap, nil
	case "GasFeeCap":
		if ma.s&fieldBit__Transaction_GasFeeCap != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasFeeCap_serial}
		}
		ma.s += fieldBit__Transaction_GasFeeCap
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_GasFeeCap.w = &ma.w.GasFeeCap.v
		ma.ca_GasFeeCap.m = &ma.w.GasFeeCap.m
		ma.w.GasFeeCap.m = allowNull
		return &ma.ca_GasFeeCap, nil
	case "GasLimit":
		if ma.s&fieldBit__Transaction_GasLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit_serial}
		}
		ma.s += fieldBit__Transaction_GasLimit
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit, nil
	case "Recipient":
		if ma.s&fieldBit__Transaction_Recipient != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient_serial}
		}
		ma.s += fieldBit__Transaction_Recipient
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Recipient.w = &ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient, nil
	case "Amount":
		if ma.s&fieldBit__Transaction_Amount != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount_serial}
		}
		ma.s += fieldBit__Transaction_Amount
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount, nil
	case "Data":
		if ma.s&fieldBit__Transaction_Data != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data_serial}
		}
		ma.s += fieldBit__Transaction_Data
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data, nil
	case "AccessList":
		if ma.s&fieldBit__Transaction_AccessList != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList_serial}
		}
		ma.s += fieldBit__Transaction_AccessList
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_AccessList.w = &ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList, nil
	case "V":
		if ma.s&fieldBit__Transaction_V != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V_serial}
		}
		ma.s += fieldBit__Transaction_V
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V, nil
	case "R":
		if ma.s&fieldBit__Transaction_R != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R_serial}
		}
		ma.s += fieldBit__Transaction_R
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R, nil
	case "S":
		if ma.s&fieldBit__Transaction_S != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S_serial}
		}
		ma.s += fieldBit__Transaction_S
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Transaction.Repr", Key: &_String{k}}
}
func (ma *_Transaction__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Transaction__ReprKeyAssembler)(ma)
}
func (ma *_Transaction__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxType.w = &ma.w.TxType
		ma.ca_TxType.m = &ma.cm
		return &ma.ca_TxType
	case 1:
		ma.ca_ChainID.w = &ma.w.ChainID.v
		ma.ca_ChainID.m = &ma.w.ChainID.m
		ma.w.ChainID.m = allowNull
		return &ma.ca_ChainID
	case 2:
		ma.ca_AccountNonce.w = &ma.w.AccountNonce
		ma.ca_AccountNonce.m = &ma.cm
		return &ma.ca_AccountNonce
	case 3:
		ma.ca_GasPrice.w = &ma.w.GasPrice.v
		ma.ca_GasPrice.m = &ma.w.GasPrice.m
		ma.w.GasPrice.m = allowNull
		return &ma.ca_GasPrice
	case 4:
		ma.ca_GasTipCap.w = &ma.w.GasTipCap.v
		ma.ca_GasTipCap.m = &ma.w.GasTipCap.m
		ma.w.GasTipCap.m = allowNull
		return &ma.ca_GasTipCap
	case 5:
		ma.ca_GasFeeCap.w = &ma.w.GasFeeCap.v
		ma.ca_GasFeeCap.m = &ma.w.GasFeeCap.m
		ma.w.GasFeeCap.m = allowNull
		return &ma.ca_GasFeeCap
	case 6:
		ma.ca_GasLimit.w = &ma.w.GasLimit
		ma.ca_GasLimit.m = &ma.cm
		return &ma.ca_GasLimit
	case 7:
		ma.ca_Recipient.w = &ma.w.Recipient.v
		ma.ca_Recipient.m = &ma.w.Recipient.m
		ma.w.Recipient.m = allowNull
		return &ma.ca_Recipient
	case 8:
		ma.ca_Amount.w = &ma.w.Amount
		ma.ca_Amount.m = &ma.cm
		return &ma.ca_Amount
	case 9:
		ma.ca_Data.w = &ma.w.Data
		ma.ca_Data.m = &ma.cm
		return &ma.ca_Data
	case 10:
		ma.ca_AccessList.w = &ma.w.AccessList.v
		ma.ca_AccessList.m = &ma.w.AccessList.m
		ma.w.AccessList.m = allowNull
		return &ma.ca_AccessList
	case 11:
		ma.ca_V.w = &ma.w.V
		ma.ca_V.m = &ma.cm
		return &ma.ca_V
	case 12:
		ma.ca_R.w = &ma.w.R
		ma.ca_R.m = &ma.cm
		return &ma.ca_R
	case 13:
		ma.ca_S.w = &ma.w.S
		ma.ca_S.m = &ma.cm
		return &ma.ca_S
	default:
		panic("unreachable")
	}
}
func (ma *_Transaction__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__Transaction_sufficient != fieldBits__Transaction_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__Transaction_TxType == 0 {
			err.Missing = append(err.Missing, "TxType")
		}
		if ma.s&fieldBit__Transaction_AccountNonce == 0 {
			err.Missing = append(err.Missing, "AccountNonce")
		}
		if ma.s&fieldBit__Transaction_GasLimit == 0 {
			err.Missing = append(err.Missing, "GasLimit")
		}
		if ma.s&fieldBit__Transaction_Amount == 0 {
			err.Missing = append(err.Missing, "Amount")
		}
		if ma.s&fieldBit__Transaction_Data == 0 {
			err.Missing = append(err.Missing, "Data")
		}
		if ma.s&fieldBit__Transaction_V == 0 {
			err.Missing = append(err.Missing, "V")
		}
		if ma.s&fieldBit__Transaction_R == 0 {
			err.Missing = append(err.Missing, "R")
		}
		if ma.s&fieldBit__Transaction_S == 0 {
			err.Missing = append(err.Missing, "S")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Transaction__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Transaction__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _Transaction__ReprKeyAssembler _Transaction__ReprAssembler

func (_Transaction__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Transaction__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Transaction__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignNull()
}
func (_Transaction__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Transaction__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Transaction__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Transaction__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxType":
		if ka.s&fieldBit__Transaction_TxType != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_TxType_serial}
		}
		ka.s += fieldBit__Transaction_TxType
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "ChainID":
		if ka.s&fieldBit__Transaction_ChainID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_ChainID_serial}
		}
		ka.s += fieldBit__Transaction_ChainID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "AccountNonce":
		if ka.s&fieldBit__Transaction_AccountNonce != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccountNonce_serial}
		}
		ka.s += fieldBit__Transaction_AccountNonce
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "GasPrice":
		if ka.s&fieldBit__Transaction_GasPrice != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasPrice_serial}
		}
		ka.s += fieldBit__Transaction_GasPrice
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "GasTipCap":
		if ka.s&fieldBit__Transaction_GasTipCap != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasTipCap_serial}
		}
		ka.s += fieldBit__Transaction_GasTipCap
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "GasFeeCap":
		if ka.s&fieldBit__Transaction_GasFeeCap != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasFeeCap_serial}
		}
		ka.s += fieldBit__Transaction_GasFeeCap
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "GasLimit":
		if ka.s&fieldBit__Transaction_GasLimit != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_GasLimit_serial}
		}
		ka.s += fieldBit__Transaction_GasLimit
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Recipient":
		if ka.s&fieldBit__Transaction_Recipient != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Recipient_serial}
		}
		ka.s += fieldBit__Transaction_Recipient
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "Amount":
		if ka.s&fieldBit__Transaction_Amount != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Amount_serial}
		}
		ka.s += fieldBit__Transaction_Amount
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "Data":
		if ka.s&fieldBit__Transaction_Data != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_Data_serial}
		}
		ka.s += fieldBit__Transaction_Data
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "AccessList":
		if ka.s&fieldBit__Transaction_AccessList != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_AccessList_serial}
		}
		ka.s += fieldBit__Transaction_AccessList
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "V":
		if ka.s&fieldBit__Transaction_V != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_V_serial}
		}
		ka.s += fieldBit__Transaction_V
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "R":
		if ka.s&fieldBit__Transaction_R != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_R_serial}
		}
		ka.s += fieldBit__Transaction_R
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "S":
		if ka.s&fieldBit__Transaction_S != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__Transaction_S_serial}
		}
		ka.s += fieldBit__Transaction_S
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Transaction.Repr", Key: &_String{k}}
}
func (_Transaction__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Transaction__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Transaction.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Transaction__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Transaction__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Transactions) Lookup(idx int64) Transaction {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Transactions) LookupMaybe(idx int64) MaybeTransaction {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Transaction__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Transactions__valueAbsent = _Transaction__Maybe{m: schema.Maybe_Absent}

func (n Transactions) Iterator() *Transactions__Itr {
	return &Transactions__Itr{n, 0}
}

type Transactions__Itr struct {
	n   Transactions
	idx int
}

func (itr *Transactions__Itr) Next() (idx int64, v Transaction) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Transactions__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Transactions__Maybe struct {
	m schema.Maybe
	v _Transactions
}
type MaybeTransactions = *_Transactions__Maybe

func (m MaybeTransactions) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTransactions) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTransactions) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTransactions) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTransactions) Must() Transactions {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Transactions)(&_Transactions{})
var _ schema.TypedNode = (Transactions)(&_Transactions{})

func (Transactions) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Transactions) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.LookupByString("")
}
func (n Transactions) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Transactions) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Transactions) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Transactions", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Transactions) MapIterator() ipld.MapIterator {
	return nil
}
func (n Transactions) ListIterator() ipld.ListIterator {
	return &_Transactions__ListItr{n, 0}
}

type _Transactions__ListItr struct {
	n   Transactions
	idx int
}

func (itr *_Transactions__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Transactions__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Transactions) Length() int64 {
	return int64(len(n.x))
}
func (Transactions) IsAbsent() bool {
	return false
}
func (Transactions) IsNull() bool {
	return false
}
func (Transactions) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsBool()
}
func (Transactions) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsInt()
}
func (Transactions) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsFloat()
}
func (Transactions) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsString()
}
func (Transactions) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsBytes()
}
func (Transactions) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Transactions"}.AsLink()
}
func (Transactions) Prototype() ipld.NodePrototype {
	return _Transactions__Prototype{}
}

type _Transactions__Prototype struct{}

func (_Transactions__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transactions__Builder
	nb.Reset()
	return &nb
}

type _Transactions__Builder struct {
	_Transactions__Assembler
}

func (nb *_Transactions__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transactions__Builder) Reset() {
	var w _Transactions
	var m schema.Maybe
	*nb = _Transactions__Builder{_Transactions__Assembler{w: &w, m: &m}}
}

type _Transactions__Assembler struct {
	w     *_Transactions
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Transaction__Assembler
}

func (na *_Transactions__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Transactions__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.BeginMap(0)
}
func (na *_Transactions__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Transaction, 0, sizeHint)
	}
	return na, nil
}
func (na *_Transactions__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transactions__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignBool(false)
}
func (_Transactions__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignInt(0)
}
func (_Transactions__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignFloat(0)
}
func (_Transactions__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignString("")
}
func (_Transactions__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignBytes(nil)
}
func (_Transactions__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions"}.AssignLink(nil)
}
func (na *_Transactions__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transactions); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Transactions", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transactions__Assembler) Prototype() ipld.NodePrototype {
	return _Transactions__Prototype{}
}
func (la *_Transactions__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Transactions__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Transaction{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Transactions__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Transactions__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Transaction__Prototype{}
}
func (Transactions) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Transactions) Representation() ipld.Node {
	return (*_Transactions__Repr)(n)
}

type _Transactions__Repr _Transactions

var _ ipld.Node = &_Transactions__Repr{}

func (_Transactions__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Transactions__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.LookupByString("")
}
func (nr *_Transactions__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Transactions)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Transaction).Representation(), nil
}
func (nr *_Transactions__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Transactions)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Transaction).Representation(), nil
}
func (n _Transactions__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Transactions.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Transactions__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Transactions__Repr) ListIterator() ipld.ListIterator {
	return &_Transactions__ReprListItr{(Transactions)(nr), 0}
}

type _Transactions__ReprListItr _Transactions__ListItr

func (itr *_Transactions__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Transactions__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Transaction).Representation(), nil
}
func (itr *_Transactions__ReprListItr) Done() bool {
	return (*_Transactions__ListItr)(itr).Done()
}

func (rn *_Transactions__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Transactions__Repr) IsAbsent() bool {
	return false
}
func (_Transactions__Repr) IsNull() bool {
	return false
}
func (_Transactions__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsBool()
}
func (_Transactions__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsInt()
}
func (_Transactions__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsFloat()
}
func (_Transactions__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsString()
}
func (_Transactions__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsBytes()
}
func (_Transactions__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Transactions.Repr"}.AsLink()
}
func (_Transactions__Repr) Prototype() ipld.NodePrototype {
	return _Transactions__ReprPrototype{}
}

type _Transactions__ReprPrototype struct{}

func (_Transactions__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Transactions__ReprBuilder
	nb.Reset()
	return &nb
}

type _Transactions__ReprBuilder struct {
	_Transactions__ReprAssembler
}

func (nb *_Transactions__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Transactions__ReprBuilder) Reset() {
	var w _Transactions
	var m schema.Maybe
	*nb = _Transactions__ReprBuilder{_Transactions__ReprAssembler{w: &w, m: &m}}
}

type _Transactions__ReprAssembler struct {
	w     *_Transactions
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Transaction__ReprAssembler
}

func (na *_Transactions__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Transactions__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.BeginMap(0)
}
func (na *_Transactions__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Transaction, 0, sizeHint)
	}
	return na, nil
}
func (na *_Transactions__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Transactions__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignBool(false)
}
func (_Transactions__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignInt(0)
}
func (_Transactions__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignFloat(0)
}
func (_Transactions__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignString("")
}
func (_Transactions__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignBytes(nil)
}
func (_Transactions__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Transactions.Repr"}.AssignLink(nil)
}
func (na *_Transactions__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Transactions); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Transactions.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Transactions__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Transactions__ReprPrototype{}
}
func (la *_Transactions__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Transactions__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Transaction{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Transactions__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Transactions__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Transaction__ReprPrototype{}
}

func (n _TrieBranchNode) FieldChild0() MaybeChild {
	return &n.Child0
}
func (n _TrieBranchNode) FieldChild1() MaybeChild {
	return &n.Child1
}
func (n _TrieBranchNode) FieldChild2() MaybeChild {
	return &n.Child2
}
func (n _TrieBranchNode) FieldChild3() MaybeChild {
	return &n.Child3
}
func (n _TrieBranchNode) FieldChild4() MaybeChild {
	return &n.Child4
}
func (n _TrieBranchNode) FieldChild5() MaybeChild {
	return &n.Child5
}
func (n _TrieBranchNode) FieldChild6() MaybeChild {
	return &n.Child6
}
func (n _TrieBranchNode) FieldChild7() MaybeChild {
	return &n.Child7
}
func (n _TrieBranchNode) FieldChild8() MaybeChild {
	return &n.Child8
}
func (n _TrieBranchNode) FieldChild9() MaybeChild {
	return &n.Child9
}
func (n _TrieBranchNode) FieldChildA() MaybeChild {
	return &n.ChildA
}
func (n _TrieBranchNode) FieldChildB() MaybeChild {
	return &n.ChildB
}
func (n _TrieBranchNode) FieldChildC() MaybeChild {
	return &n.ChildC
}
func (n _TrieBranchNode) FieldChildD() MaybeChild {
	return &n.ChildD
}
func (n _TrieBranchNode) FieldChildE() MaybeChild {
	return &n.ChildE
}
func (n _TrieBranchNode) FieldChildF() MaybeChild {
	return &n.ChildF
}
func (n _TrieBranchNode) FieldValue() MaybeValue {
	return &n.Value
}

type _TrieBranchNode__Maybe struct {
	m schema.Maybe
	v TrieBranchNode
}
type MaybeTrieBranchNode = *_TrieBranchNode__Maybe

func (m MaybeTrieBranchNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieBranchNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieBranchNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieBranchNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieBranchNode) Must() TrieBranchNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieBranchNode_Child0 = _String{"Child0"}
	fieldName__TrieBranchNode_Child1 = _String{"Child1"}
	fieldName__TrieBranchNode_Child2 = _String{"Child2"}
	fieldName__TrieBranchNode_Child3 = _String{"Child3"}
	fieldName__TrieBranchNode_Child4 = _String{"Child4"}
	fieldName__TrieBranchNode_Child5 = _String{"Child5"}
	fieldName__TrieBranchNode_Child6 = _String{"Child6"}
	fieldName__TrieBranchNode_Child7 = _String{"Child7"}
	fieldName__TrieBranchNode_Child8 = _String{"Child8"}
	fieldName__TrieBranchNode_Child9 = _String{"Child9"}
	fieldName__TrieBranchNode_ChildA = _String{"ChildA"}
	fieldName__TrieBranchNode_ChildB = _String{"ChildB"}
	fieldName__TrieBranchNode_ChildC = _String{"ChildC"}
	fieldName__TrieBranchNode_ChildD = _String{"ChildD"}
	fieldName__TrieBranchNode_ChildE = _String{"ChildE"}
	fieldName__TrieBranchNode_ChildF = _String{"ChildF"}
	fieldName__TrieBranchNode_Value  = _String{"Value"}
)
var _ ipld.Node = (TrieBranchNode)(&_TrieBranchNode{})
var _ schema.TypedNode = (TrieBranchNode)(&_TrieBranchNode{})

func (TrieBranchNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieBranchNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Child0":
		if n.Child0.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child0.v, nil
	case "Child1":
		if n.Child1.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child1.v, nil
	case "Child2":
		if n.Child2.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child2.v, nil
	case "Child3":
		if n.Child3.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child3.v, nil
	case "Child4":
		if n.Child4.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child4.v, nil
	case "Child5":
		if n.Child5.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child5.v, nil
	case "Child6":
		if n.Child6.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child6.v, nil
	case "Child7":
		if n.Child7.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child7.v, nil
	case "Child8":
		if n.Child8.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child8.v, nil
	case "Child9":
		if n.Child9.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child9.v, nil
	case "ChildA":
		if n.ChildA.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildA.v, nil
	case "ChildB":
		if n.ChildB.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildB.v, nil
	case "ChildC":
		if n.ChildC.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildC.v, nil
	case "ChildD":
		if n.ChildD.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildD.v, nil
	case "ChildE":
		if n.ChildE.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildE.v, nil
	case "ChildF":
		if n.ChildF.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildF.v, nil
	case "Value":
		if n.Value.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Value.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieBranchNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieBranchNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.LookupByIndex(0)
}
func (n TrieBranchNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieBranchNode) MapIterator() ipld.MapIterator {
	return &_TrieBranchNode__MapItr{n, 0}
}

type _TrieBranchNode__MapItr struct {
	n   TrieBranchNode
	idx int
}

func (itr *_TrieBranchNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 17 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieBranchNode_Child0
		if itr.n.Child0.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child0.v
	case 1:
		k = &fieldName__TrieBranchNode_Child1
		if itr.n.Child1.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child1.v
	case 2:
		k = &fieldName__TrieBranchNode_Child2
		if itr.n.Child2.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child2.v
	case 3:
		k = &fieldName__TrieBranchNode_Child3
		if itr.n.Child3.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child3.v
	case 4:
		k = &fieldName__TrieBranchNode_Child4
		if itr.n.Child4.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child4.v
	case 5:
		k = &fieldName__TrieBranchNode_Child5
		if itr.n.Child5.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child5.v
	case 6:
		k = &fieldName__TrieBranchNode_Child6
		if itr.n.Child6.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child6.v
	case 7:
		k = &fieldName__TrieBranchNode_Child7
		if itr.n.Child7.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child7.v
	case 8:
		k = &fieldName__TrieBranchNode_Child8
		if itr.n.Child8.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child8.v
	case 9:
		k = &fieldName__TrieBranchNode_Child9
		if itr.n.Child9.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child9.v
	case 10:
		k = &fieldName__TrieBranchNode_ChildA
		if itr.n.ChildA.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildA.v
	case 11:
		k = &fieldName__TrieBranchNode_ChildB
		if itr.n.ChildB.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildB.v
	case 12:
		k = &fieldName__TrieBranchNode_ChildC
		if itr.n.ChildC.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildC.v
	case 13:
		k = &fieldName__TrieBranchNode_ChildD
		if itr.n.ChildD.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildD.v
	case 14:
		k = &fieldName__TrieBranchNode_ChildE
		if itr.n.ChildE.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildE.v
	case 15:
		k = &fieldName__TrieBranchNode_ChildF
		if itr.n.ChildF.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildF.v
	case 16:
		k = &fieldName__TrieBranchNode_Value
		if itr.n.Value.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Value.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieBranchNode__MapItr) Done() bool {
	return itr.idx >= 17
}

func (TrieBranchNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieBranchNode) Length() int64 {
	return 17
}
func (TrieBranchNode) IsAbsent() bool {
	return false
}
func (TrieBranchNode) IsNull() bool {
	return false
}
func (TrieBranchNode) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsBool()
}
func (TrieBranchNode) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsInt()
}
func (TrieBranchNode) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsFloat()
}
func (TrieBranchNode) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsString()
}
func (TrieBranchNode) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsBytes()
}
func (TrieBranchNode) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode"}.AsLink()
}
func (TrieBranchNode) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__Prototype{}
}

type _TrieBranchNode__Prototype struct{}

func (_TrieBranchNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieBranchNode__Builder
	nb.Reset()
	return &nb
}

type _TrieBranchNode__Builder struct {
	_TrieBranchNode__Assembler
}

func (nb *_TrieBranchNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieBranchNode__Builder) Reset() {
	var w _TrieBranchNode
	var m schema.Maybe
	*nb = _TrieBranchNode__Builder{_TrieBranchNode__Assembler{w: &w, m: &m}}
}

type _TrieBranchNode__Assembler struct {
	w     *_TrieBranchNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Child0 _Child__Assembler
	ca_Child1 _Child__Assembler
	ca_Child2 _Child__Assembler
	ca_Child3 _Child__Assembler
	ca_Child4 _Child__Assembler
	ca_Child5 _Child__Assembler
	ca_Child6 _Child__Assembler
	ca_Child7 _Child__Assembler
	ca_Child8 _Child__Assembler
	ca_Child9 _Child__Assembler
	ca_ChildA _Child__Assembler
	ca_ChildB _Child__Assembler
	ca_ChildC _Child__Assembler
	ca_ChildD _Child__Assembler
	ca_ChildE _Child__Assembler
	ca_ChildF _Child__Assembler
	ca_Value  _Value__Assembler
}

func (na *_TrieBranchNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Child0.reset()
	na.ca_Child1.reset()
	na.ca_Child2.reset()
	na.ca_Child3.reset()
	na.ca_Child4.reset()
	na.ca_Child5.reset()
	na.ca_Child6.reset()
	na.ca_Child7.reset()
	na.ca_Child8.reset()
	na.ca_Child9.reset()
	na.ca_ChildA.reset()
	na.ca_ChildB.reset()
	na.ca_ChildC.reset()
	na.ca_ChildD.reset()
	na.ca_ChildE.reset()
	na.ca_ChildF.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__TrieBranchNode_Child0      = 1 << 0
	fieldBit__TrieBranchNode_Child1      = 1 << 1
	fieldBit__TrieBranchNode_Child2      = 1 << 2
	fieldBit__TrieBranchNode_Child3      = 1 << 3
	fieldBit__TrieBranchNode_Child4      = 1 << 4
	fieldBit__TrieBranchNode_Child5      = 1 << 5
	fieldBit__TrieBranchNode_Child6      = 1 << 6
	fieldBit__TrieBranchNode_Child7      = 1 << 7
	fieldBit__TrieBranchNode_Child8      = 1 << 8
	fieldBit__TrieBranchNode_Child9      = 1 << 9
	fieldBit__TrieBranchNode_ChildA      = 1 << 10
	fieldBit__TrieBranchNode_ChildB      = 1 << 11
	fieldBit__TrieBranchNode_ChildC      = 1 << 12
	fieldBit__TrieBranchNode_ChildD      = 1 << 13
	fieldBit__TrieBranchNode_ChildE      = 1 << 14
	fieldBit__TrieBranchNode_ChildF      = 1 << 15
	fieldBit__TrieBranchNode_Value       = 1 << 16
	fieldBits__TrieBranchNode_sufficient = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5 + 1<<6 + 1<<7 + 1<<8 + 1<<9 + 1<<10 + 1<<11 + 1<<12 + 1<<13 + 1<<14 + 1<<15 + 1<<16
)

func (na *_TrieBranchNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieBranchNode{}
	}
	return na, nil
}
func (_TrieBranchNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.BeginList(0)
}
func (na *_TrieBranchNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieBranchNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignBool(false)
}
func (_TrieBranchNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignInt(0)
}
func (_TrieBranchNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignFloat(0)
}
func (_TrieBranchNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignString("")
}
func (_TrieBranchNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignBytes(nil)
}
func (_TrieBranchNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode"}.AssignLink(nil)
}
func (na *_TrieBranchNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieBranchNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieBranchNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieBranchNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__Prototype{}
}
func (ma *_TrieBranchNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Child0.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child0.v = ma.ca_Child0.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Child1.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child1.v = ma.ca_Child1.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Child2.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child2.v = ma.ca_Child2.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Child3.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child3.v = ma.ca_Child3.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Child4.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child4.v = ma.ca_Child4.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.Child5.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child5.v = ma.ca_Child5.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Child6.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child6.v = ma.ca_Child6.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Child7.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child7.v = ma.ca_Child7.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.Child8.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child8.v = ma.ca_Child8.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.Child9.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child9.v = ma.ca_Child9.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.ChildA.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildA.v = ma.ca_ChildA.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.w.ChildB.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildB.v = ma.ca_ChildB.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.w.ChildC.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildC.v = ma.ca_ChildC.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.w.ChildD.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildD.v = ma.ca_ChildD.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.w.ChildE.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildE.v = ma.ca_ChildE.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.ChildF.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildF.v = ma.ca_ChildF.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 16:
		switch ma.w.Value.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Value.v = ma.ca_Value.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Child0":
		if ma.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0}
		}
		ma.s += fieldBit__TrieBranchNode_Child0
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0, nil
	case "Child1":
		if ma.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1}
		}
		ma.s += fieldBit__TrieBranchNode_Child1
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1, nil
	case "Child2":
		if ma.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2}
		}
		ma.s += fieldBit__TrieBranchNode_Child2
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2, nil
	case "Child3":
		if ma.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3}
		}
		ma.s += fieldBit__TrieBranchNode_Child3
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3, nil
	case "Child4":
		if ma.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4}
		}
		ma.s += fieldBit__TrieBranchNode_Child4
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4, nil
	case "Child5":
		if ma.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5}
		}
		ma.s += fieldBit__TrieBranchNode_Child5
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5, nil
	case "Child6":
		if ma.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6}
		}
		ma.s += fieldBit__TrieBranchNode_Child6
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6, nil
	case "Child7":
		if ma.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7}
		}
		ma.s += fieldBit__TrieBranchNode_Child7
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7, nil
	case "Child8":
		if ma.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8}
		}
		ma.s += fieldBit__TrieBranchNode_Child8
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8, nil
	case "Child9":
		if ma.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9}
		}
		ma.s += fieldBit__TrieBranchNode_Child9
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9, nil
	case "ChildA":
		if ma.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA}
		}
		ma.s += fieldBit__TrieBranchNode_ChildA
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA, nil
	case "ChildB":
		if ma.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB}
		}
		ma.s += fieldBit__TrieBranchNode_ChildB
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB, nil
	case "ChildC":
		if ma.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC}
		}
		ma.s += fieldBit__TrieBranchNode_ChildC
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC, nil
	case "ChildD":
		if ma.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD}
		}
		ma.s += fieldBit__TrieBranchNode_ChildD
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD, nil
	case "ChildE":
		if ma.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE}
		}
		ma.s += fieldBit__TrieBranchNode_ChildE
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE, nil
	case "ChildF":
		if ma.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF}
		}
		ma.s += fieldBit__TrieBranchNode_ChildF
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF, nil
	case "Value":
		if ma.s&fieldBit__TrieBranchNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value}
		}
		ma.s += fieldBit__TrieBranchNode_Value
		ma.state = maState_midValue
		ma.f = 16
		ma.ca_Value.w = ma.w.Value.v
		ma.ca_Value.m = &ma.w.Value.m
		ma.w.Value.m = allowNull
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode", Key: &_String{k}}
}
func (ma *_TrieBranchNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieBranchNode__KeyAssembler)(ma)
}
func (ma *_TrieBranchNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0
	case 1:
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1
	case 2:
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2
	case 3:
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3
	case 4:
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4
	case 5:
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5
	case 6:
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6
	case 7:
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7
	case 8:
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8
	case 9:
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9
	case 10:
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA
	case 11:
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB
	case 12:
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC
	case 13:
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD
	case 14:
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE
	case 15:
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF
	case 16:
		ma.ca_Value.w = ma.w.Value.v
		ma.ca_Value.m = &ma.w.Value.m
		ma.w.Value.m = allowNull
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieBranchNode_sufficient != fieldBits__TrieBranchNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieBranchNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieBranchNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieBranchNode__KeyAssembler _TrieBranchNode__Assembler

func (_TrieBranchNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieBranchNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieBranchNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignNull()
}
func (_TrieBranchNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieBranchNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieBranchNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieBranchNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Child0":
		if ka.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0}
		}
		ka.s += fieldBit__TrieBranchNode_Child0
		ka.state = maState_expectValue
		ka.f = 0
	case "Child1":
		if ka.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1}
		}
		ka.s += fieldBit__TrieBranchNode_Child1
		ka.state = maState_expectValue
		ka.f = 1
	case "Child2":
		if ka.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2}
		}
		ka.s += fieldBit__TrieBranchNode_Child2
		ka.state = maState_expectValue
		ka.f = 2
	case "Child3":
		if ka.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3}
		}
		ka.s += fieldBit__TrieBranchNode_Child3
		ka.state = maState_expectValue
		ka.f = 3
	case "Child4":
		if ka.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4}
		}
		ka.s += fieldBit__TrieBranchNode_Child4
		ka.state = maState_expectValue
		ka.f = 4
	case "Child5":
		if ka.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5}
		}
		ka.s += fieldBit__TrieBranchNode_Child5
		ka.state = maState_expectValue
		ka.f = 5
	case "Child6":
		if ka.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6}
		}
		ka.s += fieldBit__TrieBranchNode_Child6
		ka.state = maState_expectValue
		ka.f = 6
	case "Child7":
		if ka.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7}
		}
		ka.s += fieldBit__TrieBranchNode_Child7
		ka.state = maState_expectValue
		ka.f = 7
	case "Child8":
		if ka.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8}
		}
		ka.s += fieldBit__TrieBranchNode_Child8
		ka.state = maState_expectValue
		ka.f = 8
	case "Child9":
		if ka.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9}
		}
		ka.s += fieldBit__TrieBranchNode_Child9
		ka.state = maState_expectValue
		ka.f = 9
	case "ChildA":
		if ka.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA}
		}
		ka.s += fieldBit__TrieBranchNode_ChildA
		ka.state = maState_expectValue
		ka.f = 10
	case "ChildB":
		if ka.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB}
		}
		ka.s += fieldBit__TrieBranchNode_ChildB
		ka.state = maState_expectValue
		ka.f = 11
	case "ChildC":
		if ka.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC}
		}
		ka.s += fieldBit__TrieBranchNode_ChildC
		ka.state = maState_expectValue
		ka.f = 12
	case "ChildD":
		if ka.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD}
		}
		ka.s += fieldBit__TrieBranchNode_ChildD
		ka.state = maState_expectValue
		ka.f = 13
	case "ChildE":
		if ka.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE}
		}
		ka.s += fieldBit__TrieBranchNode_ChildE
		ka.state = maState_expectValue
		ka.f = 14
	case "ChildF":
		if ka.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF}
		}
		ka.s += fieldBit__TrieBranchNode_ChildF
		ka.state = maState_expectValue
		ka.f = 15
	case "Value":
		if ka.s&fieldBit__TrieBranchNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value}
		}
		ka.s += fieldBit__TrieBranchNode_Value
		ka.state = maState_expectValue
		ka.f = 16
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieBranchNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieBranchNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieBranchNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieBranchNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieBranchNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieBranchNode) Representation() ipld.Node {
	return (*_TrieBranchNode__Repr)(n)
}

type _TrieBranchNode__Repr _TrieBranchNode

var (
	fieldName__TrieBranchNode_Child0_serial = _String{"Child0"}
	fieldName__TrieBranchNode_Child1_serial = _String{"Child1"}
	fieldName__TrieBranchNode_Child2_serial = _String{"Child2"}
	fieldName__TrieBranchNode_Child3_serial = _String{"Child3"}
	fieldName__TrieBranchNode_Child4_serial = _String{"Child4"}
	fieldName__TrieBranchNode_Child5_serial = _String{"Child5"}
	fieldName__TrieBranchNode_Child6_serial = _String{"Child6"}
	fieldName__TrieBranchNode_Child7_serial = _String{"Child7"}
	fieldName__TrieBranchNode_Child8_serial = _String{"Child8"}
	fieldName__TrieBranchNode_Child9_serial = _String{"Child9"}
	fieldName__TrieBranchNode_ChildA_serial = _String{"ChildA"}
	fieldName__TrieBranchNode_ChildB_serial = _String{"ChildB"}
	fieldName__TrieBranchNode_ChildC_serial = _String{"ChildC"}
	fieldName__TrieBranchNode_ChildD_serial = _String{"ChildD"}
	fieldName__TrieBranchNode_ChildE_serial = _String{"ChildE"}
	fieldName__TrieBranchNode_ChildF_serial = _String{"ChildF"}
	fieldName__TrieBranchNode_Value_serial  = _String{"Value"}
)
var _ ipld.Node = &_TrieBranchNode__Repr{}

func (_TrieBranchNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieBranchNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Child0":
		if n.Child0.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child0.v.Representation(), nil
	case "Child1":
		if n.Child1.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child1.v.Representation(), nil
	case "Child2":
		if n.Child2.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child2.v.Representation(), nil
	case "Child3":
		if n.Child3.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child3.v.Representation(), nil
	case "Child4":
		if n.Child4.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child4.v.Representation(), nil
	case "Child5":
		if n.Child5.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child5.v.Representation(), nil
	case "Child6":
		if n.Child6.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child6.v.Representation(), nil
	case "Child7":
		if n.Child7.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child7.v.Representation(), nil
	case "Child8":
		if n.Child8.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child8.v.Representation(), nil
	case "Child9":
		if n.Child9.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Child9.v.Representation(), nil
	case "ChildA":
		if n.ChildA.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildA.v.Representation(), nil
	case "ChildB":
		if n.ChildB.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildB.v.Representation(), nil
	case "ChildC":
		if n.ChildC.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildC.v.Representation(), nil
	case "ChildD":
		if n.ChildD.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildD.v.Representation(), nil
	case "ChildE":
		if n.ChildE.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildE.v.Representation(), nil
	case "ChildF":
		if n.ChildF.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.ChildF.v.Representation(), nil
	case "Value":
		if n.Value.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Value.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieBranchNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieBranchNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.LookupByIndex(0)
}
func (n _TrieBranchNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieBranchNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieBranchNode__ReprMapItr{n, 0}
}

type _TrieBranchNode__ReprMapItr struct {
	n   *_TrieBranchNode__Repr
	idx int
}

func (itr *_TrieBranchNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 17 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieBranchNode_Child0_serial
		if itr.n.Child0.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child0.v.Representation()
	case 1:
		k = &fieldName__TrieBranchNode_Child1_serial
		if itr.n.Child1.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child1.v.Representation()
	case 2:
		k = &fieldName__TrieBranchNode_Child2_serial
		if itr.n.Child2.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child2.v.Representation()
	case 3:
		k = &fieldName__TrieBranchNode_Child3_serial
		if itr.n.Child3.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child3.v.Representation()
	case 4:
		k = &fieldName__TrieBranchNode_Child4_serial
		if itr.n.Child4.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child4.v.Representation()
	case 5:
		k = &fieldName__TrieBranchNode_Child5_serial
		if itr.n.Child5.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child5.v.Representation()
	case 6:
		k = &fieldName__TrieBranchNode_Child6_serial
		if itr.n.Child6.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child6.v.Representation()
	case 7:
		k = &fieldName__TrieBranchNode_Child7_serial
		if itr.n.Child7.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child7.v.Representation()
	case 8:
		k = &fieldName__TrieBranchNode_Child8_serial
		if itr.n.Child8.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child8.v.Representation()
	case 9:
		k = &fieldName__TrieBranchNode_Child9_serial
		if itr.n.Child9.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Child9.v.Representation()
	case 10:
		k = &fieldName__TrieBranchNode_ChildA_serial
		if itr.n.ChildA.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildA.v.Representation()
	case 11:
		k = &fieldName__TrieBranchNode_ChildB_serial
		if itr.n.ChildB.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildB.v.Representation()
	case 12:
		k = &fieldName__TrieBranchNode_ChildC_serial
		if itr.n.ChildC.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildC.v.Representation()
	case 13:
		k = &fieldName__TrieBranchNode_ChildD_serial
		if itr.n.ChildD.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildD.v.Representation()
	case 14:
		k = &fieldName__TrieBranchNode_ChildE_serial
		if itr.n.ChildE.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildE.v.Representation()
	case 15:
		k = &fieldName__TrieBranchNode_ChildF_serial
		if itr.n.ChildF.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.ChildF.v.Representation()
	case 16:
		k = &fieldName__TrieBranchNode_Value_serial
		if itr.n.Value.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Value.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieBranchNode__ReprMapItr) Done() bool {
	return itr.idx >= 17
}
func (_TrieBranchNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieBranchNode__Repr) Length() int64 {
	l := 17
	return int64(l)
}
func (_TrieBranchNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieBranchNode__Repr) IsNull() bool {
	return false
}
func (_TrieBranchNode__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsBool()
}
func (_TrieBranchNode__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsInt()
}
func (_TrieBranchNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsFloat()
}
func (_TrieBranchNode__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsString()
}
func (_TrieBranchNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsBytes()
}
func (_TrieBranchNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieBranchNode.Repr"}.AsLink()
}
func (_TrieBranchNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__ReprPrototype{}
}

type _TrieBranchNode__ReprPrototype struct{}

func (_TrieBranchNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieBranchNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieBranchNode__ReprBuilder struct {
	_TrieBranchNode__ReprAssembler
}

func (nb *_TrieBranchNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieBranchNode__ReprBuilder) Reset() {
	var w _TrieBranchNode
	var m schema.Maybe
	*nb = _TrieBranchNode__ReprBuilder{_TrieBranchNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieBranchNode__ReprAssembler struct {
	w     *_TrieBranchNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm        schema.Maybe
	ca_Child0 _Child__ReprAssembler
	ca_Child1 _Child__ReprAssembler
	ca_Child2 _Child__ReprAssembler
	ca_Child3 _Child__ReprAssembler
	ca_Child4 _Child__ReprAssembler
	ca_Child5 _Child__ReprAssembler
	ca_Child6 _Child__ReprAssembler
	ca_Child7 _Child__ReprAssembler
	ca_Child8 _Child__ReprAssembler
	ca_Child9 _Child__ReprAssembler
	ca_ChildA _Child__ReprAssembler
	ca_ChildB _Child__ReprAssembler
	ca_ChildC _Child__ReprAssembler
	ca_ChildD _Child__ReprAssembler
	ca_ChildE _Child__ReprAssembler
	ca_ChildF _Child__ReprAssembler
	ca_Value  _Value__ReprAssembler
}

func (na *_TrieBranchNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Child0.reset()
	na.ca_Child1.reset()
	na.ca_Child2.reset()
	na.ca_Child3.reset()
	na.ca_Child4.reset()
	na.ca_Child5.reset()
	na.ca_Child6.reset()
	na.ca_Child7.reset()
	na.ca_Child8.reset()
	na.ca_Child9.reset()
	na.ca_ChildA.reset()
	na.ca_ChildB.reset()
	na.ca_ChildC.reset()
	na.ca_ChildD.reset()
	na.ca_ChildE.reset()
	na.ca_ChildF.reset()
	na.ca_Value.reset()
}
func (na *_TrieBranchNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieBranchNode{}
	}
	return na, nil
}
func (_TrieBranchNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.BeginList(0)
}
func (na *_TrieBranchNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieBranchNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignBool(false)
}
func (_TrieBranchNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignInt(0)
}
func (_TrieBranchNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignFloat(0)
}
func (_TrieBranchNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignString("")
}
func (_TrieBranchNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignBytes(nil)
}
func (_TrieBranchNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieBranchNode.Repr"}.AssignLink(nil)
}
func (na *_TrieBranchNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieBranchNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieBranchNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieBranchNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieBranchNode__ReprPrototype{}
}
func (ma *_TrieBranchNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Child0.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child0.v = ma.ca_Child0.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.Child1.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child1.v = ma.ca_Child1.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Child2.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child2.v = ma.ca_Child2.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Child3.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child3.v = ma.ca_Child3.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.Child4.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child4.v = ma.ca_Child4.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.Child5.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child5.v = ma.ca_Child5.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Child6.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child6.v = ma.ca_Child6.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.Child7.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child7.v = ma.ca_Child7.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.Child8.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child8.v = ma.ca_Child8.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.Child9.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Child9.v = ma.ca_Child9.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.ChildA.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildA.v = ma.ca_ChildA.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.w.ChildB.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildB.v = ma.ca_ChildB.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 12:
		switch ma.w.ChildC.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildC.v = ma.ca_ChildC.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 13:
		switch ma.w.ChildD.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildD.v = ma.ca_ChildD.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 14:
		switch ma.w.ChildE.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildE.v = ma.ca_ChildE.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 15:
		switch ma.w.ChildF.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.ChildF.v = ma.ca_ChildF.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 16:
		switch ma.w.Value.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Value.v = ma.ca_Value.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Child0":
		if ma.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child0
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0, nil
	case "Child1":
		if ma.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child1
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1, nil
	case "Child2":
		if ma.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child2
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2, nil
	case "Child3":
		if ma.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child3
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3, nil
	case "Child4":
		if ma.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child4
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4, nil
	case "Child5":
		if ma.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child5
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5, nil
	case "Child6":
		if ma.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child6
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6, nil
	case "Child7":
		if ma.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child7
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7, nil
	case "Child8":
		if ma.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child8
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8, nil
	case "Child9":
		if ma.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Child9
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9, nil
	case "ChildA":
		if ma.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildA
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA, nil
	case "ChildB":
		if ma.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildB
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB, nil
	case "ChildC":
		if ma.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildC
		ma.state = maState_midValue
		ma.f = 12
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC, nil
	case "ChildD":
		if ma.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildD
		ma.state = maState_midValue
		ma.f = 13
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD, nil
	case "ChildE":
		if ma.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildE
		ma.state = maState_midValue
		ma.f = 14
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE, nil
	case "ChildF":
		if ma.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF_serial}
		}
		ma.s += fieldBit__TrieBranchNode_ChildF
		ma.state = maState_midValue
		ma.f = 15
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF, nil
	case "Value":
		if ma.s&fieldBit__TrieBranchNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value_serial}
		}
		ma.s += fieldBit__TrieBranchNode_Value
		ma.state = maState_midValue
		ma.f = 16
		ma.ca_Value.w = ma.w.Value.v
		ma.ca_Value.m = &ma.w.Value.m
		ma.w.Value.m = allowNull
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode.Repr", Key: &_String{k}}
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieBranchNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieBranchNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Child0.w = ma.w.Child0.v
		ma.ca_Child0.m = &ma.w.Child0.m
		ma.w.Child0.m = allowNull
		return &ma.ca_Child0
	case 1:
		ma.ca_Child1.w = ma.w.Child1.v
		ma.ca_Child1.m = &ma.w.Child1.m
		ma.w.Child1.m = allowNull
		return &ma.ca_Child1
	case 2:
		ma.ca_Child2.w = ma.w.Child2.v
		ma.ca_Child2.m = &ma.w.Child2.m
		ma.w.Child2.m = allowNull
		return &ma.ca_Child2
	case 3:
		ma.ca_Child3.w = ma.w.Child3.v
		ma.ca_Child3.m = &ma.w.Child3.m
		ma.w.Child3.m = allowNull
		return &ma.ca_Child3
	case 4:
		ma.ca_Child4.w = ma.w.Child4.v
		ma.ca_Child4.m = &ma.w.Child4.m
		ma.w.Child4.m = allowNull
		return &ma.ca_Child4
	case 5:
		ma.ca_Child5.w = ma.w.Child5.v
		ma.ca_Child5.m = &ma.w.Child5.m
		ma.w.Child5.m = allowNull
		return &ma.ca_Child5
	case 6:
		ma.ca_Child6.w = ma.w.Child6.v
		ma.ca_Child6.m = &ma.w.Child6.m
		ma.w.Child6.m = allowNull
		return &ma.ca_Child6
	case 7:
		ma.ca_Child7.w = ma.w.Child7.v
		ma.ca_Child7.m = &ma.w.Child7.m
		ma.w.Child7.m = allowNull
		return &ma.ca_Child7
	case 8:
		ma.ca_Child8.w = ma.w.Child8.v
		ma.ca_Child8.m = &ma.w.Child8.m
		ma.w.Child8.m = allowNull
		return &ma.ca_Child8
	case 9:
		ma.ca_Child9.w = ma.w.Child9.v
		ma.ca_Child9.m = &ma.w.Child9.m
		ma.w.Child9.m = allowNull
		return &ma.ca_Child9
	case 10:
		ma.ca_ChildA.w = ma.w.ChildA.v
		ma.ca_ChildA.m = &ma.w.ChildA.m
		ma.w.ChildA.m = allowNull
		return &ma.ca_ChildA
	case 11:
		ma.ca_ChildB.w = ma.w.ChildB.v
		ma.ca_ChildB.m = &ma.w.ChildB.m
		ma.w.ChildB.m = allowNull
		return &ma.ca_ChildB
	case 12:
		ma.ca_ChildC.w = ma.w.ChildC.v
		ma.ca_ChildC.m = &ma.w.ChildC.m
		ma.w.ChildC.m = allowNull
		return &ma.ca_ChildC
	case 13:
		ma.ca_ChildD.w = ma.w.ChildD.v
		ma.ca_ChildD.m = &ma.w.ChildD.m
		ma.w.ChildD.m = allowNull
		return &ma.ca_ChildD
	case 14:
		ma.ca_ChildE.w = ma.w.ChildE.v
		ma.ca_ChildE.m = &ma.w.ChildE.m
		ma.w.ChildE.m = allowNull
		return &ma.ca_ChildE
	case 15:
		ma.ca_ChildF.w = ma.w.ChildF.v
		ma.ca_ChildF.m = &ma.w.ChildF.m
		ma.w.ChildF.m = allowNull
		return &ma.ca_ChildF
	case 16:
		ma.ca_Value.w = ma.w.Value.v
		ma.ca_Value.m = &ma.w.Value.m
		ma.w.Value.m = allowNull
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieBranchNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieBranchNode_sufficient != fieldBits__TrieBranchNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieBranchNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieBranchNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieBranchNode__ReprKeyAssembler _TrieBranchNode__ReprAssembler

func (_TrieBranchNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieBranchNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieBranchNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieBranchNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieBranchNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Child0":
		if ka.s&fieldBit__TrieBranchNode_Child0 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child0_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child0
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Child1":
		if ka.s&fieldBit__TrieBranchNode_Child1 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child1_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child1
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Child2":
		if ka.s&fieldBit__TrieBranchNode_Child2 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child2_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child2
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Child3":
		if ka.s&fieldBit__TrieBranchNode_Child3 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child3_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child3
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Child4":
		if ka.s&fieldBit__TrieBranchNode_Child4 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child4_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child4
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Child5":
		if ka.s&fieldBit__TrieBranchNode_Child5 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child5_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child5
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	case "Child6":
		if ka.s&fieldBit__TrieBranchNode_Child6 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child6_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child6
		ka.state = maState_expectValue
		ka.f = 6
		return nil
	case "Child7":
		if ka.s&fieldBit__TrieBranchNode_Child7 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child7_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child7
		ka.state = maState_expectValue
		ka.f = 7
		return nil
	case "Child8":
		if ka.s&fieldBit__TrieBranchNode_Child8 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child8_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child8
		ka.state = maState_expectValue
		ka.f = 8
		return nil
	case "Child9":
		if ka.s&fieldBit__TrieBranchNode_Child9 != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Child9_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Child9
		ka.state = maState_expectValue
		ka.f = 9
		return nil
	case "ChildA":
		if ka.s&fieldBit__TrieBranchNode_ChildA != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildA_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildA
		ka.state = maState_expectValue
		ka.f = 10
		return nil
	case "ChildB":
		if ka.s&fieldBit__TrieBranchNode_ChildB != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildB_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildB
		ka.state = maState_expectValue
		ka.f = 11
		return nil
	case "ChildC":
		if ka.s&fieldBit__TrieBranchNode_ChildC != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildC_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildC
		ka.state = maState_expectValue
		ka.f = 12
		return nil
	case "ChildD":
		if ka.s&fieldBit__TrieBranchNode_ChildD != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildD_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildD
		ka.state = maState_expectValue
		ka.f = 13
		return nil
	case "ChildE":
		if ka.s&fieldBit__TrieBranchNode_ChildE != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildE_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildE
		ka.state = maState_expectValue
		ka.f = 14
		return nil
	case "ChildF":
		if ka.s&fieldBit__TrieBranchNode_ChildF != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_ChildF_serial}
		}
		ka.s += fieldBit__TrieBranchNode_ChildF
		ka.state = maState_expectValue
		ka.f = 15
		return nil
	case "Value":
		if ka.s&fieldBit__TrieBranchNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieBranchNode_Value_serial}
		}
		ka.s += fieldBit__TrieBranchNode_Value
		ka.state = maState_expectValue
		ka.f = 16
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieBranchNode.Repr", Key: &_String{k}}
}
func (_TrieBranchNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieBranchNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieBranchNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieBranchNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieBranchNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieExtensionNode) FieldPartialPath() Bytes {
	return &n.PartialPath
}
func (n _TrieExtensionNode) FieldChild() Link {
	return &n.Child
}

type _TrieExtensionNode__Maybe struct {
	m schema.Maybe
	v TrieExtensionNode
}
type MaybeTrieExtensionNode = *_TrieExtensionNode__Maybe

func (m MaybeTrieExtensionNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieExtensionNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieExtensionNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieExtensionNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieExtensionNode) Must() TrieExtensionNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieExtensionNode_PartialPath = _String{"PartialPath"}
	fieldName__TrieExtensionNode_Child       = _String{"Child"}
)
var _ ipld.Node = (TrieExtensionNode)(&_TrieExtensionNode{})
var _ schema.TypedNode = (TrieExtensionNode)(&_TrieExtensionNode{})

func (TrieExtensionNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieExtensionNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return &n.PartialPath, nil
	case "Child":
		return &n.Child, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieExtensionNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieExtensionNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.LookupByIndex(0)
}
func (n TrieExtensionNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieExtensionNode) MapIterator() ipld.MapIterator {
	return &_TrieExtensionNode__MapItr{n, 0}
}

type _TrieExtensionNode__MapItr struct {
	n   TrieExtensionNode
	idx int
}

func (itr *_TrieExtensionNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieExtensionNode_PartialPath
		v = &itr.n.PartialPath
	case 1:
		k = &fieldName__TrieExtensionNode_Child
		v = &itr.n.Child
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieExtensionNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TrieExtensionNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieExtensionNode) Length() int64 {
	return 2
}
func (TrieExtensionNode) IsAbsent() bool {
	return false
}
func (TrieExtensionNode) IsNull() bool {
	return false
}
func (TrieExtensionNode) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsBool()
}
func (TrieExtensionNode) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsInt()
}
func (TrieExtensionNode) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsFloat()
}
func (TrieExtensionNode) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsString()
}
func (TrieExtensionNode) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsBytes()
}
func (TrieExtensionNode) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode"}.AsLink()
}
func (TrieExtensionNode) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__Prototype{}
}

type _TrieExtensionNode__Prototype struct{}

func (_TrieExtensionNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieExtensionNode__Builder
	nb.Reset()
	return &nb
}

type _TrieExtensionNode__Builder struct {
	_TrieExtensionNode__Assembler
}

func (nb *_TrieExtensionNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieExtensionNode__Builder) Reset() {
	var w _TrieExtensionNode
	var m schema.Maybe
	*nb = _TrieExtensionNode__Builder{_TrieExtensionNode__Assembler{w: &w, m: &m}}
}

type _TrieExtensionNode__Assembler struct {
	w     *_TrieExtensionNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__Assembler
	ca_Child       _Link__Assembler
}

func (na *_TrieExtensionNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Child.reset()
}

var (
	fieldBit__TrieExtensionNode_PartialPath = 1 << 0
	fieldBit__TrieExtensionNode_Child       = 1 << 1
	fieldBits__TrieExtensionNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_TrieExtensionNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieExtensionNode{}
	}
	return na, nil
}
func (_TrieExtensionNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.BeginList(0)
}
func (na *_TrieExtensionNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieExtensionNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignBool(false)
}
func (_TrieExtensionNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignInt(0)
}
func (_TrieExtensionNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignFloat(0)
}
func (_TrieExtensionNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignString("")
}
func (_TrieExtensionNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignBytes(nil)
}
func (_TrieExtensionNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode"}.AssignLink(nil)
}
func (na *_TrieExtensionNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieExtensionNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieExtensionNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieExtensionNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__Prototype{}
}
func (ma *_TrieExtensionNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartialPath.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Child.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath}
		}
		ma.s += fieldBit__TrieExtensionNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Child":
		if ma.s&fieldBit__TrieExtensionNode_Child != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_Child}
		}
		ma.s += fieldBit__TrieExtensionNode_Child
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child.w = &ma.w.Child
		ma.ca_Child.m = &ma.cm
		return &ma.ca_Child, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode", Key: &_String{k}}
}
func (ma *_TrieExtensionNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieExtensionNode__KeyAssembler)(ma)
}
func (ma *_TrieExtensionNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Child.w = &ma.w.Child
		ma.ca_Child.m = &ma.cm
		return &ma.ca_Child
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieExtensionNode_sufficient != fieldBits__TrieExtensionNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieExtensionNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieExtensionNode_Child == 0 {
			err.Missing = append(err.Missing, "Child")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieExtensionNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieExtensionNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieExtensionNode__KeyAssembler _TrieExtensionNode__Assembler

func (_TrieExtensionNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieExtensionNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieExtensionNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignNull()
}
func (_TrieExtensionNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieExtensionNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieExtensionNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieExtensionNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath}
		}
		ka.s += fieldBit__TrieExtensionNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
	case "Child":
		if ka.s&fieldBit__TrieExtensionNode_Child != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_Child}
		}
		ka.s += fieldBit__TrieExtensionNode_Child
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieExtensionNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieExtensionNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieExtensionNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieExtensionNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieExtensionNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieExtensionNode) Representation() ipld.Node {
	return (*_TrieExtensionNode__Repr)(n)
}

type _TrieExtensionNode__Repr _TrieExtensionNode

var (
	fieldName__TrieExtensionNode_PartialPath_serial = _String{"PartialPath"}
	fieldName__TrieExtensionNode_Child_serial       = _String{"Child"}
)
var _ ipld.Node = &_TrieExtensionNode__Repr{}

func (_TrieExtensionNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieExtensionNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return n.PartialPath.Representation(), nil
	case "Child":
		return n.Child.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieExtensionNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieExtensionNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.LookupByIndex(0)
}
func (n _TrieExtensionNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieExtensionNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieExtensionNode__ReprMapItr{n, 0}
}

type _TrieExtensionNode__ReprMapItr struct {
	n   *_TrieExtensionNode__Repr
	idx int
}

func (itr *_TrieExtensionNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieExtensionNode_PartialPath_serial
		v = itr.n.PartialPath.Representation()
	case 1:
		k = &fieldName__TrieExtensionNode_Child_serial
		v = itr.n.Child.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieExtensionNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TrieExtensionNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieExtensionNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_TrieExtensionNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieExtensionNode__Repr) IsNull() bool {
	return false
}
func (_TrieExtensionNode__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsBool()
}
func (_TrieExtensionNode__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsInt()
}
func (_TrieExtensionNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsFloat()
}
func (_TrieExtensionNode__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsString()
}
func (_TrieExtensionNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsBytes()
}
func (_TrieExtensionNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieExtensionNode.Repr"}.AsLink()
}
func (_TrieExtensionNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__ReprPrototype{}
}

type _TrieExtensionNode__ReprPrototype struct{}

func (_TrieExtensionNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieExtensionNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieExtensionNode__ReprBuilder struct {
	_TrieExtensionNode__ReprAssembler
}

func (nb *_TrieExtensionNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieExtensionNode__ReprBuilder) Reset() {
	var w _TrieExtensionNode
	var m schema.Maybe
	*nb = _TrieExtensionNode__ReprBuilder{_TrieExtensionNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieExtensionNode__ReprAssembler struct {
	w     *_TrieExtensionNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__ReprAssembler
	ca_Child       _Link__ReprAssembler
}

func (na *_TrieExtensionNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Child.reset()
}
func (na *_TrieExtensionNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieExtensionNode{}
	}
	return na, nil
}
func (_TrieExtensionNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.BeginList(0)
}
func (na *_TrieExtensionNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieExtensionNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignBool(false)
}
func (_TrieExtensionNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignInt(0)
}
func (_TrieExtensionNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignFloat(0)
}
func (_TrieExtensionNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignString("")
}
func (_TrieExtensionNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignBytes(nil)
}
func (_TrieExtensionNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieExtensionNode.Repr"}.AssignLink(nil)
}
func (na *_TrieExtensionNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieExtensionNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieExtensionNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieExtensionNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieExtensionNode__ReprPrototype{}
}
func (ma *_TrieExtensionNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath_serial}
		}
		ma.s += fieldBit__TrieExtensionNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Child":
		if ma.s&fieldBit__TrieExtensionNode_Child != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_Child_serial}
		}
		ma.s += fieldBit__TrieExtensionNode_Child
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Child.w = &ma.w.Child
		ma.ca_Child.m = &ma.cm
		return &ma.ca_Child, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode.Repr", Key: &_String{k}}
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieExtensionNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieExtensionNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Child.w = &ma.w.Child
		ma.ca_Child.m = &ma.cm
		return &ma.ca_Child
	default:
		panic("unreachable")
	}
}
func (ma *_TrieExtensionNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieExtensionNode_sufficient != fieldBits__TrieExtensionNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieExtensionNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieExtensionNode_Child == 0 {
			err.Missing = append(err.Missing, "Child")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieExtensionNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieExtensionNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieExtensionNode__ReprKeyAssembler _TrieExtensionNode__ReprAssembler

func (_TrieExtensionNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieExtensionNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieExtensionNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieExtensionNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieExtensionNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_PartialPath_serial}
		}
		ka.s += fieldBit__TrieExtensionNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Child":
		if ka.s&fieldBit__TrieExtensionNode_Child != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieExtensionNode_Child_serial}
		}
		ka.s += fieldBit__TrieExtensionNode_Child
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieExtensionNode.Repr", Key: &_String{k}}
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieExtensionNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieExtensionNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieExtensionNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieExtensionNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieLeafNode) FieldPartialPath() Bytes {
	return &n.PartialPath
}
func (n _TrieLeafNode) FieldValue() Value {
	return &n.Value
}

type _TrieLeafNode__Maybe struct {
	m schema.Maybe
	v TrieLeafNode
}
type MaybeTrieLeafNode = *_TrieLeafNode__Maybe

func (m MaybeTrieLeafNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieLeafNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieLeafNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieLeafNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieLeafNode) Must() TrieLeafNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TrieLeafNode_PartialPath = _String{"PartialPath"}
	fieldName__TrieLeafNode_Value       = _String{"Value"}
)
var _ ipld.Node = (TrieLeafNode)(&_TrieLeafNode{})
var _ schema.TypedNode = (TrieLeafNode)(&_TrieLeafNode{})

func (TrieLeafNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieLeafNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return &n.PartialPath, nil
	case "Value":
		return &n.Value, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieLeafNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieLeafNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.LookupByIndex(0)
}
func (n TrieLeafNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieLeafNode) MapIterator() ipld.MapIterator {
	return &_TrieLeafNode__MapItr{n, 0}
}

type _TrieLeafNode__MapItr struct {
	n   TrieLeafNode
	idx int
}

func (itr *_TrieLeafNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieLeafNode_PartialPath
		v = &itr.n.PartialPath
	case 1:
		k = &fieldName__TrieLeafNode_Value
		v = &itr.n.Value
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieLeafNode__MapItr) Done() bool {
	return itr.idx >= 2
}

func (TrieLeafNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieLeafNode) Length() int64 {
	return 2
}
func (TrieLeafNode) IsAbsent() bool {
	return false
}
func (TrieLeafNode) IsNull() bool {
	return false
}
func (TrieLeafNode) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsBool()
}
func (TrieLeafNode) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsInt()
}
func (TrieLeafNode) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsFloat()
}
func (TrieLeafNode) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsString()
}
func (TrieLeafNode) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsBytes()
}
func (TrieLeafNode) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode"}.AsLink()
}
func (TrieLeafNode) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__Prototype{}
}

type _TrieLeafNode__Prototype struct{}

func (_TrieLeafNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieLeafNode__Builder
	nb.Reset()
	return &nb
}

type _TrieLeafNode__Builder struct {
	_TrieLeafNode__Assembler
}

func (nb *_TrieLeafNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieLeafNode__Builder) Reset() {
	var w _TrieLeafNode
	var m schema.Maybe
	*nb = _TrieLeafNode__Builder{_TrieLeafNode__Assembler{w: &w, m: &m}}
}

type _TrieLeafNode__Assembler struct {
	w     *_TrieLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__Assembler
	ca_Value       _Value__Assembler
}

func (na *_TrieLeafNode__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Value.reset()
}

var (
	fieldBit__TrieLeafNode_PartialPath = 1 << 0
	fieldBit__TrieLeafNode_Value       = 1 << 1
	fieldBits__TrieLeafNode_sufficient = 0 + 1<<0 + 1<<1
)

func (na *_TrieLeafNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieLeafNode{}
	}
	return na, nil
}
func (_TrieLeafNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.BeginList(0)
}
func (na *_TrieLeafNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieLeafNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignBool(false)
}
func (_TrieLeafNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignInt(0)
}
func (_TrieLeafNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignFloat(0)
}
func (_TrieLeafNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignString("")
}
func (_TrieLeafNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignBytes(nil)
}
func (_TrieLeafNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode"}.AssignLink(nil)
}
func (na *_TrieLeafNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieLeafNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieLeafNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__Prototype{}
}
func (ma *_TrieLeafNode__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PartialPath.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Value.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath}
		}
		ma.s += fieldBit__TrieLeafNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Value":
		if ma.s&fieldBit__TrieLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value}
		}
		ma.s += fieldBit__TrieLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode", Key: &_String{k}}
}
func (ma *_TrieLeafNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieLeafNode__KeyAssembler)(ma)
}
func (ma *_TrieLeafNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieLeafNode_sufficient != fieldBits__TrieLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieLeafNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieLeafNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieLeafNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TrieLeafNode__KeyAssembler _TrieLeafNode__Assembler

func (_TrieLeafNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieLeafNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieLeafNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignNull()
}
func (_TrieLeafNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieLeafNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieLeafNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieLeafNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath}
		}
		ka.s += fieldBit__TrieLeafNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
	case "Value":
		if ka.s&fieldBit__TrieLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value}
		}
		ka.s += fieldBit__TrieLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode", Key: &_String{k}}
	}
	return nil
}
func (_TrieLeafNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieLeafNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieLeafNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieLeafNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieLeafNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieLeafNode) Representation() ipld.Node {
	return (*_TrieLeafNode__Repr)(n)
}

type _TrieLeafNode__Repr _TrieLeafNode

var (
	fieldName__TrieLeafNode_PartialPath_serial = _String{"PartialPath"}
	fieldName__TrieLeafNode_Value_serial       = _String{"Value"}
)
var _ ipld.Node = &_TrieLeafNode__Repr{}

func (_TrieLeafNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieLeafNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "PartialPath":
		return n.PartialPath.Representation(), nil
	case "Value":
		return n.Value.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieLeafNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieLeafNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.LookupByIndex(0)
}
func (n _TrieLeafNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieLeafNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieLeafNode__ReprMapItr{n, 0}
}

type _TrieLeafNode__ReprMapItr struct {
	n   *_TrieLeafNode__Repr
	idx int
}

func (itr *_TrieLeafNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TrieLeafNode_PartialPath_serial
		v = itr.n.PartialPath.Representation()
	case 1:
		k = &fieldName__TrieLeafNode_Value_serial
		v = itr.n.Value.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TrieLeafNode__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_TrieLeafNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TrieLeafNode__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_TrieLeafNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieLeafNode__Repr) IsNull() bool {
	return false
}
func (_TrieLeafNode__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsBool()
}
func (_TrieLeafNode__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsInt()
}
func (_TrieLeafNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsFloat()
}
func (_TrieLeafNode__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsString()
}
func (_TrieLeafNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsBytes()
}
func (_TrieLeafNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieLeafNode.Repr"}.AsLink()
}
func (_TrieLeafNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__ReprPrototype{}
}

type _TrieLeafNode__ReprPrototype struct{}

func (_TrieLeafNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieLeafNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieLeafNode__ReprBuilder struct {
	_TrieLeafNode__ReprAssembler
}

func (nb *_TrieLeafNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieLeafNode__ReprBuilder) Reset() {
	var w _TrieLeafNode
	var m schema.Maybe
	*nb = _TrieLeafNode__ReprBuilder{_TrieLeafNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieLeafNode__ReprAssembler struct {
	w     *_TrieLeafNode
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm             schema.Maybe
	ca_PartialPath _Bytes__ReprAssembler
	ca_Value       _Value__ReprAssembler
}

func (na *_TrieLeafNode__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_PartialPath.reset()
	na.ca_Value.reset()
}
func (na *_TrieLeafNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieLeafNode{}
	}
	return na, nil
}
func (_TrieLeafNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.BeginList(0)
}
func (na *_TrieLeafNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieLeafNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignBool(false)
}
func (_TrieLeafNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignInt(0)
}
func (_TrieLeafNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignFloat(0)
}
func (_TrieLeafNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignString("")
}
func (_TrieLeafNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignBytes(nil)
}
func (_TrieLeafNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieLeafNode.Repr"}.AssignLink(nil)
}
func (na *_TrieLeafNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieLeafNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieLeafNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieLeafNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieLeafNode__ReprPrototype{}
}
func (ma *_TrieLeafNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "PartialPath":
		if ma.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath_serial}
		}
		ma.s += fieldBit__TrieLeafNode_PartialPath
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath, nil
	case "Value":
		if ma.s&fieldBit__TrieLeafNode_Value != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value_serial}
		}
		ma.s += fieldBit__TrieLeafNode_Value
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode.Repr", Key: &_String{k}}
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieLeafNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieLeafNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_PartialPath.w = &ma.w.PartialPath
		ma.ca_PartialPath.m = &ma.cm
		return &ma.ca_PartialPath
	case 1:
		ma.ca_Value.w = &ma.w.Value
		ma.ca_Value.m = &ma.cm
		return &ma.ca_Value
	default:
		panic("unreachable")
	}
}
func (ma *_TrieLeafNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TrieLeafNode_sufficient != fieldBits__TrieLeafNode_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TrieLeafNode_PartialPath == 0 {
			err.Missing = append(err.Missing, "PartialPath")
		}
		if ma.s&fieldBit__TrieLeafNode_Value == 0 {
			err.Missing = append(err.Missing, "Value")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieLeafNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieLeafNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TrieLeafNode__ReprKeyAssembler _TrieLeafNode__ReprAssembler

func (_TrieLeafNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieLeafNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieLeafNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieLeafNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieLeafNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "PartialPath":
		if ka.s&fieldBit__TrieLeafNode_PartialPath != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_PartialPath_serial}
		}
		ka.s += fieldBit__TrieLeafNode_PartialPath
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "Value":
		if ka.s&fieldBit__TrieLeafNode_Value != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TrieLeafNode_Value_serial}
		}
		ka.s += fieldBit__TrieLeafNode_Value
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieLeafNode.Repr", Key: &_String{k}}
}
func (_TrieLeafNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieLeafNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieLeafNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieLeafNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieLeafNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n _TrieNode) AsInterface() _TrieNode__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _TrieNode__Maybe struct {
	m schema.Maybe
	v TrieNode
}
type MaybeTrieNode = *_TrieNode__Maybe

func (m MaybeTrieNode) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTrieNode) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTrieNode) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTrieNode) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTrieNode) Must() TrieNode {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__TrieNode_TrieBranchNode    = _String{"TrieBranchNode"}
	memberName__TrieNode_TrieExtensionNode = _String{"TrieExtensionNode"}
	memberName__TrieNode_TrieLeafNode      = _String{"TrieLeafNode"}
)
var _ ipld.Node = (TrieNode)(&_TrieNode{})
var _ schema.TypedNode = (TrieNode)(&_TrieNode{})

func (TrieNode) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TrieNode) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TrieBranchNode":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "TrieExtensionNode":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "TrieLeafNode":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TrieNode) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TrieNode) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.LookupByIndex(0)
}
func (n TrieNode) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TrieNode) MapIterator() ipld.MapIterator {
	return &_TrieNode__MapItr{n, false}
}

type _TrieNode__MapItr struct {
	n    TrieNode
	done bool
}

func (itr *_TrieNode__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TrieNode_TrieBranchNode, &itr.n.x1
	case 2:
		k, v = &memberName__TrieNode_TrieExtensionNode, &itr.n.x2
	case 3:
		k, v = &memberName__TrieNode_TrieLeafNode, &itr.n.x3
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TrieNode__MapItr) Done() bool {
	return itr.done
}

func (TrieNode) ListIterator() ipld.ListIterator {
	return nil
}
func (TrieNode) Length() int64 {
	return 1
}
func (TrieNode) IsAbsent() bool {
	return false
}
func (TrieNode) IsNull() bool {
	return false
}
func (TrieNode) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsBool()
}
func (TrieNode) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsInt()
}
func (TrieNode) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsFloat()
}
func (TrieNode) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsString()
}
func (TrieNode) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsBytes()
}
func (TrieNode) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieNode"}.AsLink()
}
func (TrieNode) Prototype() ipld.NodePrototype {
	return _TrieNode__Prototype{}
}

type _TrieNode__Prototype struct{}

func (_TrieNode__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieNode__Builder
	nb.Reset()
	return &nb
}

type _TrieNode__Builder struct {
	_TrieNode__Assembler
}

func (nb *_TrieNode__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieNode__Builder) Reset() {
	var w _TrieNode
	var m schema.Maybe
	*nb = _TrieNode__Builder{_TrieNode__Assembler{w: &w, m: &m}}
}

type _TrieNode__Assembler struct {
	w     *_TrieNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _TrieBranchNode__Assembler

	ca2 _TrieExtensionNode__Assembler

	ca3 _TrieLeafNode__Assembler
	ca  uint
}

func (na *_TrieNode__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TrieNode__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieNode{}
	}
	return na, nil
}
func (_TrieNode__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.BeginList(0)
}
func (na *_TrieNode__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieNode__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignBool(false)
}
func (_TrieNode__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignInt(0)
}
func (_TrieNode__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignFloat(0)
}
func (_TrieNode__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignString("")
}
func (_TrieNode__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignBytes(nil)
}
func (_TrieNode__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode"}.AssignLink(nil)
}
func (na *_TrieNode__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieNode", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieNode__Assembler) Prototype() ipld.NodePrototype {
	return _TrieNode__Prototype{}
}
func (ma *_TrieNode__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TrieNode__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TrieBranchNode":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "TrieExtensionNode":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "TrieLeafNode":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieNode", Key: &_String{k}}
}
func (ma *_TrieNode__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieNode__KeyAssembler)(ma)
}
func (ma *_TrieNode__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 1:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 2:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 3:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	default:
		panic("unreachable")
	}
}
func (ma *_TrieNode__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieNode__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieNode__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TrieBranchNode":
		return _TrieBranchNode__Prototype{}
	case "TrieExtensionNode":
		return _TrieExtensionNode__Prototype{}
	case "TrieLeafNode":
		return _TrieLeafNode__Prototype{}
	default:
		return nil
	}
}

type _TrieNode__KeyAssembler _TrieNode__Assembler

func (_TrieNode__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.BeginMap(0)
}
func (_TrieNode__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.BeginList(0)
}
func (na *_TrieNode__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignNull()
}
func (_TrieNode__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignBool(false)
}
func (_TrieNode__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignInt(0)
}
func (_TrieNode__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieNode__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "TrieBranchNode":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "TrieExtensionNode":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "TrieLeafNode":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieNode", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_TrieNode__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieNode__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieNode__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieNode__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TrieNode) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TrieNode) Representation() ipld.Node {
	return (*_TrieNode__Repr)(n)
}

type _TrieNode__Repr _TrieNode

var (
	memberName__TrieNode_TrieBranchNode_serial    = _String{"branch"}
	memberName__TrieNode_TrieExtensionNode_serial = _String{"extension"}
	memberName__TrieNode_TrieLeafNode_serial      = _String{"leaf"}
)
var _ ipld.Node = &_TrieNode__Repr{}

func (_TrieNode__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TrieNode__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "branch":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "extension":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "leaf":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TrieNode__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TrieNode__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.LookupByIndex(0)
}
func (n _TrieNode__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TrieNode__Repr) MapIterator() ipld.MapIterator {
	return &_TrieNode__ReprMapItr{n, false}
}

type _TrieNode__ReprMapItr struct {
	n    *_TrieNode__Repr
	done bool
}

func (itr *_TrieNode__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__TrieNode_TrieBranchNode_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__TrieNode_TrieExtensionNode_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__TrieNode_TrieLeafNode_serial, itr.n.x3.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_TrieNode__ReprMapItr) Done() bool {
	return itr.done
}

func (_TrieNode__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_TrieNode__Repr) Length() int64 {
	return 1
}
func (_TrieNode__Repr) IsAbsent() bool {
	return false
}
func (_TrieNode__Repr) IsNull() bool {
	return false
}
func (_TrieNode__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsBool()
}
func (_TrieNode__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsInt()
}
func (_TrieNode__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsFloat()
}
func (_TrieNode__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsString()
}
func (_TrieNode__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsBytes()
}
func (_TrieNode__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TrieNode.Repr"}.AsLink()
}
func (_TrieNode__Repr) Prototype() ipld.NodePrototype {
	return _TrieNode__ReprPrototype{}
}

type _TrieNode__ReprPrototype struct{}

func (_TrieNode__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TrieNode__ReprBuilder
	nb.Reset()
	return &nb
}

type _TrieNode__ReprBuilder struct {
	_TrieNode__ReprAssembler
}

func (nb *_TrieNode__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TrieNode__ReprBuilder) Reset() {
	var w _TrieNode
	var m schema.Maybe
	*nb = _TrieNode__ReprBuilder{_TrieNode__ReprAssembler{w: &w, m: &m}}
}

type _TrieNode__ReprAssembler struct {
	w     *_TrieNode
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _TrieBranchNode__ReprAssembler

	ca2 _TrieExtensionNode__ReprAssembler

	ca3 _TrieLeafNode__ReprAssembler
	ca  uint
}

func (na *_TrieNode__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_TrieNode__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TrieNode{}
	}
	return na, nil
}
func (_TrieNode__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.BeginList(0)
}
func (na *_TrieNode__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TrieNode__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignBool(false)
}
func (_TrieNode__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignInt(0)
}
func (_TrieNode__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignFloat(0)
}
func (_TrieNode__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignString("")
}
func (_TrieNode__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignBytes(nil)
}
func (_TrieNode__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TrieNode.Repr"}.AssignLink(nil)
}
func (na *_TrieNode__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TrieNode); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TrieNode.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TrieNode__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TrieNode__ReprPrototype{}
}
func (ma *_TrieNode__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_TrieNode__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "branch":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "extension":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "leaf":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TrieNode.Repr", Key: &_String{k}}
}
func (ma *_TrieNode__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TrieNode__ReprKeyAssembler)(ma)
}
func (ma *_TrieNode__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	default:
		panic("unreachable")
	}
}
func (ma *_TrieNode__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TrieNode__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TrieNode__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "TrieBranchNode":
		return _TrieBranchNode__ReprPrototype{}
	case "TrieExtensionNode":
		return _TrieExtensionNode__ReprPrototype{}
	case "TrieLeafNode":
		return _TrieLeafNode__ReprPrototype{}
	default:
		return nil
	}
}

type _TrieNode__ReprKeyAssembler _TrieNode__ReprAssembler

func (_TrieNode__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TrieNode__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TrieNode__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignNull()
}
func (_TrieNode__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TrieNode__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TrieNode__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TrieNode__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.TrieNode.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "branch":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "extension":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "leaf":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TrieNode.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_TrieNode__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TrieNode__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TrieNode.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TrieNode__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TrieNode__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_TxCIDList) Lookup(idx int64) Link {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_TxCIDList) LookupMaybe(idx int64) MaybeLink {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Link__Maybe{
		m: schema.Maybe_Value,
		v: *v,
	}
}

var _TxCIDList__valueAbsent = _Link__Maybe{m: schema.Maybe_Absent}

func (n TxCIDList) Iterator() *TxCIDList__Itr {
	return &TxCIDList__Itr{n, 0}
}

type TxCIDList__Itr struct {
	n   TxCIDList
	idx int
}

func (itr *TxCIDList__Itr) Next() (idx int64, v Link) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *TxCIDList__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _TxCIDList__Maybe struct {
	m schema.Maybe
	v _TxCIDList
}
type MaybeTxCIDList = *_TxCIDList__Maybe

func (m MaybeTxCIDList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTxCIDList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTxCIDList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTxCIDList) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTxCIDList) Must() TxCIDList {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (TxCIDList)(&_TxCIDList{})
var _ schema.TypedNode = (TxCIDList)(&_TxCIDList{})

func (TxCIDList) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (TxCIDList) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.LookupByString("")
}
func (n TxCIDList) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n TxCIDList) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n TxCIDList) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.TxCIDList", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (TxCIDList) MapIterator() ipld.MapIterator {
	return nil
}
func (n TxCIDList) ListIterator() ipld.ListIterator {
	return &_TxCIDList__ListItr{n, 0}
}

type _TxCIDList__ListItr struct {
	n   TxCIDList
	idx int
}

func (itr *_TxCIDList__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_TxCIDList__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n TxCIDList) Length() int64 {
	return int64(len(n.x))
}
func (TxCIDList) IsAbsent() bool {
	return false
}
func (TxCIDList) IsNull() bool {
	return false
}
func (TxCIDList) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsBool()
}
func (TxCIDList) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsInt()
}
func (TxCIDList) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsFloat()
}
func (TxCIDList) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsString()
}
func (TxCIDList) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsBytes()
}
func (TxCIDList) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.TxCIDList"}.AsLink()
}
func (TxCIDList) Prototype() ipld.NodePrototype {
	return _TxCIDList__Prototype{}
}

type _TxCIDList__Prototype struct{}

func (_TxCIDList__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TxCIDList__Builder
	nb.Reset()
	return &nb
}

type _TxCIDList__Builder struct {
	_TxCIDList__Assembler
}

func (nb *_TxCIDList__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TxCIDList__Builder) Reset() {
	var w _TxCIDList
	var m schema.Maybe
	*nb = _TxCIDList__Builder{_TxCIDList__Assembler{w: &w, m: &m}}
}

type _TxCIDList__Assembler struct {
	w     *_TxCIDList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Link__Assembler
}

func (na *_TxCIDList__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_TxCIDList__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.BeginMap(0)
}
func (na *_TxCIDList__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Link, 0, sizeHint)
	}
	return na, nil
}
func (na *_TxCIDList__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TxCIDList__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignBool(false)
}
func (_TxCIDList__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignInt(0)
}
func (_TxCIDList__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignFloat(0)
}
func (_TxCIDList__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignString("")
}
func (_TxCIDList__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignBytes(nil)
}
func (_TxCIDList__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList"}.AssignLink(nil)
}
func (na *_TxCIDList__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TxCIDList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.TxCIDList", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TxCIDList__Assembler) Prototype() ipld.NodePrototype {
	return _TxCIDList__Prototype{}
}
func (la *_TxCIDList__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_TxCIDList__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Link{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_TxCIDList__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_TxCIDList__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Link__Prototype{}
}
func (TxCIDList) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TxCIDList) Representation() ipld.Node {
	return (*_TxCIDList__Repr)(n)
}

type _TxCIDList__Repr _TxCIDList

var _ ipld.Node = &_TxCIDList__Repr{}

func (_TxCIDList__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_TxCIDList__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.LookupByString("")
}
func (nr *_TxCIDList__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (TxCIDList)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Link).Representation(), nil
}
func (nr *_TxCIDList__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (TxCIDList)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Link).Representation(), nil
}
func (n _TxCIDList__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.TxCIDList.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_TxCIDList__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_TxCIDList__Repr) ListIterator() ipld.ListIterator {
	return &_TxCIDList__ReprListItr{(TxCIDList)(nr), 0}
}

type _TxCIDList__ReprListItr _TxCIDList__ListItr

func (itr *_TxCIDList__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_TxCIDList__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Link).Representation(), nil
}
func (itr *_TxCIDList__ReprListItr) Done() bool {
	return (*_TxCIDList__ListItr)(itr).Done()
}

func (rn *_TxCIDList__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_TxCIDList__Repr) IsAbsent() bool {
	return false
}
func (_TxCIDList__Repr) IsNull() bool {
	return false
}
func (_TxCIDList__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsBool()
}
func (_TxCIDList__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsInt()
}
func (_TxCIDList__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsFloat()
}
func (_TxCIDList__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsString()
}
func (_TxCIDList__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsBytes()
}
func (_TxCIDList__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.TxCIDList.Repr"}.AsLink()
}
func (_TxCIDList__Repr) Prototype() ipld.NodePrototype {
	return _TxCIDList__ReprPrototype{}
}

type _TxCIDList__ReprPrototype struct{}

func (_TxCIDList__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TxCIDList__ReprBuilder
	nb.Reset()
	return &nb
}

type _TxCIDList__ReprBuilder struct {
	_TxCIDList__ReprAssembler
}

func (nb *_TxCIDList__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TxCIDList__ReprBuilder) Reset() {
	var w _TxCIDList
	var m schema.Maybe
	*nb = _TxCIDList__ReprBuilder{_TxCIDList__ReprAssembler{w: &w, m: &m}}
}

type _TxCIDList__ReprAssembler struct {
	w     *_TxCIDList
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Link__ReprAssembler
}

func (na *_TxCIDList__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_TxCIDList__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.BeginMap(0)
}
func (na *_TxCIDList__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Link, 0, sizeHint)
	}
	return na, nil
}
func (na *_TxCIDList__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TxCIDList__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignBool(false)
}
func (_TxCIDList__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignInt(0)
}
func (_TxCIDList__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignFloat(0)
}
func (_TxCIDList__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignString("")
}
func (_TxCIDList__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignBytes(nil)
}
func (_TxCIDList__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.TxCIDList.Repr"}.AssignLink(nil)
}
func (na *_TxCIDList__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TxCIDList); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.TxCIDList.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TxCIDList__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TxCIDList__ReprPrototype{}
}
func (la *_TxCIDList__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_TxCIDList__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Link{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_TxCIDList__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_TxCIDList__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Link__ReprPrototype{}
}

func (n _TxTrace) FieldTxCIDs() TxCIDList {
	return &n.TxCIDs
}
func (n _TxTrace) FieldStateRootCID() Link {
	return &n.StateRootCID
}
func (n _TxTrace) FieldResult() Bytes {
	return &n.Result
}
func (n _TxTrace) FieldFrames() FrameList {
	return &n.Frames
}
func (n _TxTrace) FieldGas() Uint {
	return &n.Gas
}
func (n _TxTrace) FieldFailed() Bool {
	return &n.Failed
}

type _TxTrace__Maybe struct {
	m schema.Maybe
	v TxTrace
}
type MaybeTxTrace = *_TxTrace__Maybe

func (m MaybeTxTrace) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTxTrace) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTxTrace) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTxTrace) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTxTrace) Must() TxTrace {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	fieldName__TxTrace_TxCIDs       = _String{"TxCIDs"}
	fieldName__TxTrace_StateRootCID = _String{"StateRootCID"}
	fieldName__TxTrace_Result       = _String{"Result"}
	fieldName__TxTrace_Frames       = _String{"Frames"}
	fieldName__TxTrace_Gas          = _String{"Gas"}
	fieldName__TxTrace_Failed       = _String{"Failed"}
)
var _ ipld.Node = (TxTrace)(&_TxTrace{})
var _ schema.TypedNode = (TxTrace)(&_TxTrace{})

func (TxTrace) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n TxTrace) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxCIDs":
		return &n.TxCIDs, nil
	case "StateRootCID":
		return &n.StateRootCID, nil
	case "Result":
		return &n.Result, nil
	case "Frames":
		return &n.Frames, nil
	case "Gas":
		return &n.Gas, nil
	case "Failed":
		return &n.Failed, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n TxTrace) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (TxTrace) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.LookupByIndex(0)
}
func (n TxTrace) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n TxTrace) MapIterator() ipld.MapIterator {
	return &_TxTrace__MapItr{n, 0}
}

type _TxTrace__MapItr struct {
	n   TxTrace
	idx int
}

func (itr *_TxTrace__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 6 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TxTrace_TxCIDs
		v = &itr.n.TxCIDs
	case 1:
		k = &fieldName__TxTrace_StateRootCID
		v = &itr.n.StateRootCID
	case 2:
		k = &fieldName__TxTrace_Result
		v = &itr.n.Result
	case 3:
		k = &fieldName__TxTrace_Frames
		v = &itr.n.Frames
	case 4:
		k = &fieldName__TxTrace_Gas
		v = &itr.n.Gas
	case 5:
		k = &fieldName__TxTrace_Failed
		v = &itr.n.Failed
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TxTrace__MapItr) Done() bool {
	return itr.idx >= 6
}

func (TxTrace) ListIterator() ipld.ListIterator {
	return nil
}
func (TxTrace) Length() int64 {
	return 6
}
func (TxTrace) IsAbsent() bool {
	return false
}
func (TxTrace) IsNull() bool {
	return false
}
func (TxTrace) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsBool()
}
func (TxTrace) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsInt()
}
func (TxTrace) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsFloat()
}
func (TxTrace) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsString()
}
func (TxTrace) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsBytes()
}
func (TxTrace) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TxTrace"}.AsLink()
}
func (TxTrace) Prototype() ipld.NodePrototype {
	return _TxTrace__Prototype{}
}

type _TxTrace__Prototype struct{}

func (_TxTrace__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TxTrace__Builder
	nb.Reset()
	return &nb
}

type _TxTrace__Builder struct {
	_TxTrace__Assembler
}

func (nb *_TxTrace__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TxTrace__Builder) Reset() {
	var w _TxTrace
	var m schema.Maybe
	*nb = _TxTrace__Builder{_TxTrace__Assembler{w: &w, m: &m}}
}

type _TxTrace__Assembler struct {
	w     *_TxTrace
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_TxCIDs       _TxCIDList__Assembler
	ca_StateRootCID _Link__Assembler
	ca_Result       _Bytes__Assembler
	ca_Frames       _FrameList__Assembler
	ca_Gas          _Uint__Assembler
	ca_Failed       _Bool__Assembler
}

func (na *_TxTrace__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxCIDs.reset()
	na.ca_StateRootCID.reset()
	na.ca_Result.reset()
	na.ca_Frames.reset()
	na.ca_Gas.reset()
	na.ca_Failed.reset()
}

var (
	fieldBit__TxTrace_TxCIDs       = 1 << 0
	fieldBit__TxTrace_StateRootCID = 1 << 1
	fieldBit__TxTrace_Result       = 1 << 2
	fieldBit__TxTrace_Frames       = 1 << 3
	fieldBit__TxTrace_Gas          = 1 << 4
	fieldBit__TxTrace_Failed       = 1 << 5
	fieldBits__TxTrace_sufficient  = 0 + 1<<0 + 1<<1 + 1<<2 + 1<<3 + 1<<4 + 1<<5
)

func (na *_TxTrace__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TxTrace{}
	}
	return na, nil
}
func (_TxTrace__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.BeginList(0)
}
func (na *_TxTrace__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TxTrace__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignBool(false)
}
func (_TxTrace__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignInt(0)
}
func (_TxTrace__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignFloat(0)
}
func (_TxTrace__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignString("")
}
func (_TxTrace__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignBytes(nil)
}
func (_TxTrace__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace"}.AssignLink(nil)
}
func (na *_TxTrace__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TxTrace); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TxTrace", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TxTrace__Assembler) Prototype() ipld.NodePrototype {
	return _TxTrace__Prototype{}
}
func (ma *_TxTrace__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_TxCIDs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StateRootCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Result.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Frames.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Gas.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Failed.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TxTrace__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxCIDs":
		if ma.s&fieldBit__TxTrace_TxCIDs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_TxCIDs}
		}
		ma.s += fieldBit__TxTrace_TxCIDs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxCIDs.w = &ma.w.TxCIDs
		ma.ca_TxCIDs.m = &ma.cm
		return &ma.ca_TxCIDs, nil
	case "StateRootCID":
		if ma.s&fieldBit__TxTrace_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_StateRootCID}
		}
		ma.s += fieldBit__TxTrace_StateRootCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "Result":
		if ma.s&fieldBit__TxTrace_Result != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Result}
		}
		ma.s += fieldBit__TxTrace_Result
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Result.w = &ma.w.Result
		ma.ca_Result.m = &ma.cm
		return &ma.ca_Result, nil
	case "Frames":
		if ma.s&fieldBit__TxTrace_Frames != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Frames}
		}
		ma.s += fieldBit__TxTrace_Frames
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Frames.w = &ma.w.Frames
		ma.ca_Frames.m = &ma.cm
		return &ma.ca_Frames, nil
	case "Gas":
		if ma.s&fieldBit__TxTrace_Gas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Gas}
		}
		ma.s += fieldBit__TxTrace_Gas
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas, nil
	case "Failed":
		if ma.s&fieldBit__TxTrace_Failed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Failed}
		}
		ma.s += fieldBit__TxTrace_Failed
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Failed.w = &ma.w.Failed
		ma.ca_Failed.m = &ma.cm
		return &ma.ca_Failed, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TxTrace", Key: &_String{k}}
}
func (ma *_TxTrace__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TxTrace__KeyAssembler)(ma)
}
func (ma *_TxTrace__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxCIDs.w = &ma.w.TxCIDs
		ma.ca_TxCIDs.m = &ma.cm
		return &ma.ca_TxCIDs
	case 1:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 2:
		ma.ca_Result.w = &ma.w.Result
		ma.ca_Result.m = &ma.cm
		return &ma.ca_Result
	case 3:
		ma.ca_Frames.w = &ma.w.Frames
		ma.ca_Frames.m = &ma.cm
		return &ma.ca_Frames
	case 4:
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas
	case 5:
		ma.ca_Failed.w = &ma.w.Failed
		ma.ca_Failed.m = &ma.cm
		return &ma.ca_Failed
	default:
		panic("unreachable")
	}
}
func (ma *_TxTrace__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TxTrace_sufficient != fieldBits__TxTrace_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TxTrace_TxCIDs == 0 {
			err.Missing = append(err.Missing, "TxCIDs")
		}
		if ma.s&fieldBit__TxTrace_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__TxTrace_Result == 0 {
			err.Missing = append(err.Missing, "Result")
		}
		if ma.s&fieldBit__TxTrace_Frames == 0 {
			err.Missing = append(err.Missing, "Frames")
		}
		if ma.s&fieldBit__TxTrace_Gas == 0 {
			err.Missing = append(err.Missing, "Gas")
		}
		if ma.s&fieldBit__TxTrace_Failed == 0 {
			err.Missing = append(err.Missing, "Failed")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TxTrace__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TxTrace__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}

type _TxTrace__KeyAssembler _TxTrace__Assembler

func (_TxTrace__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.BeginMap(0)
}
func (_TxTrace__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.BeginList(0)
}
func (na *_TxTrace__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignNull()
}
func (_TxTrace__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignBool(false)
}
func (_TxTrace__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignInt(0)
}
func (_TxTrace__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TxTrace__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxCIDs":
		if ka.s&fieldBit__TxTrace_TxCIDs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_TxCIDs}
		}
		ka.s += fieldBit__TxTrace_TxCIDs
		ka.state = maState_expectValue
		ka.f = 0
	case "StateRootCID":
		if ka.s&fieldBit__TxTrace_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_StateRootCID}
		}
		ka.s += fieldBit__TxTrace_StateRootCID
		ka.state = maState_expectValue
		ka.f = 1
	case "Result":
		if ka.s&fieldBit__TxTrace_Result != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Result}
		}
		ka.s += fieldBit__TxTrace_Result
		ka.state = maState_expectValue
		ka.f = 2
	case "Frames":
		if ka.s&fieldBit__TxTrace_Frames != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Frames}
		}
		ka.s += fieldBit__TxTrace_Frames
		ka.state = maState_expectValue
		ka.f = 3
	case "Gas":
		if ka.s&fieldBit__TxTrace_Gas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Gas}
		}
		ka.s += fieldBit__TxTrace_Gas
		ka.state = maState_expectValue
		ka.f = 4
	case "Failed":
		if ka.s&fieldBit__TxTrace_Failed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Failed}
		}
		ka.s += fieldBit__TxTrace_Failed
		ka.state = maState_expectValue
		ka.f = 5
	default:
		return ipld.ErrInvalidKey{TypeName: "dageth.TxTrace", Key: &_String{k}}
	}
	return nil
}
func (_TxTrace__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignBytes(nil)
}
func (_TxTrace__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TxTrace__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TxTrace__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (TxTrace) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TxTrace) Representation() ipld.Node {
	return (*_TxTrace__Repr)(n)
}

type _TxTrace__Repr _TxTrace

var (
	fieldName__TxTrace_TxCIDs_serial       = _String{"TxCIDs"}
	fieldName__TxTrace_StateRootCID_serial = _String{"StateRootCID"}
	fieldName__TxTrace_Result_serial       = _String{"Result"}
	fieldName__TxTrace_Frames_serial       = _String{"Frames"}
	fieldName__TxTrace_Gas_serial          = _String{"Gas"}
	fieldName__TxTrace_Failed_serial       = _String{"Failed"}
)
var _ ipld.Node = &_TxTrace__Repr{}

func (_TxTrace__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_TxTrace__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "TxCIDs":
		return n.TxCIDs.Representation(), nil
	case "StateRootCID":
		return n.StateRootCID.Representation(), nil
	case "Result":
		return n.Result.Representation(), nil
	case "Frames":
		return n.Frames.Representation(), nil
	case "Gas":
		return n.Gas.Representation(), nil
	case "Failed":
		return n.Failed.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_TxTrace__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_TxTrace__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.LookupByIndex(0)
}
func (n _TxTrace__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_TxTrace__Repr) MapIterator() ipld.MapIterator {
	return &_TxTrace__ReprMapItr{n, 0}
}

type _TxTrace__ReprMapItr struct {
	n   *_TxTrace__Repr
	idx int
}

func (itr *_TxTrace__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 6 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__TxTrace_TxCIDs_serial
		v = itr.n.TxCIDs.Representation()
	case 1:
		k = &fieldName__TxTrace_StateRootCID_serial
		v = itr.n.StateRootCID.Representation()
	case 2:
		k = &fieldName__TxTrace_Result_serial
		v = itr.n.Result.Representation()
	case 3:
		k = &fieldName__TxTrace_Frames_serial
		v = itr.n.Frames.Representation()
	case 4:
		k = &fieldName__TxTrace_Gas_serial
		v = itr.n.Gas.Representation()
	case 5:
		k = &fieldName__TxTrace_Failed_serial
		v = itr.n.Failed.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_TxTrace__ReprMapItr) Done() bool {
	return itr.idx >= 6
}
func (_TxTrace__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_TxTrace__Repr) Length() int64 {
	l := 6
	return int64(l)
}
func (_TxTrace__Repr) IsAbsent() bool {
	return false
}
func (_TxTrace__Repr) IsNull() bool {
	return false
}
func (_TxTrace__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsBool()
}
func (_TxTrace__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsInt()
}
func (_TxTrace__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsFloat()
}
func (_TxTrace__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsString()
}
func (_TxTrace__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsBytes()
}
func (_TxTrace__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.TxTrace.Repr"}.AsLink()
}
func (_TxTrace__Repr) Prototype() ipld.NodePrototype {
	return _TxTrace__ReprPrototype{}
}

type _TxTrace__ReprPrototype struct{}

func (_TxTrace__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _TxTrace__ReprBuilder
	nb.Reset()
	return &nb
}

type _TxTrace__ReprBuilder struct {
	_TxTrace__ReprAssembler
}

func (nb *_TxTrace__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TxTrace__ReprBuilder) Reset() {
	var w _TxTrace
	var m schema.Maybe
	*nb = _TxTrace__ReprBuilder{_TxTrace__ReprAssembler{w: &w, m: &m}}
}

type _TxTrace__ReprAssembler struct {
	w     *_TxTrace
	m     *schema.Maybe
	state maState
	s     int
	f     int

	cm              schema.Maybe
	ca_TxCIDs       _TxCIDList__ReprAssembler
	ca_StateRootCID _Link__ReprAssembler
	ca_Result       _Bytes__ReprAssembler
	ca_Frames       _FrameList__ReprAssembler
	ca_Gas          _Uint__ReprAssembler
	ca_Failed       _Bool__ReprAssembler
}

func (na *_TxTrace__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_TxCIDs.reset()
	na.ca_StateRootCID.reset()
	na.ca_Result.reset()
	na.ca_Frames.reset()
	na.ca_Gas.reset()
	na.ca_Failed.reset()
}
func (na *_TxTrace__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_TxTrace{}
	}
	return na, nil
}
func (_TxTrace__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.BeginList(0)
}
func (na *_TxTrace__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_TxTrace__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignBool(false)
}
func (_TxTrace__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignInt(0)
}
func (_TxTrace__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignFloat(0)
}
func (_TxTrace__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignString("")
}
func (_TxTrace__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignBytes(nil)
}
func (_TxTrace__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.TxTrace.Repr"}.AssignLink(nil)
}
func (na *_TxTrace__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TxTrace); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.TxTrace.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_TxTrace__ReprAssembler) Prototype() ipld.NodePrototype {
	return _TxTrace__ReprPrototype{}
}
func (ma *_TxTrace__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_TxTrace__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "TxCIDs":
		if ma.s&fieldBit__TxTrace_TxCIDs != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_TxCIDs_serial}
		}
		ma.s += fieldBit__TxTrace_TxCIDs
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_TxCIDs.w = &ma.w.TxCIDs
		ma.ca_TxCIDs.m = &ma.cm
		return &ma.ca_TxCIDs, nil
	case "StateRootCID":
		if ma.s&fieldBit__TxTrace_StateRootCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_StateRootCID_serial}
		}
		ma.s += fieldBit__TxTrace_StateRootCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID, nil
	case "Result":
		if ma.s&fieldBit__TxTrace_Result != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Result_serial}
		}
		ma.s += fieldBit__TxTrace_Result
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Result.w = &ma.w.Result
		ma.ca_Result.m = &ma.cm
		return &ma.ca_Result, nil
	case "Frames":
		if ma.s&fieldBit__TxTrace_Frames != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Frames_serial}
		}
		ma.s += fieldBit__TxTrace_Frames
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Frames.w = &ma.w.Frames
		ma.ca_Frames.m = &ma.cm
		return &ma.ca_Frames, nil
	case "Gas":
		if ma.s&fieldBit__TxTrace_Gas != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Gas_serial}
		}
		ma.s += fieldBit__TxTrace_Gas
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas, nil
	case "Failed":
		if ma.s&fieldBit__TxTrace_Failed != 0 {
			return nil, ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Failed_serial}
		}
		ma.s += fieldBit__TxTrace_Failed
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Failed.w = &ma.w.Failed
		ma.ca_Failed.m = &ma.cm
		return &ma.ca_Failed, nil
	default:
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.TxTrace.Repr", Key: &_String{k}}
}
func (ma *_TxTrace__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_TxTrace__ReprKeyAssembler)(ma)
}
func (ma *_TxTrace__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_TxCIDs.w = &ma.w.TxCIDs
		ma.ca_TxCIDs.m = &ma.cm
		return &ma.ca_TxCIDs
	case 1:
		ma.ca_StateRootCID.w = &ma.w.StateRootCID
		ma.ca_StateRootCID.m = &ma.cm
		return &ma.ca_StateRootCID
	case 2:
		ma.ca_Result.w = &ma.w.Result
		ma.ca_Result.m = &ma.cm
		return &ma.ca_Result
	case 3:
		ma.ca_Frames.w = &ma.w.Frames
		ma.ca_Frames.m = &ma.cm
		return &ma.ca_Frames
	case 4:
		ma.ca_Gas.w = &ma.w.Gas
		ma.ca_Gas.m = &ma.cm
		return &ma.ca_Gas
	case 5:
		ma.ca_Failed.w = &ma.w.Failed
		ma.ca_Failed.m = &ma.cm
		return &ma.ca_Failed
	default:
		panic("unreachable")
	}
}
func (ma *_TxTrace__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s&fieldBits__TxTrace_sufficient != fieldBits__TxTrace_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s&fieldBit__TxTrace_TxCIDs == 0 {
			err.Missing = append(err.Missing, "TxCIDs")
		}
		if ma.s&fieldBit__TxTrace_StateRootCID == 0 {
			err.Missing = append(err.Missing, "StateRootCID")
		}
		if ma.s&fieldBit__TxTrace_Result == 0 {
			err.Missing = append(err.Missing, "Result")
		}
		if ma.s&fieldBit__TxTrace_Frames == 0 {
			err.Missing = append(err.Missing, "Frames")
		}
		if ma.s&fieldBit__TxTrace_Gas == 0 {
			err.Missing = append(err.Missing, "Gas")
		}
		if ma.s&fieldBit__TxTrace_Failed == 0 {
			err.Missing = append(err.Missing, "Failed")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_TxTrace__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_TxTrace__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}

type _TxTrace__ReprKeyAssembler _TxTrace__ReprAssembler

func (_TxTrace__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.BeginMap(0)
}
func (_TxTrace__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_TxTrace__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignNull()
}
func (_TxTrace__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignBool(false)
}
func (_TxTrace__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignInt(0)
}
func (_TxTrace__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_TxTrace__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "TxCIDs":
		if ka.s&fieldBit__TxTrace_TxCIDs != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_TxCIDs_serial}
		}
		ka.s += fieldBit__TxTrace_TxCIDs
		ka.state = maState_expectValue
		ka.f = 0
		return nil
	case "StateRootCID":
		if ka.s&fieldBit__TxTrace_StateRootCID != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_StateRootCID_serial}
		}
		ka.s += fieldBit__TxTrace_StateRootCID
		ka.state = maState_expectValue
		ka.f = 1
		return nil
	case "Result":
		if ka.s&fieldBit__TxTrace_Result != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Result_serial}
		}
		ka.s += fieldBit__TxTrace_Result
		ka.state = maState_expectValue
		ka.f = 2
		return nil
	case "Frames":
		if ka.s&fieldBit__TxTrace_Frames != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Frames_serial}
		}
		ka.s += fieldBit__TxTrace_Frames
		ka.state = maState_expectValue
		ka.f = 3
		return nil
	case "Gas":
		if ka.s&fieldBit__TxTrace_Gas != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Gas_serial}
		}
		ka.s += fieldBit__TxTrace_Gas
		ka.state = maState_expectValue
		ka.f = 4
		return nil
	case "Failed":
		if ka.s&fieldBit__TxTrace_Failed != 0 {
			return ipld.ErrRepeatedMapKey{Key: &fieldName__TxTrace_Failed_serial}
		}
		ka.s += fieldBit__TxTrace_Failed
		ka.state = maState_expectValue
		ka.f = 5
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.TxTrace.Repr", Key: &_String{k}}
}
func (_TxTrace__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_TxTrace__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.TxTrace.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_TxTrace__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_TxTrace__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n TxType) Bytes() []byte {
	return n.x
}
func (_TxType__Prototype) FromBytes(v []byte) (TxType, error) {
	n := _TxType{v}
	return &n, nil
}

type _TxType__Maybe struct {
	m schema.Maybe
	v _TxType
}
type MaybeTxType = *_TxType__Maybe

func (m MaybeTxType) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTxType) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTxType) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTxType) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeTxType) Must() TxType {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (TxType)(&_TxType{})
var _ schema.TypedNode = (TxType)(&_TxType{})

func (TxType) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (TxType) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.LookupByString("")
}
func (TxType) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.LookupByNode(nil)
}
func (TxType) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.LookupByIndex(0)
}
func (TxType) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.LookupBySegment(seg)
}
func (TxType) MapIterator() ipld.MapIterator {
	return nil
}
func (TxType) ListIterator() ipld.ListIterator {
	return nil
}
func (TxType) Length() int64 {
	return -1
}
func (TxType) IsAbsent() bool {
	return false
}
func (TxType) IsNull() bool {
	return false
}
func (TxType) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.AsBool()
}
func (TxType) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.AsInt()
}
func (TxType) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.AsFloat()
}
func (TxType) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.AsString()
}
func (n TxType) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (TxType) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.TxType"}.AsLink()
}
func (TxType) Prototype() ipld.NodePrototype {
	return _TxType__Prototype{}
}

type _TxType__Prototype struct{}

func (_TxType__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _TxType__Builder
	nb.Reset()
	return &nb
}

type _TxType__Builder struct {
	_TxType__Assembler
}

func (nb *_TxType__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_TxType__Builder) Reset() {
	var w _TxType
	var m schema.Maybe
	*nb = _TxType__Builder{_TxType__Assembler{w: &w, m: &m}}
}

type _TxType__Assembler struct {
	w *_TxType
	m *schema.Maybe
}

func (na *_TxType__Assembler) reset() {}
func (_TxType__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.BeginMap(0)
}
func (_TxType__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.BeginList(0)
}
func (na *_TxType__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_TxType__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignBool(false)
}
func (_TxType__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignInt(0)
}
func (_TxType__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignFloat(0)
}
func (_TxType__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignString("")
}
func (na *_TxType__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_TxType__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.TxType"}.AssignLink(nil)
}
func (na *_TxType__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_TxType); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_TxType__Assembler) Prototype() ipld.NodePrototype {
	return _TxType__Prototype{}
}
func (TxType) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n TxType) Representation() ipld.Node {
	return (*_TxType__Repr)(n)
}

type _TxType__Repr = _TxType

var _ ipld.Node = &_TxType__Repr{}

type _TxType__ReprPrototype = _TxType__Prototype
type _TxType__ReprAssembler = _TxType__Assembler

func (n Uint) Bytes() []byte {
	return n.x
}
func (_Uint__Prototype) FromBytes(v []byte) (Uint, error) {
	n := _Uint{v}
	return &n, nil
}

type _Uint__Maybe struct {
	m schema.Maybe
	v _Uint
}
type MaybeUint = *_Uint__Maybe

func (m MaybeUint) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUint) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUint) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUint) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUint) Must() Uint {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Uint)(&_Uint{})
var _ schema.TypedNode = (Uint)(&_Uint{})

func (Uint) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Uint) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.LookupByString("")
}
func (Uint) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.LookupByNode(nil)
}
func (Uint) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.LookupByIndex(0)
}
func (Uint) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.LookupBySegment(seg)
}
func (Uint) MapIterator() ipld.MapIterator {
	return nil
}
func (Uint) ListIterator() ipld.ListIterator {
	return nil
}
func (Uint) Length() int64 {
	return -1
}
func (Uint) IsAbsent() bool {
	return false
}
func (Uint) IsNull() bool {
	return false
}
func (Uint) AsBool() (bool, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.AsBool()
}
func (Uint) AsInt() (int64, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.AsInt()
}
func (Uint) AsFloat() (float64, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.AsFloat()
}
func (Uint) AsString() (string, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.AsString()
}
func (n Uint) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Uint) AsLink() (ipld.Link, error) {
	return mixins.Bytes{TypeName: "dageth.Uint"}.AsLink()
}
func (Uint) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}

type _Uint__Prototype struct{}

func (_Uint__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uint__Builder
	nb.Reset()
	return &nb
}

type _Uint__Builder struct {
	_Uint__Assembler
}

func (nb *_Uint__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uint__Builder) Reset() {
	var w _Uint
	var m schema.Maybe
	*nb = _Uint__Builder{_Uint__Assembler{w: &w, m: &m}}
}

type _Uint__Assembler struct {
	w *_Uint
	m *schema.Maybe
}

func (na *_Uint__Assembler) reset() {}
func (_Uint__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.BeginMap(0)
}
func (_Uint__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.BeginList(0)
}
func (na *_Uint__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Uint__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignBool(false)
}
func (_Uint__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignInt(0)
}
func (_Uint__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignFloat(0)
}
func (_Uint__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignString("")
}
func (na *_Uint__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Uint__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{TypeName: "dageth.Uint"}.AssignLink(nil)
}
func (na *_Uint__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uint); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Uint__Assembler) Prototype() ipld.NodePrototype {
	return _Uint__Prototype{}
}
func (Uint) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uint) Representation() ipld.Node {
	return (*_Uint__Repr)(n)
}

type _Uint__Repr = _Uint

var _ ipld.Node = &_Uint__Repr{}

type _Uint__ReprPrototype = _Uint__Prototype
type _Uint__ReprAssembler = _Uint__Assembler

func (n *_Uncles) Lookup(idx int64) Header {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Uncles) LookupMaybe(idx int64) MaybeHeader {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Header__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Uncles__valueAbsent = _Header__Maybe{m: schema.Maybe_Absent}

func (n Uncles) Iterator() *Uncles__Itr {
	return &Uncles__Itr{n, 0}
}

type Uncles__Itr struct {
	n   Uncles
	idx int
}

func (itr *Uncles__Itr) Next() (idx int64, v Header) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Uncles__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Uncles__Maybe struct {
	m schema.Maybe
	v _Uncles
}
type MaybeUncles = *_Uncles__Maybe

func (m MaybeUncles) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUncles) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUncles) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUncles) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return &m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeUncles) Must() Uncles {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return &m.v
}

var _ ipld.Node = (Uncles)(&_Uncles{})
var _ schema.TypedNode = (Uncles)(&_Uncles{})

func (Uncles) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Uncles) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.LookupByString("")
}
func (n Uncles) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Uncles) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Uncles) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Uncles", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Uncles) MapIterator() ipld.MapIterator {
	return nil
}
func (n Uncles) ListIterator() ipld.ListIterator {
	return &_Uncles__ListItr{n, 0}
}

type _Uncles__ListItr struct {
	n   Uncles
	idx int
}

func (itr *_Uncles__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Uncles__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Uncles) Length() int64 {
	return int64(len(n.x))
}
func (Uncles) IsAbsent() bool {
	return false
}
func (Uncles) IsNull() bool {
	return false
}
func (Uncles) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsBool()
}
func (Uncles) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsInt()
}
func (Uncles) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsFloat()
}
func (Uncles) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsString()
}
func (Uncles) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsBytes()
}
func (Uncles) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Uncles"}.AsLink()
}
func (Uncles) Prototype() ipld.NodePrototype {
	return _Uncles__Prototype{}
}

type _Uncles__Prototype struct{}

func (_Uncles__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uncles__Builder
	nb.Reset()
	return &nb
}

type _Uncles__Builder struct {
	_Uncles__Assembler
}

func (nb *_Uncles__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uncles__Builder) Reset() {
	var w _Uncles
	var m schema.Maybe
	*nb = _Uncles__Builder{_Uncles__Assembler{w: &w, m: &m}}
}

type _Uncles__Assembler struct {
	w     *_Uncles
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Header__Assembler
}

func (na *_Uncles__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Uncles__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.BeginMap(0)
}
func (na *_Uncles__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Header, 0, sizeHint)
	}
	return na, nil
}
func (na *_Uncles__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Uncles__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignBool(false)
}
func (_Uncles__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignInt(0)
}
func (_Uncles__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignFloat(0)
}
func (_Uncles__Assembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignString("")
}
func (_Uncles__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignBytes(nil)
}
func (_Uncles__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles"}.AssignLink(nil)
}
func (na *_Uncles__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uncles); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Uncles", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Uncles__Assembler) Prototype() ipld.NodePrototype {
	return _Uncles__Prototype{}
}
func (la *_Uncles__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Uncles__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Header{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Uncles__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Uncles__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Header__Prototype{}
}
func (Uncles) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Uncles) Representation() ipld.Node {
	return (*_Uncles__Repr)(n)
}

type _Uncles__Repr _Uncles

var _ ipld.Node = &_Uncles__Repr{}

func (_Uncles__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Uncles__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.LookupByString("")
}
func (nr *_Uncles__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Uncles)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Header).Representation(), nil
}
func (nr *_Uncles__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Uncles)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Header).Representation(), nil
}
func (n _Uncles__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "dageth.Uncles.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Uncles__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Uncles__Repr) ListIterator() ipld.ListIterator {
	return &_Uncles__ReprListItr{(Uncles)(nr), 0}
}

type _Uncles__ReprListItr _Uncles__ListItr

func (itr *_Uncles__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Uncles__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Header).Representation(), nil
}
func (itr *_Uncles__ReprListItr) Done() bool {
	return (*_Uncles__ListItr)(itr).Done()
}

func (rn *_Uncles__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Uncles__Repr) IsAbsent() bool {
	return false
}
func (_Uncles__Repr) IsNull() bool {
	return false
}
func (_Uncles__Repr) AsBool() (bool, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsBool()
}
func (_Uncles__Repr) AsInt() (int64, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsInt()
}
func (_Uncles__Repr) AsFloat() (float64, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsFloat()
}
func (_Uncles__Repr) AsString() (string, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsString()
}
func (_Uncles__Repr) AsBytes() ([]byte, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsBytes()
}
func (_Uncles__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{TypeName: "dageth.Uncles.Repr"}.AsLink()
}
func (_Uncles__Repr) Prototype() ipld.NodePrototype {
	return _Uncles__ReprPrototype{}
}

type _Uncles__ReprPrototype struct{}

func (_Uncles__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Uncles__ReprBuilder
	nb.Reset()
	return &nb
}

type _Uncles__ReprBuilder struct {
	_Uncles__ReprAssembler
}

func (nb *_Uncles__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Uncles__ReprBuilder) Reset() {
	var w _Uncles
	var m schema.Maybe
	*nb = _Uncles__ReprBuilder{_Uncles__ReprAssembler{w: &w, m: &m}}
}

type _Uncles__ReprAssembler struct {
	w     *_Uncles
	m     *schema.Maybe
	state laState

	cm schema.Maybe
	va _Header__ReprAssembler
}

func (na *_Uncles__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Uncles__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.BeginMap(0)
}
func (na *_Uncles__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if sizeHint > 0 {
		na.w.x = make([]_Header, 0, sizeHint)
	}
	return na, nil
}
func (na *_Uncles__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Uncles__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignBool(false)
}
func (_Uncles__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignInt(0)
}
func (_Uncles__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignFloat(0)
}
func (_Uncles__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignString("")
}
func (_Uncles__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignBytes(nil)
}
func (_Uncles__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{TypeName: "dageth.Uncles.Repr"}.AssignLink(nil)
}
func (na *_Uncles__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Uncles); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "dageth.Uncles.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Uncles__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Uncles__ReprPrototype{}
}
func (la *_Uncles__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Uncles__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Header{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Uncles__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Uncles__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Header__ReprPrototype{}
}

func (n _Value) AsInterface() _Value__iface {
	switch n.tag {
	case 1:
		return &n.x1
	case 2:
		return &n.x2
	case 3:
		return &n.x3
	case 4:
		return &n.x4
	case 5:
		return &n.x5
	default:
		panic("invalid union state; how did you create this object?")
	}
}

type _Value__Maybe struct {
	m schema.Maybe
	v Value
}
type MaybeValue = *_Value__Maybe

func (m MaybeValue) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeValue) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeValue) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeValue) AsNode() ipld.Node {
	switch m.m {
	case schema.Maybe_Absent:
		return ipld.Absent
	case schema.Maybe_Null:
		return ipld.Null
	case schema.Maybe_Value:
		return m.v
	default:
		panic("unreachable")
	}
}
func (m MaybeValue) Must() Value {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}

var (
	memberName__Value_Transaction = _String{"Transaction"}
	memberName__Value_Receipt     = _String{"Receipt"}
	memberName__Value_Account     = _String{"Account"}
	memberName__Value_Bytes       = _String{"Bytes"}
	memberName__Value_Log         = _String{"Log"}
)
var _ ipld.Node = (Value)(&_Value{})
var _ schema.TypedNode = (Value)(&_Value{})

func (Value) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Value) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Transaction":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x1, nil
	case "Receipt":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x2, nil
	case "Account":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x3, nil
	case "Bytes":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x4, nil
	case "Log":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return &n.x5, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Value) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Value) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Value"}.LookupByIndex(0)
}
func (n Value) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Value) MapIterator() ipld.MapIterator {
	return &_Value__MapItr{n, false}
}

type _Value__MapItr struct {
	n    Value
	done bool
}

func (itr *_Value__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Value_Transaction, &itr.n.x1
	case 2:
		k, v = &memberName__Value_Receipt, &itr.n.x2
	case 3:
		k, v = &memberName__Value_Account, &itr.n.x3
	case 4:
		k, v = &memberName__Value_Bytes, &itr.n.x4
	case 5:
		k, v = &memberName__Value_Log, &itr.n.x5
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Value__MapItr) Done() bool {
	return itr.done
}

func (Value) ListIterator() ipld.ListIterator {
	return nil
}
func (Value) Length() int64 {
	return 1
}
func (Value) IsAbsent() bool {
	return false
}
func (Value) IsNull() bool {
	return false
}
func (Value) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsBool()
}
func (Value) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsInt()
}
func (Value) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsFloat()
}
func (Value) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsString()
}
func (Value) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsBytes()
}
func (Value) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Value"}.AsLink()
}
func (Value) Prototype() ipld.NodePrototype {
	return _Value__Prototype{}
}

type _Value__Prototype struct{}

func (_Value__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Value__Builder
	nb.Reset()
	return &nb
}

type _Value__Builder struct {
	_Value__Assembler
}

func (nb *_Value__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Value__Builder) Reset() {
	var w _Value
	var m schema.Maybe
	*nb = _Value__Builder{_Value__Assembler{w: &w, m: &m}}
}

type _Value__Assembler struct {
	w     *_Value
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _Transaction__Assembler

	ca2 _Receipt__Assembler

	ca3 _Account__Assembler

	ca4 _Bytes__Assembler

	ca5 _Log__Assembler
	ca  uint
}

func (na *_Value__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()

	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Value__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Value{}
	}
	return na, nil
}
func (_Value__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.BeginList(0)
}
func (na *_Value__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Value__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignBool(false)
}
func (_Value__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignInt(0)
}
func (_Value__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignFloat(0)
}
func (_Value__Assembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignString("")
}
func (_Value__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignBytes(nil)
}
func (_Value__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Value"}.AssignLink(nil)
}
func (na *_Value__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Value); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Value", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Value__Assembler) Prototype() ipld.NodePrototype {
	return _Value__Prototype{}
}
func (ma *_Value__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Value__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.Value", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Transaction":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "Receipt":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "Account":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "Bytes":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "Log":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Value", Key: &_String{k}}
}
func (ma *_Value__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Value__KeyAssembler)(ma)
}
func (ma *_Value__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 1:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 2:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 3:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 4:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 5:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	default:
		panic("unreachable")
	}
}
func (ma *_Value__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Value", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Value__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Value__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "Transaction":
		return _Transaction__Prototype{}
	case "Receipt":
		return _Receipt__Prototype{}
	case "Account":
		return _Account__Prototype{}
	case "Bytes":
		return _Bytes__Prototype{}
	case "Log":
		return _Log__Prototype{}
	default:
		return nil
	}
}

type _Value__KeyAssembler _Value__Assembler

func (_Value__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.BeginMap(0)
}
func (_Value__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.BeginList(0)
}
func (na *_Value__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignNull()
}
func (_Value__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignBool(false)
}
func (_Value__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignInt(0)
}
func (_Value__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Value__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Value", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Transaction":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "Receipt":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "Account":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "Bytes":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "Log":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Value", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Value__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignBytes(nil)
}
func (_Value__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Value__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Value__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Value) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Value) Representation() ipld.Node {
	return (*_Value__Repr)(n)
}

type _Value__Repr _Value

var (
	memberName__Value_Transaction_serial = _String{"tx"}
	memberName__Value_Receipt_serial     = _String{"rct"}
	memberName__Value_Account_serial     = _String{"state"}
	memberName__Value_Bytes_serial       = _String{"storage"}
	memberName__Value_Log_serial         = _String{"log"}
)
var _ ipld.Node = &_Value__Repr{}

func (_Value__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Value__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "tx":
		if n.tag != 1 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x1.Representation(), nil
	case "rct":
		if n.tag != 2 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x2.Representation(), nil
	case "state":
		if n.tag != 3 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x3.Representation(), nil
	case "storage":
		if n.tag != 4 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x4.Representation(), nil
	case "log":
		if n.tag != 5 {
			return nil, ipld.ErrNotExists{Segment: ipld.PathSegmentOfString(key)}
		}
		return n.x5.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Value__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Value__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.LookupByIndex(0)
}
func (n _Value__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Value__Repr) MapIterator() ipld.MapIterator {
	return &_Value__ReprMapItr{n, false}
}

type _Value__ReprMapItr struct {
	n    *_Value__Repr
	done bool
}

func (itr *_Value__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.n.tag {
	case 1:
		k, v = &memberName__Value_Transaction_serial, itr.n.x1.Representation()
	case 2:
		k, v = &memberName__Value_Receipt_serial, itr.n.x2.Representation()
	case 3:
		k, v = &memberName__Value_Account_serial, itr.n.x3.Representation()
	case 4:
		k, v = &memberName__Value_Bytes_serial, itr.n.x4.Representation()
	case 5:
		k, v = &memberName__Value_Log_serial, itr.n.x5.Representation()
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Value__ReprMapItr) Done() bool {
	return itr.done
}

func (_Value__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (_Value__Repr) Length() int64 {
	return 1
}
func (_Value__Repr) IsAbsent() bool {
	return false
}
func (_Value__Repr) IsNull() bool {
	return false
}
func (_Value__Repr) AsBool() (bool, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsBool()
}
func (_Value__Repr) AsInt() (int64, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsInt()
}
func (_Value__Repr) AsFloat() (float64, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsFloat()
}
func (_Value__Repr) AsString() (string, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsString()
}
func (_Value__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsBytes()
}
func (_Value__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{TypeName: "dageth.Value.Repr"}.AsLink()
}
func (_Value__Repr) Prototype() ipld.NodePrototype {
	return _Value__ReprPrototype{}
}

type _Value__ReprPrototype struct{}

func (_Value__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Value__ReprBuilder
	nb.Reset()
	return &nb
}

type _Value__ReprBuilder struct {
	_Value__ReprAssembler
}

func (nb *_Value__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Value__ReprBuilder) Reset() {
	var w _Value
	var m schema.Maybe
	*nb = _Value__ReprBuilder{_Value__ReprAssembler{w: &w, m: &m}}
}

type _Value__ReprAssembler struct {
	w     *_Value
	m     *schema.Maybe
	state maState

	cm  schema.Maybe
	ca1 _Transaction__ReprAssembler

	ca2 _Receipt__ReprAssembler

	ca3 _Account__ReprAssembler

	ca4 _Bytes__ReprAssembler

	ca5 _Log__ReprAssembler
	ca  uint
}

func (na *_Value__ReprAssembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()

	case 2:
		na.ca2.reset()

	case 3:
		na.ca3.reset()

	case 4:
		na.ca4.reset()

	case 5:
		na.ca5.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Value__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Value{}
	}
	return na, nil
}
func (_Value__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.BeginList(0)
}
func (na *_Value__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{TypeName: "dageth.Value.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Value__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignBool(false)
}
func (_Value__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignInt(0)
}
func (_Value__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignFloat(0)
}
func (_Value__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignString("")
}
func (_Value__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignBytes(nil)
}
func (_Value__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{TypeName: "dageth.Value.Repr"}.AssignLink(nil)
}
func (na *_Value__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Value); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "dageth.Value.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Value__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Value__ReprPrototype{}
}
func (ma *_Value__ReprAssembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Value__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName: "dageth.Value.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "tx":
		ma.state = maState_midValue
		ma.ca = 1
		ma.w.tag = 1
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1, nil
	case "rct":
		ma.state = maState_midValue
		ma.ca = 2
		ma.w.tag = 2
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2, nil
	case "state":
		ma.state = maState_midValue
		ma.ca = 3
		ma.w.tag = 3
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3, nil
	case "storage":
		ma.state = maState_midValue
		ma.ca = 4
		ma.w.tag = 4
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4, nil
	case "log":
		ma.state = maState_midValue
		ma.ca = 5
		ma.w.tag = 5
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5, nil
	}
	return nil, ipld.ErrInvalidKey{TypeName: "dageth.Value.Repr", Key: &_String{k}}
}
func (ma *_Value__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Value__ReprKeyAssembler)(ma)
}
func (ma *_Value__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		ma.ca1.w = &ma.w.x1
		ma.ca1.m = &ma.cm
		return &ma.ca1
	case 1:
		ma.ca2.w = &ma.w.x2
		ma.ca2.m = &ma.cm
		return &ma.ca2
	case 2:
		ma.ca3.w = &ma.w.x3
		ma.ca3.m = &ma.cm
		return &ma.ca3
	case 3:
		ma.ca4.w = &ma.w.x4
		ma.ca4.m = &ma.cm
		return &ma.ca4
	case 4:
		ma.ca5.w = &ma.w.x5
		ma.ca5.m = &ma.cm
		return &ma.ca5
	default:
		panic("unreachable")
	}
}
func (ma *_Value__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Value.Repr", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Value__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Value__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "Transaction":
		return _Transaction__ReprPrototype{}
	case "Receipt":
		return _Receipt__ReprPrototype{}
	case "Account":
		return _Account__ReprPrototype{}
	case "Bytes":
		return _Bytes__ReprPrototype{}
	case "Log":
		return _Log__ReprPrototype{}
	default:
		return nil
	}
}

type _Value__ReprKeyAssembler _Value__ReprAssembler

func (_Value__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Value__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Value__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignNull()
}
func (_Value__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Value__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Value__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Value__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName: "dageth.Value.Repr", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "tx":
		ka.ca = 1
		ka.w.tag = 1
		ka.state = maState_expectValue
		return nil
	case "rct":
		ka.ca = 2
		ka.w.tag = 2
		ka.state = maState_expectValue
		return nil
	case "state":
		ka.ca = 3
		ka.w.tag = 3
		ka.state = maState_expectValue
		return nil
	case "storage":
		ka.ca = 4
		ka.w.tag = 4
		ka.state = maState_expectValue
		return nil
	case "log":
		ka.ca = 5
		ka.w.tag = 5
		ka.state = maState_expectValue
		return nil
	}
	return ipld.ErrInvalidKey{TypeName: "dageth.Value.Repr", Key: &_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
}
func (_Value__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Value__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{TypeName: "dageth.Value.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Value__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Value__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
